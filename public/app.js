!function(e){function n(e){var n=document.getElementsByTagName("head")[0],t=document.createElement("script");t.type="text/javascript",t.charset="utf-8",t.src=p.p+""+e+"."+g+".hot-update.js",n.appendChild(t)}function t(e){if("undefined"==typeof XMLHttpRequest)return e(new Error("No browser support"));try{var n=new XMLHttpRequest,t=p.p+""+g+".hot-update.json";n.open("GET",t,!0),n.timeout=1e4,n.send(null)}catch(r){return e(r)}n.onreadystatechange=function(){if(4===n.readyState)if(0===n.status)e(new Error("Manifest request to "+t+" timed out."));else if(404===n.status)e();else if(200!==n.status&&304!==n.status)e(new Error("Manifest request to "+t+" failed."));else{try{var r=JSON.parse(n.responseText)}catch(a){return void e(a)}e(null,r)}}}function r(e){function n(e,n){"ready"===x&&i("prepare"),_++,p.e(e,function(){function t(){_--,"prepare"===x&&(S[e]||u(e),0===_&&0===k&&c())}try{n.call(null,r)}finally{t()}})}var t=Q[e];if(!t)return p;var r=function(n){return t.hot.active?Q[n]?(Q[n].parents.indexOf(e)<0&&Q[n].parents.push(e),t.children.indexOf(n)<0&&t.children.push(n)):j=[e]:(console.warn("[HMR] unexpected require("+n+") from disposed module "+e),j=[]),p(n)};for(var a in p)Object.prototype.hasOwnProperty.call(p,a)&&(Object.defineProperty?Object.defineProperty(r,a,function(e){return{configurable:!0,enumerable:!0,get:function(){return p[e]},set:function(n){p[e]=n}}}(a)):r[a]=p[a]);return Object.defineProperty?Object.defineProperty(r,"e",{enumerable:!0,value:n}):r.e=n,r}function a(e){var n={_acceptedDependencies:{},_declinedDependencies:{},_selfAccepted:!1,_selfDeclined:!1,_disposeHandlers:[],active:!0,accept:function(e,t){if("undefined"==typeof e)n._selfAccepted=!0;else if("function"==typeof e)n._selfAccepted=e;else if("object"==typeof e)for(var r=0;r<e.length;r++)n._acceptedDependencies[e[r]]=t;else n._acceptedDependencies[e]=t},decline:function(e){if("undefined"==typeof e)n._selfDeclined=!0;else if("number"==typeof e)n._declinedDependencies[e]=!0;else for(var t=0;t<e.length;t++)n._declinedDependencies[e[t]]=!0},dispose:function(e){n._disposeHandlers.push(e)},addDisposeHandler:function(e){n._disposeHandlers.push(e)},removeDisposeHandler:function(e){var t=n._disposeHandlers.indexOf(e);t>=0&&n._disposeHandlers.splice(t,1)},check:s,apply:d,status:function(e){return e?void w.push(e):x},addStatusHandler:function(e){w.push(e)},removeStatusHandler:function(e){var n=w.indexOf(e);n>=0&&w.splice(n,1)},data:b[e]};return n}function i(e){x=e;for(var n=0;n<w.length;n++)w[n].call(null,e)}function o(e){var n=+e+""===e;return n?+e:e}function s(e,n){if("idle"!==x)throw new Error("check() is only allowed in idle status");"function"==typeof e?(v=!1,n=e):(v=e,n=n||function(e){if(e)throw e}),i("check"),t(function(e,t){if(e)return n(e);if(!t)return i("idle"),void n(null,null);E={},q={},S={};for(var r=0;r<t.c.length;r++)q[t.c[r]]=!0;y=t.h,i("prepare"),f=n,m={};var a=0;u(a),"prepare"===x&&0===_&&0===k&&c()})}function l(e,n){if(q[e]&&E[e]){E[e]=!1;for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(m[t]=n[t]);0===--k&&0===_&&c()}}function u(e){q[e]?(E[e]=!0,k++,n(e)):S[e]=!0}function c(){i("ready");var e=f;if(f=null,e)if(v)d(v,e);else{var n=[];for(var t in m)Object.prototype.hasOwnProperty.call(m,t)&&n.push(o(t));e(null,n)}}function d(n,t){function r(e){for(var n=[e],t={},r=n.slice();r.length>0;){var i=r.pop(),e=Q[i];if(e&&!e.hot._selfAccepted){if(e.hot._selfDeclined)return new Error("Aborted because of self decline: "+i);if(0===i)return;for(var o=0;o<e.parents.length;o++){var s=e.parents[o],l=Q[s];if(l.hot._declinedDependencies[i])return new Error("Aborted because of declined dependency: "+i+" in "+s);n.indexOf(s)>=0||(l.hot._acceptedDependencies[i]?(t[s]||(t[s]=[]),a(t[s],[i])):(delete t[s],n.push(s),r.push(s)))}}}return[n,t]}function a(e,n){for(var t=0;t<n.length;t++){var r=n[t];e.indexOf(r)<0&&e.push(r)}}if("ready"!==x)throw new Error("apply() is only allowed in ready status");"function"==typeof n?(t=n,n={}):n&&"object"==typeof n?t=t||function(e){if(e)throw e}:(n={},t=t||function(e){if(e)throw e});var s={},l=[],u={};for(var c in m)if(Object.prototype.hasOwnProperty.call(m,c)){var d=o(c),h=r(d);if(!h){if(n.ignoreUnaccepted)continue;return i("abort"),t(new Error("Aborted because "+d+" is not accepted"))}if(h instanceof Error)return i("abort"),t(h);u[d]=m[d],a(l,h[0]);for(var d in h[1])Object.prototype.hasOwnProperty.call(h[1],d)&&(s[d]||(s[d]=[]),a(s[d],h[1][d]))}for(var f=[],v=0;v<l.length;v++){var d=l[v];Q[d]&&Q[d].hot._selfAccepted&&f.push({module:d,errorHandler:Q[d].hot._selfAccepted})}i("dispose");for(var w=l.slice();w.length>0;){var d=w.pop(),k=Q[d];if(k){for(var _={},S=k.hot._disposeHandlers,E=0;E<S.length;E++){var q=S[E];q(_)}b[d]=_,k.hot.active=!1,delete Q[d];for(var E=0;E<k.children.length;E++){var T=Q[k.children[E]];if(T){var C=T.parents.indexOf(d);C>=0&&T.parents.splice(C,1)}}}}for(var d in s)if(Object.prototype.hasOwnProperty.call(s,d))for(var k=Q[d],A=s[d],E=0;E<A.length;E++){var I=A[E],C=k.children.indexOf(I);C>=0&&k.children.splice(C,1)}i("apply"),g=y;for(var d in u)Object.prototype.hasOwnProperty.call(u,d)&&(e[d]=u[d]);var D=null;for(var d in s)if(Object.prototype.hasOwnProperty.call(s,d)){for(var k=Q[d],A=s[d],M=[],v=0;v<A.length;v++){var I=A[v],q=k.hot._acceptedDependencies[I];M.indexOf(q)>=0||M.push(q)}for(var v=0;v<M.length;v++){var q=M[v];try{q(s)}catch(O){D||(D=O)}}}for(var v=0;v<f.length;v++){var N=f[v],d=N.module;j=[d];try{p(d)}catch(O){if("function"==typeof N.errorHandler)try{N.errorHandler(O)}catch(O){D||(D=O)}else D||(D=O)}}return D?(i("fail"),t(D)):(i("idle"),void t(null,l))}function p(n){if(Q[n])return Q[n].exports;var t=Q[n]={exports:{},id:n,loaded:!1,hot:a(n),parents:j,children:[]};return e[n].call(t.exports,t,t.exports,r(n)),t.loaded=!0,t.exports}var h=this.webpackHotUpdate;this.webpackHotUpdate=function(e,n){l(e,n),h&&h(e,n)};var f,m,y,v=!0,g="aa74d205c997b6f6a854",b={},j=[],w=[],x="idle",k=0,_=0,S={},E={},q={},Q={};return p.m=e,p.c=Q,p.p="",p.h=function(){return g},r(0)(0)}([function(module,exports,__webpack_require__){eval("'use strict';\n\nvar _controller = __webpack_require__(1);\n\nvar _controller2 = _interopRequireDefault(_controller);\n\n__webpack_require__(23);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/app.js\n ** module id = 0\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/app.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nvar _jquery = __webpack_require__(2);\n\nvar _jquery2 = _interopRequireDefault(_jquery);\n\nvar _menu = __webpack_require__(3);\n\nvar _levels = __webpack_require__(6);\n\nvar _level = __webpack_require__(7);\n\nvar _level2 = _interopRequireDefault(_level);\n\nvar _game = __webpack_require__(18);\n\nvar _game2 = _interopRequireDefault(_game);\n\nvar _editor = __webpack_require__(20);\n\nvar _editor2 = _interopRequireDefault(_editor);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar rows = 1;\nvar columns = 1;\n\nvar editing = false;\n\nvar pf = new _game2.default(50, 100, 20);\nvar editor = new _editor2.default(null);\n\nvar L1 = new _level2.default(_levels.level1);\nvar L2 = new _level2.default(_levels.level2);\n\nvar levels = [_levels.level1, _levels.level2];\n\nvar resizeViewport = function resizeViewport(level) {\n  var docWidth = (0, _jquery2.default)(document).width() * 0.9;\n  var docHeight = (0, _jquery2.default)(window).height() * 0.7;\n\n  var viewWidth = docWidth < level.column * level.sqSize ? \"90%\" : level.column * level.sqSize + 'px';\n  var viewHeight = docHeight < level.row * level.sqSize ? \"70vh\" : level.row * level.sqSize + 'px';\n\n  (0, _jquery2.default)('.game').css({ 'width': viewWidth,\n    'height': viewHeight });\n};\n\nvar registerGameInput = function registerGameInput(level) {\n  (0, _jquery2.default)('.mode-button').click(function () {\n    if (!editing) {\n      editor.init(pf.suspend());\n      editing = true;\n      //$('.mode-container').empty();\n      //$('.mode-container').append(`<div class=\"mode-button\">play level</div>`)\n      (0, _jquery2.default)('.mode-button').text(\"play level\");\n    } else {\n      //pf.init(editor.suspend());\n\n      pf.init(editor.suspend());\n      editing = false;\n      //$('.mode-container').empty();\n      //$('.mode-container').append(`<div class=\"mode-button\">edit level</div>`)\n      (0, _jquery2.default)('.mode-button').text(\"edit level\");\n    }\n  });\n\n  (0, _jquery2.default)(window).resize(function () {\n    resizeViewport(level);\n  });\n};\n\nvar registerMenuInput = function registerMenuInput() {\n  (0, _jquery2.default)('.level-selection').click(function (e) {\n    editing = false;\n    var levelNum = e.target.getAttribute('data-level-num');\n    openGame(new _level2.default(levels[levelNum]));\n  });\n\n  (0, _jquery2.default)('.create-level .btn').click(function (e) {\n    openLevelInit();\n\n    //    openGame(null);\n  });\n\n  (0, _jquery2.default)('.header .title').click(function () {\n    window.location.href = 'http://localhost:3000/home';\n  });\n};\n\nfunction registerLevelInitInput() {\n  rows = 20;\n  columns = 120;\n  name = \"\";\n\n  (0, _jquery2.default)('.columns').val(columns);\n  (0, _jquery2.default)('.rows').val(rows);\n\n  (0, _jquery2.default)('.create-button').click(function (e) {\n    editing = true;\n    openGame(new _level2.default({\n      row: rows,\n      column: columns,\n      roamingObjs: [],\n      arr: [],\n      name: name\n    }));\n  });\n\n  (0, _jquery2.default)('.columns').bind('input propertychange', function (e) {\n    var val = (0, _jquery2.default)(e.target).val();\n    if (val === \"\") val = \"1\";\n    val = parseFloat(val) || 1;\n    val = val < 1 ? 1 : val;\n\n    val = val > 4500 / rows ? Math.floor(4500 / rows) : val;\n\n    console.log(val);\n\n    columns = val;\n  });\n\n  (0, _jquery2.default)('.rows').bind('input propertychange', function (e) {\n    var val = (0, _jquery2.default)(e.target).val();\n    if (val === \"\") val = \"1\";\n    val = parseFloat(val) || 1;\n    val = val < 1 ? 1 : val;\n    val = val > 4500 / columns ? Math.floor(4500 / columns) : val;\n    console.log(val);\n\n    rows = val;\n  });\n\n  (0, _jquery2.default)('.level-name').bind('input propertychange', function (e) {\n    var val = (0, _jquery2.default)(e.target).val();\n    console.log(val);\n\n    name = val;\n  });\n\n  (0, _jquery2.default)('.columns').change(function (e) {\n    (0, _jquery2.default)(e.target).val(columns);\n  });\n  (0, _jquery2.default)('.rows').change(function (e) {\n    (0, _jquery2.default)(e.target).val(rows);\n  });\n};\n\nfunction openLevelInit() {\n  (0, _jquery2.default)('.main-area').empty();\n  (0, _jquery2.default)('.main-area').append((0, _menu.renderLevelInit)());\n  (0, _jquery2.default)('.status').empty();\n\n  registerLevelInitInput();\n}\n\nfunction openGame(level) {\n  (0, _jquery2.default)('.main-area').empty();\n  (0, _jquery2.default)('.main-area').append((0, _menu.renderGameArea)());\n\n  (0, _jquery2.default)('.mode-container').empty();\n  resizeViewport(level);\n\n  if (!editing) {\n    pf.init(level);\n    (0, _jquery2.default)('.mode-container').append('<div class=\"mode-button\">edit level</div>');\n  } else {\n    editor.init(level);\n    (0, _jquery2.default)('.mode-container').append('<div class=\"mode-button\">play level</div>');\n  }\n  registerGameInput(level);\n}\n\nvar openMenu = function openMenu(levels) {\n  (0, _jquery2.default)('.main-area').empty();\n  (0, _jquery2.default)('.main-area').append((0, _menu.renderMenu)(levels));\n  (0, _jquery2.default)('.mode-container').empty();\n  registerMenuInput();\n  //pf.suspend();\n  //editor.suspend();\n};\n\n(0, _jquery2.default)(document).ready(function () {\n\n  var userLevels = window._userLevels;\n\n  console.log(userLevels);\n\n  openMenu(userLevels);\n  //openGame(L2);\n\n  //pf.init(null);\n  //  pf.run();\n\n  //  editor.init();\n});\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/js/controller.js\n ** module id = 1\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/js/controller.js?")},function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery JavaScript Library v1.12.2\n * http://jquery.com/\n *\n * Includes Sizzle.js\n * http://sizzlejs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2016-03-17T17:44Z\n */\n\n(function( global, factory ) {\n\n	if ( typeof module === "object" && typeof module.exports === "object" ) {\n		// For CommonJS and CommonJS-like environments where a proper `window`\n		// is present, execute the factory and get jQuery.\n		// For environments that do not have a `window` with a `document`\n		// (such as Node.js), expose a factory as module.exports.\n		// This accentuates the need for the creation of a real `window`.\n		// e.g. var jQuery = require("jquery")(window);\n		// See ticket #14549 for more info.\n		module.exports = global.document ?\n			factory( global, true ) :\n			function( w ) {\n				if ( !w.document ) {\n					throw new Error( "jQuery requires a window with a document" );\n				}\n				return factory( w );\n			};\n	} else {\n		factory( global );\n	}\n\n// Pass this if window is not defined yet\n}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {\n\n// Support: Firefox 18+\n// Can\'t be in strict mode, several libs including ASP.NET trace\n// the stack via arguments.caller.callee and Firefox dies if\n// you try to trace through "use strict" call chains. (#13335)\n//"use strict";\nvar deletedIds = [];\n\nvar document = window.document;\n\nvar slice = deletedIds.slice;\n\nvar concat = deletedIds.concat;\n\nvar push = deletedIds.push;\n\nvar indexOf = deletedIds.indexOf;\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar support = {};\n\n\n\nvar\n	version = "1.12.2",\n\n	// Define a local copy of jQuery\n	jQuery = function( selector, context ) {\n\n		// The jQuery object is actually just the init constructor \'enhanced\'\n		// Need init if jQuery is called (just allow error to be thrown if not included)\n		return new jQuery.fn.init( selector, context );\n	},\n\n	// Support: Android<4.1, IE<9\n	// Make sure we trim BOM and NBSP\n	rtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\n	// Matches dashed string for camelizing\n	rmsPrefix = /^-ms-/,\n	rdashAlpha = /-([\\da-z])/gi,\n\n	// Used by jQuery.camelCase as callback to replace()\n	fcamelCase = function( all, letter ) {\n		return letter.toUpperCase();\n	};\n\njQuery.fn = jQuery.prototype = {\n\n	// The current version of jQuery being used\n	jquery: version,\n\n	constructor: jQuery,\n\n	// Start with an empty selector\n	selector: "",\n\n	// The default length of a jQuery object is 0\n	length: 0,\n\n	toArray: function() {\n		return slice.call( this );\n	},\n\n	// Get the Nth element in the matched element set OR\n	// Get the whole matched element set as a clean array\n	get: function( num ) {\n		return num != null ?\n\n			// Return just the one element from the set\n			( num < 0 ? this[ num + this.length ] : this[ num ] ) :\n\n			// Return all the elements in a clean array\n			slice.call( this );\n	},\n\n	// Take an array of elements and push it onto the stack\n	// (returning the new matched element set)\n	pushStack: function( elems ) {\n\n		// Build a new jQuery matched element set\n		var ret = jQuery.merge( this.constructor(), elems );\n\n		// Add the old object onto the stack (as a reference)\n		ret.prevObject = this;\n		ret.context = this.context;\n\n		// Return the newly-formed element set\n		return ret;\n	},\n\n	// Execute a callback for every element in the matched set.\n	each: function( callback ) {\n		return jQuery.each( this, callback );\n	},\n\n	map: function( callback ) {\n		return this.pushStack( jQuery.map( this, function( elem, i ) {\n			return callback.call( elem, i, elem );\n		} ) );\n	},\n\n	slice: function() {\n		return this.pushStack( slice.apply( this, arguments ) );\n	},\n\n	first: function() {\n		return this.eq( 0 );\n	},\n\n	last: function() {\n		return this.eq( -1 );\n	},\n\n	eq: function( i ) {\n		var len = this.length,\n			j = +i + ( i < 0 ? len : 0 );\n		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\n	},\n\n	end: function() {\n		return this.prevObject || this.constructor();\n	},\n\n	// For internal use only.\n	// Behaves like an Array\'s method, not like a jQuery method.\n	push: push,\n	sort: deletedIds.sort,\n	splice: deletedIds.splice\n};\n\njQuery.extend = jQuery.fn.extend = function() {\n	var src, copyIsArray, copy, name, options, clone,\n		target = arguments[ 0 ] || {},\n		i = 1,\n		length = arguments.length,\n		deep = false;\n\n	// Handle a deep copy situation\n	if ( typeof target === "boolean" ) {\n		deep = target;\n\n		// skip the boolean and the target\n		target = arguments[ i ] || {};\n		i++;\n	}\n\n	// Handle case when target is a string or something (possible in deep copy)\n	if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {\n		target = {};\n	}\n\n	// extend jQuery itself if only one argument is passed\n	if ( i === length ) {\n		target = this;\n		i--;\n	}\n\n	for ( ; i < length; i++ ) {\n\n		// Only deal with non-null/undefined values\n		if ( ( options = arguments[ i ] ) != null ) {\n\n			// Extend the base object\n			for ( name in options ) {\n				src = target[ name ];\n				copy = options[ name ];\n\n				// Prevent never-ending loop\n				if ( target === copy ) {\n					continue;\n				}\n\n				// Recurse if we\'re merging plain objects or arrays\n				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||\n					( copyIsArray = jQuery.isArray( copy ) ) ) ) {\n\n					if ( copyIsArray ) {\n						copyIsArray = false;\n						clone = src && jQuery.isArray( src ) ? src : [];\n\n					} else {\n						clone = src && jQuery.isPlainObject( src ) ? src : {};\n					}\n\n					// Never move original objects, clone them\n					target[ name ] = jQuery.extend( deep, clone, copy );\n\n				// Don\'t bring in undefined values\n				} else if ( copy !== undefined ) {\n					target[ name ] = copy;\n				}\n			}\n		}\n	}\n\n	// Return the modified object\n	return target;\n};\n\njQuery.extend( {\n\n	// Unique for each copy of jQuery on the page\n	expando: "jQuery" + ( version + Math.random() ).replace( /\\D/g, "" ),\n\n	// Assume jQuery is ready without the ready module\n	isReady: true,\n\n	error: function( msg ) {\n		throw new Error( msg );\n	},\n\n	noop: function() {},\n\n	// See test/unit/core.js for details concerning isFunction.\n	// Since version 1.3, DOM methods and functions like alert\n	// aren\'t supported. They return false on IE (#2968).\n	isFunction: function( obj ) {\n		return jQuery.type( obj ) === "function";\n	},\n\n	isArray: Array.isArray || function( obj ) {\n		return jQuery.type( obj ) === "array";\n	},\n\n	isWindow: function( obj ) {\n		/* jshint eqeqeq: false */\n		return obj != null && obj == obj.window;\n	},\n\n	isNumeric: function( obj ) {\n\n		// parseFloat NaNs numeric-cast false positives (null|true|false|"")\n		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")\n		// subtraction forces infinities to NaN\n		// adding 1 corrects loss of precision from parseFloat (#15100)\n		var realStringObj = obj && obj.toString();\n		return !jQuery.isArray( obj ) && ( realStringObj - parseFloat( realStringObj ) + 1 ) >= 0;\n	},\n\n	isEmptyObject: function( obj ) {\n		var name;\n		for ( name in obj ) {\n			return false;\n		}\n		return true;\n	},\n\n	isPlainObject: function( obj ) {\n		var key;\n\n		// Must be an Object.\n		// Because of IE, we also have to check the presence of the constructor property.\n		// Make sure that DOM nodes and window objects don\'t pass through, as well\n		if ( !obj || jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {\n			return false;\n		}\n\n		try {\n\n			// Not own constructor property must be Object\n			if ( obj.constructor &&\n				!hasOwn.call( obj, "constructor" ) &&\n				!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {\n				return false;\n			}\n		} catch ( e ) {\n\n			// IE8,9 Will throw exceptions on certain host objects #9897\n			return false;\n		}\n\n		// Support: IE<9\n		// Handle iteration over inherited properties before own properties.\n		if ( !support.ownFirst ) {\n			for ( key in obj ) {\n				return hasOwn.call( obj, key );\n			}\n		}\n\n		// Own properties are enumerated firstly, so to speed up,\n		// if last one is own, then all properties are own.\n		for ( key in obj ) {}\n\n		return key === undefined || hasOwn.call( obj, key );\n	},\n\n	type: function( obj ) {\n		if ( obj == null ) {\n			return obj + "";\n		}\n		return typeof obj === "object" || typeof obj === "function" ?\n			class2type[ toString.call( obj ) ] || "object" :\n			typeof obj;\n	},\n\n	// Workarounds based on findings by Jim Driscoll\n	// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context\n	globalEval: function( data ) {\n		if ( data && jQuery.trim( data ) ) {\n\n			// We use execScript on Internet Explorer\n			// We use an anonymous function so that context is window\n			// rather than jQuery in Firefox\n			( window.execScript || function( data ) {\n				window[ "eval" ].call( window, data ); // jscs:ignore requireDotNotation\n			} )( data );\n		}\n	},\n\n	// Convert dashed to camelCase; used by the css and data modules\n	// Microsoft forgot to hump their vendor prefix (#9572)\n	camelCase: function( string ) {\n		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );\n	},\n\n	nodeName: function( elem, name ) {\n		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n	},\n\n	each: function( obj, callback ) {\n		var length, i = 0;\n\n		if ( isArrayLike( obj ) ) {\n			length = obj.length;\n			for ( ; i < length; i++ ) {\n				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n					break;\n				}\n			}\n		} else {\n			for ( i in obj ) {\n				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n					break;\n				}\n			}\n		}\n\n		return obj;\n	},\n\n	// Support: Android<4.1, IE<9\n	trim: function( text ) {\n		return text == null ?\n			"" :\n			( text + "" ).replace( rtrim, "" );\n	},\n\n	// results is for internal usage only\n	makeArray: function( arr, results ) {\n		var ret = results || [];\n\n		if ( arr != null ) {\n			if ( isArrayLike( Object( arr ) ) ) {\n				jQuery.merge( ret,\n					typeof arr === "string" ?\n					[ arr ] : arr\n				);\n			} else {\n				push.call( ret, arr );\n			}\n		}\n\n		return ret;\n	},\n\n	inArray: function( elem, arr, i ) {\n		var len;\n\n		if ( arr ) {\n			if ( indexOf ) {\n				return indexOf.call( arr, elem, i );\n			}\n\n			len = arr.length;\n			i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;\n\n			for ( ; i < len; i++ ) {\n\n				// Skip accessing in sparse arrays\n				if ( i in arr && arr[ i ] === elem ) {\n					return i;\n				}\n			}\n		}\n\n		return -1;\n	},\n\n	merge: function( first, second ) {\n		var len = +second.length,\n			j = 0,\n			i = first.length;\n\n		while ( j < len ) {\n			first[ i++ ] = second[ j++ ];\n		}\n\n		// Support: IE<9\n		// Workaround casting of .length to NaN on otherwise arraylike objects (e.g., NodeLists)\n		if ( len !== len ) {\n			while ( second[ j ] !== undefined ) {\n				first[ i++ ] = second[ j++ ];\n			}\n		}\n\n		first.length = i;\n\n		return first;\n	},\n\n	grep: function( elems, callback, invert ) {\n		var callbackInverse,\n			matches = [],\n			i = 0,\n			length = elems.length,\n			callbackExpect = !invert;\n\n		// Go through the array, only saving the items\n		// that pass the validator function\n		for ( ; i < length; i++ ) {\n			callbackInverse = !callback( elems[ i ], i );\n			if ( callbackInverse !== callbackExpect ) {\n				matches.push( elems[ i ] );\n			}\n		}\n\n		return matches;\n	},\n\n	// arg is for internal usage only\n	map: function( elems, callback, arg ) {\n		var length, value,\n			i = 0,\n			ret = [];\n\n		// Go through the array, translating each of the items to their new values\n		if ( isArrayLike( elems ) ) {\n			length = elems.length;\n			for ( ; i < length; i++ ) {\n				value = callback( elems[ i ], i, arg );\n\n				if ( value != null ) {\n					ret.push( value );\n				}\n			}\n\n		// Go through every key on the object,\n		} else {\n			for ( i in elems ) {\n				value = callback( elems[ i ], i, arg );\n\n				if ( value != null ) {\n					ret.push( value );\n				}\n			}\n		}\n\n		// Flatten any nested arrays\n		return concat.apply( [], ret );\n	},\n\n	// A global GUID counter for objects\n	guid: 1,\n\n	// Bind a function to a context, optionally partially applying any\n	// arguments.\n	proxy: function( fn, context ) {\n		var args, proxy, tmp;\n\n		if ( typeof context === "string" ) {\n			tmp = fn[ context ];\n			context = fn;\n			fn = tmp;\n		}\n\n		// Quick check to determine if target is callable, in the spec\n		// this throws a TypeError, but we will just return undefined.\n		if ( !jQuery.isFunction( fn ) ) {\n			return undefined;\n		}\n\n		// Simulated bind\n		args = slice.call( arguments, 2 );\n		proxy = function() {\n			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n		};\n\n		// Set the guid of unique handler to the same of original handler, so it can be removed\n		proxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n		return proxy;\n	},\n\n	now: function() {\n		return +( new Date() );\n	},\n\n	// jQuery.support is not used in Core but other projects attach their\n	// properties to it so it needs to exist.\n	support: support\n} );\n\n// JSHint would error on this code due to the Symbol not being defined in ES5.\n// Defining this global in .jshintrc would create a danger of using the global\n// unguarded in another place, it seems safer to just disable JSHint for these\n// three lines.\n/* jshint ignore: start */\nif ( typeof Symbol === "function" ) {\n	jQuery.fn[ Symbol.iterator ] = deletedIds[ Symbol.iterator ];\n}\n/* jshint ignore: end */\n\n// Populate the class2type map\njQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),\nfunction( i, name ) {\n	class2type[ "[object " + name + "]" ] = name.toLowerCase();\n} );\n\nfunction isArrayLike( obj ) {\n\n	// Support: iOS 8.2 (not reproducible in simulator)\n	// `in` check used to prevent JIT error (gh-2145)\n	// hasOwn isn\'t used here due to false negatives\n	// regarding Nodelist length in IE\n	var length = !!obj && "length" in obj && obj.length,\n		type = jQuery.type( obj );\n\n	if ( type === "function" || jQuery.isWindow( obj ) ) {\n		return false;\n	}\n\n	return type === "array" || length === 0 ||\n		typeof length === "number" && length > 0 && ( length - 1 ) in obj;\n}\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v2.2.1\n * http://sizzlejs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2015-10-17\n */\n(function( window ) {\n\nvar i,\n	support,\n	Expr,\n	getText,\n	isXML,\n	tokenize,\n	compile,\n	select,\n	outermostContext,\n	sortInput,\n	hasDuplicate,\n\n	// Local document vars\n	setDocument,\n	document,\n	docElem,\n	documentIsHTML,\n	rbuggyQSA,\n	rbuggyMatches,\n	matches,\n	contains,\n\n	// Instance-specific data\n	expando = "sizzle" + 1 * new Date(),\n	preferredDoc = window.document,\n	dirruns = 0,\n	done = 0,\n	classCache = createCache(),\n	tokenCache = createCache(),\n	compilerCache = createCache(),\n	sortOrder = function( a, b ) {\n		if ( a === b ) {\n			hasDuplicate = true;\n		}\n		return 0;\n	},\n\n	// General-purpose constants\n	MAX_NEGATIVE = 1 << 31,\n\n	// Instance methods\n	hasOwn = ({}).hasOwnProperty,\n	arr = [],\n	pop = arr.pop,\n	push_native = arr.push,\n	push = arr.push,\n	slice = arr.slice,\n	// Use a stripped-down indexOf as it\'s faster than native\n	// http://jsperf.com/thor-indexof-vs-for/5\n	indexOf = function( list, elem ) {\n		var i = 0,\n			len = list.length;\n		for ( ; i < len; i++ ) {\n			if ( list[i] === elem ) {\n				return i;\n			}\n		}\n		return -1;\n	},\n\n	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",\n\n	// Regular expressions\n\n	// http://www.w3.org/TR/css3-selectors/#whitespace\n	whitespace = "[\\\\x20\\\\t\\\\r\\\\n\\\\f]",\n\n	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n	identifier = "(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+",\n\n	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n	attributes = "\\\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +\n		// Operator (capture 2)\n		"*([*^$|!~]?=)" + whitespace +\n		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"\n		"*(?:\'((?:\\\\\\\\.|[^\\\\\\\\\'])*)\'|\\"((?:\\\\\\\\.|[^\\\\\\\\\\"])*)\\"|(" + identifier + "))|)" + whitespace +\n		"*\\\\]",\n\n	pseudos = ":(" + identifier + ")(?:\\\\((" +\n		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n		// 1. quoted (capture 3; capture 4 or capture 5)\n		"(\'((?:\\\\\\\\.|[^\\\\\\\\\'])*)\'|\\"((?:\\\\\\\\.|[^\\\\\\\\\\"])*)\\")|" +\n		// 2. simple (capture 6)\n		"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|" + attributes + ")*)|" +\n		// 3. anything else (capture 2)\n		".*" +\n		")\\\\)|)",\n\n	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n	rwhitespace = new RegExp( whitespace + "+", "g" ),\n	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)" + whitespace + "+$", "g" ),\n\n	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),\n	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),\n\n	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\\\]\'\\"]*?)" + whitespace + "*\\\\]", "g" ),\n\n	rpseudo = new RegExp( pseudos ),\n	ridentifier = new RegExp( "^" + identifier + "$" ),\n\n	matchExpr = {\n		"ID": new RegExp( "^#(" + identifier + ")" ),\n		"CLASS": new RegExp( "^\\\\.(" + identifier + ")" ),\n		"TAG": new RegExp( "^(" + identifier + "|[*])" ),\n		"ATTR": new RegExp( "^" + attributes ),\n		"PSEUDO": new RegExp( "^" + pseudos ),\n		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(" + whitespace +\n			"*(even|odd|(([+-]|)(\\\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +\n			"*(\\\\d+)|))" + whitespace + "*\\\\)|)", "i" ),\n		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),\n		// For use in libraries implementing .is()\n		// We use this for POS matching in `select`\n		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(" +\n			whitespace + "*((?:-\\\\d)?\\\\d*)" + whitespace + "*\\\\)|)(?=[^-]|$)", "i" )\n	},\n\n	rinputs = /^(?:input|select|textarea|button)$/i,\n	rheader = /^h\\d$/i,\n\n	rnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n	// Easily-parseable/retrievable ID or TAG or CLASS selectors\n	rquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n	rsibling = /[+~]/,\n	rescape = /\'|\\\\/g,\n\n	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n	runescape = new RegExp( "\\\\\\\\([\\\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),\n	funescape = function( _, escaped, escapedWhitespace ) {\n		var high = "0x" + escaped - 0x10000;\n		// NaN means non-codepoint\n		// Support: Firefox<24\n		// Workaround erroneous numeric interpretation of +"0x"\n		return high !== high || escapedWhitespace ?\n			escaped :\n			high < 0 ?\n				// BMP codepoint\n				String.fromCharCode( high + 0x10000 ) :\n				// Supplemental Plane codepoint (surrogate pair)\n				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n	},\n\n	// Used for iframes\n	// See setDocument()\n	// Removing the function wrapper causes a "Permission Denied"\n	// error in IE\n	unloadHandler = function() {\n		setDocument();\n	};\n\n// Optimize for push.apply( _, NodeList )\ntry {\n	push.apply(\n		(arr = slice.call( preferredDoc.childNodes )),\n		preferredDoc.childNodes\n	);\n	// Support: Android<4.0\n	// Detect silently failing push.apply\n	arr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n	push = { apply: arr.length ?\n\n		// Leverage slice if possible\n		function( target, els ) {\n			push_native.apply( target, slice.call(els) );\n		} :\n\n		// Support: IE<9\n		// Otherwise append directly\n		function( target, els ) {\n			var j = target.length,\n				i = 0;\n			// Can\'t trust NodeList.length\n			while ( (target[j++] = els[i++]) ) {}\n			target.length = j - 1;\n		}\n	};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n	var m, i, elem, nid, nidselect, match, groups, newSelector,\n		newContext = context && context.ownerDocument,\n\n		// nodeType defaults to 9, since context defaults to document\n		nodeType = context ? context.nodeType : 9;\n\n	results = results || [];\n\n	// Return early from calls with invalid selector or context\n	if ( typeof selector !== "string" || !selector ||\n		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n		return results;\n	}\n\n	// Try to shortcut find operations (as opposed to filters) in HTML documents\n	if ( !seed ) {\n\n		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n			setDocument( context );\n		}\n		context = context || document;\n\n		if ( documentIsHTML ) {\n\n			// If the selector is sufficiently simple, try using a "get*By*" DOM method\n			// (excepting DocumentFragment context, where the methods don\'t exist)\n			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\n				// ID selector\n				if ( (m = match[1]) ) {\n\n					// Document context\n					if ( nodeType === 9 ) {\n						if ( (elem = context.getElementById( m )) ) {\n\n							// Support: IE, Opera, Webkit\n							// TODO: identify versions\n							// getElementById can match elements by name instead of ID\n							if ( elem.id === m ) {\n								results.push( elem );\n								return results;\n							}\n						} else {\n							return results;\n						}\n\n					// Element context\n					} else {\n\n						// Support: IE, Opera, Webkit\n						// TODO: identify versions\n						// getElementById can match elements by name instead of ID\n						if ( newContext && (elem = newContext.getElementById( m )) &&\n							contains( context, elem ) &&\n							elem.id === m ) {\n\n							results.push( elem );\n							return results;\n						}\n					}\n\n				// Type selector\n				} else if ( match[2] ) {\n					push.apply( results, context.getElementsByTagName( selector ) );\n					return results;\n\n				// Class selector\n				} else if ( (m = match[3]) && support.getElementsByClassName &&\n					context.getElementsByClassName ) {\n\n					push.apply( results, context.getElementsByClassName( m ) );\n					return results;\n				}\n			}\n\n			// Take advantage of querySelectorAll\n			if ( support.qsa &&\n				!compilerCache[ selector + " " ] &&\n				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\n				if ( nodeType !== 1 ) {\n					newContext = context;\n					newSelector = selector;\n\n				// qSA looks outside Element context, which is not what we want\n				// Thanks to Andrew Dupont for this workaround technique\n				// Support: IE <=8\n				// Exclude object elements\n				} else if ( context.nodeName.toLowerCase() !== "object" ) {\n\n					// Capture the context ID, setting it first if necessary\n					if ( (nid = context.getAttribute( "id" )) ) {\n						nid = nid.replace( rescape, "\\\\$&" );\n					} else {\n						context.setAttribute( "id", (nid = expando) );\n					}\n\n					// Prefix every selector in the list\n					groups = tokenize( selector );\n					i = groups.length;\n					nidselect = ridentifier.test( nid ) ? "#" + nid : "[id=\'" + nid + "\']";\n					while ( i-- ) {\n						groups[i] = nidselect + " " + toSelector( groups[i] );\n					}\n					newSelector = groups.join( "," );\n\n					// Expand context for sibling selectors\n					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n						context;\n				}\n\n				if ( newSelector ) {\n					try {\n						push.apply( results,\n							newContext.querySelectorAll( newSelector )\n						);\n						return results;\n					} catch ( qsaError ) {\n					} finally {\n						if ( nid === expando ) {\n							context.removeAttribute( "id" );\n						}\n					}\n				}\n			}\n		}\n	}\n\n	// All others\n	return select( selector.replace( rtrim, "$1" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\n *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *	deleting the oldest entry\n */\nfunction createCache() {\n	var keys = [];\n\n	function cache( key, value ) {\n		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)\n		if ( keys.push( key + " " ) > Expr.cacheLength ) {\n			// Only keep the most recent entries\n			delete cache[ keys.shift() ];\n		}\n		return (cache[ key + " " ] = value);\n	}\n	return cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n	fn[ expando ] = true;\n	return fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created div and expects a boolean result\n */\nfunction assert( fn ) {\n	var div = document.createElement("div");\n\n	try {\n		return !!fn( div );\n	} catch (e) {\n		return false;\n	} finally {\n		// Remove from its parent by default\n		if ( div.parentNode ) {\n			div.parentNode.removeChild( div );\n		}\n		// release memory in IE\n		div = null;\n	}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n	var arr = attrs.split("|"),\n		i = arr.length;\n\n	while ( i-- ) {\n		Expr.attrHandle[ arr[i] ] = handler;\n	}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n	var cur = b && a,\n		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n			( ~b.sourceIndex || MAX_NEGATIVE ) -\n			( ~a.sourceIndex || MAX_NEGATIVE );\n\n	// Use IE sourceIndex if available on both nodes\n	if ( diff ) {\n		return diff;\n	}\n\n	// Check if b follows a\n	if ( cur ) {\n		while ( (cur = cur.nextSibling) ) {\n			if ( cur === b ) {\n				return -1;\n			}\n		}\n	}\n\n	return a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n	return function( elem ) {\n		var name = elem.nodeName.toLowerCase();\n		return name === "input" && elem.type === type;\n	};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n	return function( elem ) {\n		var name = elem.nodeName.toLowerCase();\n		return (name === "input" || name === "button") && elem.type === type;\n	};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n	return markFunction(function( argument ) {\n		argument = +argument;\n		return markFunction(function( seed, matches ) {\n			var j,\n				matchIndexes = fn( [], seed.length, argument ),\n				i = matchIndexes.length;\n\n			// Match elements found at the specified indexes\n			while ( i-- ) {\n				if ( seed[ (j = matchIndexes[i]) ] ) {\n					seed[j] = !(matches[j] = seed[j]);\n				}\n			}\n		});\n	});\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n	return context && typeof context.getElementsByTagName !== "undefined" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n	// documentElement is verified for cases where it doesn\'t yet exist\n	// (such as loading iframes in IE - #4833)\n	var documentElement = elem && (elem.ownerDocument || elem).documentElement;\n	return documentElement ? documentElement.nodeName !== "HTML" : false;\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n	var hasCompare, parent,\n		doc = node ? node.ownerDocument || node : preferredDoc;\n\n	// Return early if doc is invalid or already selected\n	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n		return document;\n	}\n\n	// Update global variables\n	document = doc;\n	docElem = document.documentElement;\n	documentIsHTML = !isXML( document );\n\n	// Support: IE 9-11, Edge\n	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)\n	if ( (parent = document.defaultView) && parent.top !== parent ) {\n		// Support: IE 11\n		if ( parent.addEventListener ) {\n			parent.addEventListener( "unload", unloadHandler, false );\n\n		// Support: IE 9 - 10 only\n		} else if ( parent.attachEvent ) {\n			parent.attachEvent( "onunload", unloadHandler );\n		}\n	}\n\n	/* Attributes\n	---------------------------------------------------------------------- */\n\n	// Support: IE<8\n	// Verify that getAttribute really returns attributes and not properties\n	// (excepting IE8 booleans)\n	support.attributes = assert(function( div ) {\n		div.className = "i";\n		return !div.getAttribute("className");\n	});\n\n	/* getElement(s)By*\n	---------------------------------------------------------------------- */\n\n	// Check if getElementsByTagName("*") returns only elements\n	support.getElementsByTagName = assert(function( div ) {\n		div.appendChild( document.createComment("") );\n		return !div.getElementsByTagName("*").length;\n	});\n\n	// Support: IE<9\n	support.getElementsByClassName = rnative.test( document.getElementsByClassName );\n\n	// Support: IE<10\n	// Check if getElementById returns elements by name\n	// The broken getElementById methods don\'t pick up programatically-set names,\n	// so use a roundabout getElementsByName test\n	support.getById = assert(function( div ) {\n		docElem.appendChild( div ).id = expando;\n		return !document.getElementsByName || !document.getElementsByName( expando ).length;\n	});\n\n	// ID find and filter\n	if ( support.getById ) {\n		Expr.find["ID"] = function( id, context ) {\n			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {\n				var m = context.getElementById( id );\n				return m ? [ m ] : [];\n			}\n		};\n		Expr.filter["ID"] = function( id ) {\n			var attrId = id.replace( runescape, funescape );\n			return function( elem ) {\n				return elem.getAttribute("id") === attrId;\n			};\n		};\n	} else {\n		// Support: IE6/7\n		// getElementById is not reliable as a find shortcut\n		delete Expr.find["ID"];\n\n		Expr.filter["ID"] =  function( id ) {\n			var attrId = id.replace( runescape, funescape );\n			return function( elem ) {\n				var node = typeof elem.getAttributeNode !== "undefined" &&\n					elem.getAttributeNode("id");\n				return node && node.value === attrId;\n			};\n		};\n	}\n\n	// Tag\n	Expr.find["TAG"] = support.getElementsByTagName ?\n		function( tag, context ) {\n			if ( typeof context.getElementsByTagName !== "undefined" ) {\n				return context.getElementsByTagName( tag );\n\n			// DocumentFragment nodes don\'t have gEBTN\n			} else if ( support.qsa ) {\n				return context.querySelectorAll( tag );\n			}\n		} :\n\n		function( tag, context ) {\n			var elem,\n				tmp = [],\n				i = 0,\n				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n				results = context.getElementsByTagName( tag );\n\n			// Filter out possible comments\n			if ( tag === "*" ) {\n				while ( (elem = results[i++]) ) {\n					if ( elem.nodeType === 1 ) {\n						tmp.push( elem );\n					}\n				}\n\n				return tmp;\n			}\n			return results;\n		};\n\n	// Class\n	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {\n		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {\n			return context.getElementsByClassName( className );\n		}\n	};\n\n	/* QSA/matchesSelector\n	---------------------------------------------------------------------- */\n\n	// QSA and matchesSelector support\n\n	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n	rbuggyMatches = [];\n\n	// qSa(:focus) reports false when true (Chrome 21)\n	// We allow this because of a bug in IE8/9 that throws an error\n	// whenever `document.activeElement` is accessed on an iframe\n	// So, we allow :focus to pass through QSA all the time to avoid the IE error\n	// See http://bugs.jquery.com/ticket/13378\n	rbuggyQSA = [];\n\n	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\n		// Build QSA regex\n		// Regex strategy adopted from Diego Perini\n		assert(function( div ) {\n			// Select is set to empty string on purpose\n			// This is to test IE\'s treatment of not explicitly\n			// setting a boolean content attribute,\n			// since its presence should be enough\n			// http://bugs.jquery.com/ticket/12359\n			docElem.appendChild( div ).innerHTML = "<a id=\'" + expando + "\'></a>" +\n				"<select id=\'" + expando + "-\\r\\\\\' msallowcapture=\'\'>" +\n				"<option selected=\'\'></option></select>";\n\n			// Support: IE8, Opera 11-12.16\n			// Nothing should be selected when empty strings follow ^= or $= or *=\n			// The test attribute must be unknown in Opera but "safe" for WinRT\n			// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n			if ( div.querySelectorAll("[msallowcapture^=\'\']").length ) {\n				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:\'\'|\\"\\")" );\n			}\n\n			// Support: IE8\n			// Boolean attributes and "value" are not treated correctly\n			if ( !div.querySelectorAll("[selected]").length ) {\n				rbuggyQSA.push( "\\\\[" + whitespace + "*(?:value|" + booleans + ")" );\n			}\n\n			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n			if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {\n				rbuggyQSA.push("~=");\n			}\n\n			// Webkit/Opera - :checked should return selected option elements\n			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n			// IE8 throws error here and will not see later tests\n			if ( !div.querySelectorAll(":checked").length ) {\n				rbuggyQSA.push(":checked");\n			}\n\n			// Support: Safari 8+, iOS 8+\n			// https://bugs.webkit.org/show_bug.cgi?id=136851\n			// In-page `selector#id sibing-combinator selector` fails\n			if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {\n				rbuggyQSA.push(".#.+[+~]");\n			}\n		});\n\n		assert(function( div ) {\n			// Support: Windows 8 Native Apps\n			// The type and name attributes are restricted during .innerHTML assignment\n			var input = document.createElement("input");\n			input.setAttribute( "type", "hidden" );\n			div.appendChild( input ).setAttribute( "name", "D" );\n\n			// Support: IE8\n			// Enforce case-sensitivity of name attribute\n			if ( div.querySelectorAll("[name=d]").length ) {\n				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );\n			}\n\n			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n			// IE8 throws error here and will not see later tests\n			if ( !div.querySelectorAll(":enabled").length ) {\n				rbuggyQSA.push( ":enabled", ":disabled" );\n			}\n\n			// Opera 10-11 does not throw on post-comma invalid pseudos\n			div.querySelectorAll("*,:x");\n			rbuggyQSA.push(",.*:");\n		});\n	}\n\n	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n		docElem.webkitMatchesSelector ||\n		docElem.mozMatchesSelector ||\n		docElem.oMatchesSelector ||\n		docElem.msMatchesSelector) )) ) {\n\n		assert(function( div ) {\n			// Check to see if it\'s possible to do matchesSelector\n			// on a disconnected node (IE 9)\n			support.disconnectedMatch = matches.call( div, "div" );\n\n			// This should fail with an exception\n			// Gecko does not error, returns false instead\n			matches.call( div, "[s!=\'\']:x" );\n			rbuggyMatches.push( "!=", pseudos );\n		});\n	}\n\n	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );\n	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );\n\n	/* Contains\n	---------------------------------------------------------------------- */\n	hasCompare = rnative.test( docElem.compareDocumentPosition );\n\n	// Element contains another\n	// Purposefully self-exclusive\n	// As in, an element does not contain itself\n	contains = hasCompare || rnative.test( docElem.contains ) ?\n		function( a, b ) {\n			var adown = a.nodeType === 9 ? a.documentElement : a,\n				bup = b && b.parentNode;\n			return a === bup || !!( bup && bup.nodeType === 1 && (\n				adown.contains ?\n					adown.contains( bup ) :\n					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n			));\n		} :\n		function( a, b ) {\n			if ( b ) {\n				while ( (b = b.parentNode) ) {\n					if ( b === a ) {\n						return true;\n					}\n				}\n			}\n			return false;\n		};\n\n	/* Sorting\n	---------------------------------------------------------------------- */\n\n	// Document order sorting\n	sortOrder = hasCompare ?\n	function( a, b ) {\n\n		// Flag for duplicate removal\n		if ( a === b ) {\n			hasDuplicate = true;\n			return 0;\n		}\n\n		// Sort on method existence if only one input has compareDocumentPosition\n		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n		if ( compare ) {\n			return compare;\n		}\n\n		// Calculate position if both inputs belong to the same document\n		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n			a.compareDocumentPosition( b ) :\n\n			// Otherwise we know they are disconnected\n			1;\n\n		// Disconnected nodes\n		if ( compare & 1 ||\n			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n			// Choose the first element that is related to our preferred document\n			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n				return -1;\n			}\n			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n				return 1;\n			}\n\n			// Maintain original order\n			return sortInput ?\n				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n				0;\n		}\n\n		return compare & 4 ? -1 : 1;\n	} :\n	function( a, b ) {\n		// Exit early if the nodes are identical\n		if ( a === b ) {\n			hasDuplicate = true;\n			return 0;\n		}\n\n		var cur,\n			i = 0,\n			aup = a.parentNode,\n			bup = b.parentNode,\n			ap = [ a ],\n			bp = [ b ];\n\n		// Parentless nodes are either documents or disconnected\n		if ( !aup || !bup ) {\n			return a === document ? -1 :\n				b === document ? 1 :\n				aup ? -1 :\n				bup ? 1 :\n				sortInput ?\n				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n				0;\n\n		// If the nodes are siblings, we can do a quick check\n		} else if ( aup === bup ) {\n			return siblingCheck( a, b );\n		}\n\n		// Otherwise we need full lists of their ancestors for comparison\n		cur = a;\n		while ( (cur = cur.parentNode) ) {\n			ap.unshift( cur );\n		}\n		cur = b;\n		while ( (cur = cur.parentNode) ) {\n			bp.unshift( cur );\n		}\n\n		// Walk down the tree looking for a discrepancy\n		while ( ap[i] === bp[i] ) {\n			i++;\n		}\n\n		return i ?\n			// Do a sibling check if the nodes have a common ancestor\n			siblingCheck( ap[i], bp[i] ) :\n\n			// Otherwise nodes in our document sort first\n			ap[i] === preferredDoc ? -1 :\n			bp[i] === preferredDoc ? 1 :\n			0;\n	};\n\n	return document;\n};\n\nSizzle.matches = function( expr, elements ) {\n	return Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n	// Set document vars if needed\n	if ( ( elem.ownerDocument || elem ) !== document ) {\n		setDocument( elem );\n	}\n\n	// Make sure that attribute selectors are quoted\n	expr = expr.replace( rattributeQuotes, "=\'$1\']" );\n\n	if ( support.matchesSelector && documentIsHTML &&\n		!compilerCache[ expr + " " ] &&\n		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n		try {\n			var ret = matches.call( elem, expr );\n\n			// IE 9\'s matchesSelector returns false on disconnected nodes\n			if ( ret || support.disconnectedMatch ||\n					// As well, disconnected nodes are said to be in a document\n					// fragment in IE 9\n					elem.document && elem.document.nodeType !== 11 ) {\n				return ret;\n			}\n		} catch (e) {}\n	}\n\n	return Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n	// Set document vars if needed\n	if ( ( context.ownerDocument || context ) !== document ) {\n		setDocument( context );\n	}\n	return contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n	// Set document vars if needed\n	if ( ( elem.ownerDocument || elem ) !== document ) {\n		setDocument( elem );\n	}\n\n	var fn = Expr.attrHandle[ name.toLowerCase() ],\n		// Don\'t get fooled by Object.prototype properties (jQuery #13807)\n		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n			fn( elem, name, !documentIsHTML ) :\n			undefined;\n\n	return val !== undefined ?\n		val :\n		support.attributes || !documentIsHTML ?\n			elem.getAttribute( name ) :\n			(val = elem.getAttributeNode(name)) && val.specified ?\n				val.value :\n				null;\n};\n\nSizzle.error = function( msg ) {\n	throw new Error( "Syntax error, unrecognized expression: " + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n	var elem,\n		duplicates = [],\n		j = 0,\n		i = 0;\n\n	// Unless we *know* we can detect duplicates, assume their presence\n	hasDuplicate = !support.detectDuplicates;\n	sortInput = !support.sortStable && results.slice( 0 );\n	results.sort( sortOrder );\n\n	if ( hasDuplicate ) {\n		while ( (elem = results[i++]) ) {\n			if ( elem === results[ i ] ) {\n				j = duplicates.push( i );\n			}\n		}\n		while ( j-- ) {\n			results.splice( duplicates[ j ], 1 );\n		}\n	}\n\n	// Clear input after sorting to release objects\n	// See https://github.com/jquery/sizzle/pull/225\n	sortInput = null;\n\n	return results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n	var node,\n		ret = "",\n		i = 0,\n		nodeType = elem.nodeType;\n\n	if ( !nodeType ) {\n		// If no nodeType, this is expected to be an array\n		while ( (node = elem[i++]) ) {\n			// Do not traverse comment nodes\n			ret += getText( node );\n		}\n	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n		// Use textContent for elements\n		// innerText usage removed for consistency of new lines (jQuery #11153)\n		if ( typeof elem.textContent === "string" ) {\n			return elem.textContent;\n		} else {\n			// Traverse its children\n			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n				ret += getText( elem );\n			}\n		}\n	} else if ( nodeType === 3 || nodeType === 4 ) {\n		return elem.nodeValue;\n	}\n	// Do not include comment or processing instruction nodes\n\n	return ret;\n};\n\nExpr = Sizzle.selectors = {\n\n	// Can be adjusted by the user\n	cacheLength: 50,\n\n	createPseudo: markFunction,\n\n	match: matchExpr,\n\n	attrHandle: {},\n\n	find: {},\n\n	relative: {\n		">": { dir: "parentNode", first: true },\n		" ": { dir: "parentNode" },\n		"+": { dir: "previousSibling", first: true },\n		"~": { dir: "previousSibling" }\n	},\n\n	preFilter: {\n		"ATTR": function( match ) {\n			match[1] = match[1].replace( runescape, funescape );\n\n			// Move the given value to match[3] whether quoted or unquoted\n			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );\n\n			if ( match[2] === "~=" ) {\n				match[3] = " " + match[3] + " ";\n			}\n\n			return match.slice( 0, 4 );\n		},\n\n		"CHILD": function( match ) {\n			/* matches from matchExpr["CHILD"]\n				1 type (only|nth|...)\n				2 what (child|of-type)\n				3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n				4 xn-component of xn+y argument ([+-]?\\d*n|)\n				5 sign of xn-component\n				6 x of xn-component\n				7 sign of y-component\n				8 y of y-component\n			*/\n			match[1] = match[1].toLowerCase();\n\n			if ( match[1].slice( 0, 3 ) === "nth" ) {\n				// nth-* requires argument\n				if ( !match[3] ) {\n					Sizzle.error( match[0] );\n				}\n\n				// numeric x and y parameters for Expr.filter.CHILD\n				// remember that false/true cast respectively to 0/1\n				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );\n				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );\n\n			// other types prohibit arguments\n			} else if ( match[3] ) {\n				Sizzle.error( match[0] );\n			}\n\n			return match;\n		},\n\n		"PSEUDO": function( match ) {\n			var excess,\n				unquoted = !match[6] && match[2];\n\n			if ( matchExpr["CHILD"].test( match[0] ) ) {\n				return null;\n			}\n\n			// Accept quoted arguments as-is\n			if ( match[3] ) {\n				match[2] = match[4] || match[5] || "";\n\n			// Strip excess characters from unquoted arguments\n			} else if ( unquoted && rpseudo.test( unquoted ) &&\n				// Get excess from tokenize (recursively)\n				(excess = tokenize( unquoted, true )) &&\n				// advance to the next closing parenthesis\n				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {\n\n				// excess is a negative index\n				match[0] = match[0].slice( 0, excess );\n				match[2] = unquoted.slice( 0, excess );\n			}\n\n			// Return only captures needed by the pseudo filter method (type and argument)\n			return match.slice( 0, 3 );\n		}\n	},\n\n	filter: {\n\n		"TAG": function( nodeNameSelector ) {\n			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n			return nodeNameSelector === "*" ?\n				function() { return true; } :\n				function( elem ) {\n					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n				};\n		},\n\n		"CLASS": function( className ) {\n			var pattern = classCache[ className + " " ];\n\n			return pattern ||\n				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&\n				classCache( className, function( elem ) {\n					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );\n				});\n		},\n\n		"ATTR": function( name, operator, check ) {\n			return function( elem ) {\n				var result = Sizzle.attr( elem, name );\n\n				if ( result == null ) {\n					return operator === "!=";\n				}\n				if ( !operator ) {\n					return true;\n				}\n\n				result += "";\n\n				return operator === "=" ? result === check :\n					operator === "!=" ? result !== check :\n					operator === "^=" ? check && result.indexOf( check ) === 0 :\n					operator === "*=" ? check && result.indexOf( check ) > -1 :\n					operator === "$=" ? check && result.slice( -check.length ) === check :\n					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :\n					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :\n					false;\n			};\n		},\n\n		"CHILD": function( type, what, argument, first, last ) {\n			var simple = type.slice( 0, 3 ) !== "nth",\n				forward = type.slice( -4 ) !== "last",\n				ofType = what === "of-type";\n\n			return first === 1 && last === 0 ?\n\n				// Shortcut for :nth-*(n)\n				function( elem ) {\n					return !!elem.parentNode;\n				} :\n\n				function( elem, context, xml ) {\n					var cache, uniqueCache, outerCache, node, nodeIndex, start,\n						dir = simple !== forward ? "nextSibling" : "previousSibling",\n						parent = elem.parentNode,\n						name = ofType && elem.nodeName.toLowerCase(),\n						useCache = !xml && !ofType,\n						diff = false;\n\n					if ( parent ) {\n\n						// :(first|last|only)-(child|of-type)\n						if ( simple ) {\n							while ( dir ) {\n								node = elem;\n								while ( (node = node[ dir ]) ) {\n									if ( ofType ?\n										node.nodeName.toLowerCase() === name :\n										node.nodeType === 1 ) {\n\n										return false;\n									}\n								}\n								// Reverse direction for :only-* (if we haven\'t yet done so)\n								start = dir = type === "only" && !start && "nextSibling";\n							}\n							return true;\n						}\n\n						start = [ forward ? parent.firstChild : parent.lastChild ];\n\n						// non-xml :nth-child(...) stores cache data on `parent`\n						if ( forward && useCache ) {\n\n							// Seek `elem` from a previously-cached index\n\n							// ...in a gzip-friendly way\n							node = parent;\n							outerCache = node[ expando ] || (node[ expando ] = {});\n\n							// Support: IE <9 only\n							// Defend against cloned attroperties (jQuery gh-1709)\n							uniqueCache = outerCache[ node.uniqueID ] ||\n								(outerCache[ node.uniqueID ] = {});\n\n							cache = uniqueCache[ type ] || [];\n							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n							diff = nodeIndex && cache[ 2 ];\n							node = nodeIndex && parent.childNodes[ nodeIndex ];\n\n							while ( (node = ++nodeIndex && node && node[ dir ] ||\n\n								// Fallback to seeking `elem` from the start\n								(diff = nodeIndex = 0) || start.pop()) ) {\n\n								// When found, cache indexes on `parent` and break\n								if ( node.nodeType === 1 && ++diff && node === elem ) {\n									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n									break;\n								}\n							}\n\n						} else {\n							// Use previously-cached element index if available\n							if ( useCache ) {\n								// ...in a gzip-friendly way\n								node = elem;\n								outerCache = node[ expando ] || (node[ expando ] = {});\n\n								// Support: IE <9 only\n								// Defend against cloned attroperties (jQuery gh-1709)\n								uniqueCache = outerCache[ node.uniqueID ] ||\n									(outerCache[ node.uniqueID ] = {});\n\n								cache = uniqueCache[ type ] || [];\n								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n								diff = nodeIndex;\n							}\n\n							// xml :nth-child(...)\n							// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n							if ( diff === false ) {\n								// Use the same loop as above to seek `elem` from the start\n								while ( (node = ++nodeIndex && node && node[ dir ] ||\n									(diff = nodeIndex = 0) || start.pop()) ) {\n\n									if ( ( ofType ?\n										node.nodeName.toLowerCase() === name :\n										node.nodeType === 1 ) &&\n										++diff ) {\n\n										// Cache the index of each encountered element\n										if ( useCache ) {\n											outerCache = node[ expando ] || (node[ expando ] = {});\n\n											// Support: IE <9 only\n											// Defend against cloned attroperties (jQuery gh-1709)\n											uniqueCache = outerCache[ node.uniqueID ] ||\n												(outerCache[ node.uniqueID ] = {});\n\n											uniqueCache[ type ] = [ dirruns, diff ];\n										}\n\n										if ( node === elem ) {\n											break;\n										}\n									}\n								}\n							}\n						}\n\n						// Incorporate the offset, then check against cycle size\n						diff -= last;\n						return diff === first || ( diff % first === 0 && diff / first >= 0 );\n					}\n				};\n		},\n\n		"PSEUDO": function( pseudo, argument ) {\n			// pseudo-class names are case-insensitive\n			// http://www.w3.org/TR/selectors/#pseudo-classes\n			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n			// Remember that setFilters inherits from pseudos\n			var args,\n				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n					Sizzle.error( "unsupported pseudo: " + pseudo );\n\n			// The user may use createPseudo to indicate that\n			// arguments are needed to create the filter function\n			// just as Sizzle does\n			if ( fn[ expando ] ) {\n				return fn( argument );\n			}\n\n			// But maintain support for old signatures\n			if ( fn.length > 1 ) {\n				args = [ pseudo, pseudo, "", argument ];\n				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n					markFunction(function( seed, matches ) {\n						var idx,\n							matched = fn( seed, argument ),\n							i = matched.length;\n						while ( i-- ) {\n							idx = indexOf( seed, matched[i] );\n							seed[ idx ] = !( matches[ idx ] = matched[i] );\n						}\n					}) :\n					function( elem ) {\n						return fn( elem, 0, args );\n					};\n			}\n\n			return fn;\n		}\n	},\n\n	pseudos: {\n		// Potentially complex pseudos\n		"not": markFunction(function( selector ) {\n			// Trim the selector passed to compile\n			// to avoid treating leading and trailing\n			// spaces as combinators\n			var input = [],\n				results = [],\n				matcher = compile( selector.replace( rtrim, "$1" ) );\n\n			return matcher[ expando ] ?\n				markFunction(function( seed, matches, context, xml ) {\n					var elem,\n						unmatched = matcher( seed, null, xml, [] ),\n						i = seed.length;\n\n					// Match elements unmatched by `matcher`\n					while ( i-- ) {\n						if ( (elem = unmatched[i]) ) {\n							seed[i] = !(matches[i] = elem);\n						}\n					}\n				}) :\n				function( elem, context, xml ) {\n					input[0] = elem;\n					matcher( input, null, xml, results );\n					// Don\'t keep the element (issue #299)\n					input[0] = null;\n					return !results.pop();\n				};\n		}),\n\n		"has": markFunction(function( selector ) {\n			return function( elem ) {\n				return Sizzle( selector, elem ).length > 0;\n			};\n		}),\n\n		"contains": markFunction(function( text ) {\n			text = text.replace( runescape, funescape );\n			return function( elem ) {\n				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n			};\n		}),\n\n		// "Whether an element is represented by a :lang() selector\n		// is based solely on the element\'s language value\n		// being equal to the identifier C,\n		// or beginning with the identifier C immediately followed by "-".\n		// The matching of C against the element\'s language value is performed case-insensitively.\n		// The identifier C does not have to be a valid language name."\n		// http://www.w3.org/TR/selectors/#lang-pseudo\n		"lang": markFunction( function( lang ) {\n			// lang value must be a valid identifier\n			if ( !ridentifier.test(lang || "") ) {\n				Sizzle.error( "unsupported lang: " + lang );\n			}\n			lang = lang.replace( runescape, funescape ).toLowerCase();\n			return function( elem ) {\n				var elemLang;\n				do {\n					if ( (elemLang = documentIsHTML ?\n						elem.lang :\n						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {\n\n						elemLang = elemLang.toLowerCase();\n						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;\n					}\n				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n				return false;\n			};\n		}),\n\n		// Miscellaneous\n		"target": function( elem ) {\n			var hash = window.location && window.location.hash;\n			return hash && hash.slice( 1 ) === elem.id;\n		},\n\n		"root": function( elem ) {\n			return elem === docElem;\n		},\n\n		"focus": function( elem ) {\n			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n		},\n\n		// Boolean properties\n		"enabled": function( elem ) {\n			return elem.disabled === false;\n		},\n\n		"disabled": function( elem ) {\n			return elem.disabled === true;\n		},\n\n		"checked": function( elem ) {\n			// In CSS3, :checked should return both checked and selected elements\n			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n			var nodeName = elem.nodeName.toLowerCase();\n			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);\n		},\n\n		"selected": function( elem ) {\n			// Accessing this property makes selected-by-default\n			// options in Safari work properly\n			if ( elem.parentNode ) {\n				elem.parentNode.selectedIndex;\n			}\n\n			return elem.selected === true;\n		},\n\n		// Contents\n		"empty": function( elem ) {\n			// http://www.w3.org/TR/selectors/#empty-pseudo\n			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n			//   but not by others (comment: 8; processing instruction: 7; etc.)\n			// nodeType < 6 works because attributes (2) do not appear as children\n			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n				if ( elem.nodeType < 6 ) {\n					return false;\n				}\n			}\n			return true;\n		},\n\n		"parent": function( elem ) {\n			return !Expr.pseudos["empty"]( elem );\n		},\n\n		// Element/input types\n		"header": function( elem ) {\n			return rheader.test( elem.nodeName );\n		},\n\n		"input": function( elem ) {\n			return rinputs.test( elem.nodeName );\n		},\n\n		"button": function( elem ) {\n			var name = elem.nodeName.toLowerCase();\n			return name === "input" && elem.type === "button" || name === "button";\n		},\n\n		"text": function( elem ) {\n			var attr;\n			return elem.nodeName.toLowerCase() === "input" &&\n				elem.type === "text" &&\n\n				// Support: IE<8\n				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"\n				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );\n		},\n\n		// Position-in-collection\n		"first": createPositionalPseudo(function() {\n			return [ 0 ];\n		}),\n\n		"last": createPositionalPseudo(function( matchIndexes, length ) {\n			return [ length - 1 ];\n		}),\n\n		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {\n			return [ argument < 0 ? argument + length : argument ];\n		}),\n\n		"even": createPositionalPseudo(function( matchIndexes, length ) {\n			var i = 0;\n			for ( ; i < length; i += 2 ) {\n				matchIndexes.push( i );\n			}\n			return matchIndexes;\n		}),\n\n		"odd": createPositionalPseudo(function( matchIndexes, length ) {\n			var i = 1;\n			for ( ; i < length; i += 2 ) {\n				matchIndexes.push( i );\n			}\n			return matchIndexes;\n		}),\n\n		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {\n			var i = argument < 0 ? argument + length : argument;\n			for ( ; --i >= 0; ) {\n				matchIndexes.push( i );\n			}\n			return matchIndexes;\n		}),\n\n		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {\n			var i = argument < 0 ? argument + length : argument;\n			for ( ; ++i < length; ) {\n				matchIndexes.push( i );\n			}\n			return matchIndexes;\n		})\n	}\n};\n\nExpr.pseudos["nth"] = Expr.pseudos["eq"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n	Expr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n	Expr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n	var matched, match, tokens, type,\n		soFar, groups, preFilters,\n		cached = tokenCache[ selector + " " ];\n\n	if ( cached ) {\n		return parseOnly ? 0 : cached.slice( 0 );\n	}\n\n	soFar = selector;\n	groups = [];\n	preFilters = Expr.preFilter;\n\n	while ( soFar ) {\n\n		// Comma and first run\n		if ( !matched || (match = rcomma.exec( soFar )) ) {\n			if ( match ) {\n				// Don\'t consume trailing commas as valid\n				soFar = soFar.slice( match[0].length ) || soFar;\n			}\n			groups.push( (tokens = []) );\n		}\n\n		matched = false;\n\n		// Combinators\n		if ( (match = rcombinators.exec( soFar )) ) {\n			matched = match.shift();\n			tokens.push({\n				value: matched,\n				// Cast descendant combinators to space\n				type: match[0].replace( rtrim, " " )\n			});\n			soFar = soFar.slice( matched.length );\n		}\n\n		// Filters\n		for ( type in Expr.filter ) {\n			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n				(match = preFilters[ type ]( match ))) ) {\n				matched = match.shift();\n				tokens.push({\n					value: matched,\n					type: type,\n					matches: match\n				});\n				soFar = soFar.slice( matched.length );\n			}\n		}\n\n		if ( !matched ) {\n			break;\n		}\n	}\n\n	// Return the length of the invalid excess\n	// if we\'re just parsing\n	// Otherwise, throw an error or return tokens\n	return parseOnly ?\n		soFar.length :\n		soFar ?\n			Sizzle.error( selector ) :\n			// Cache the tokens\n			tokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n	var i = 0,\n		len = tokens.length,\n		selector = "";\n	for ( ; i < len; i++ ) {\n		selector += tokens[i].value;\n	}\n	return selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n	var dir = combinator.dir,\n		checkNonElements = base && dir === "parentNode",\n		doneName = done++;\n\n	return combinator.first ?\n		// Check against closest ancestor/preceding element\n		function( elem, context, xml ) {\n			while ( (elem = elem[ dir ]) ) {\n				if ( elem.nodeType === 1 || checkNonElements ) {\n					return matcher( elem, context, xml );\n				}\n			}\n		} :\n\n		// Check against all ancestor/preceding elements\n		function( elem, context, xml ) {\n			var oldCache, uniqueCache, outerCache,\n				newCache = [ dirruns, doneName ];\n\n			// We can\'t set arbitrary data on XML nodes, so they don\'t benefit from combinator caching\n			if ( xml ) {\n				while ( (elem = elem[ dir ]) ) {\n					if ( elem.nodeType === 1 || checkNonElements ) {\n						if ( matcher( elem, context, xml ) ) {\n							return true;\n						}\n					}\n				}\n			} else {\n				while ( (elem = elem[ dir ]) ) {\n					if ( elem.nodeType === 1 || checkNonElements ) {\n						outerCache = elem[ expando ] || (elem[ expando ] = {});\n\n						// Support: IE <9 only\n						// Defend against cloned attroperties (jQuery gh-1709)\n						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\n\n						if ( (oldCache = uniqueCache[ dir ]) &&\n							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n							// Assign to newCache so results back-propagate to previous elements\n							return (newCache[ 2 ] = oldCache[ 2 ]);\n						} else {\n							// Reuse newcache so results back-propagate to previous elements\n							uniqueCache[ dir ] = newCache;\n\n							// A match means we\'re done; a fail means we have to keep checking\n							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n								return true;\n							}\n						}\n					}\n				}\n			}\n		};\n}\n\nfunction elementMatcher( matchers ) {\n	return matchers.length > 1 ?\n		function( elem, context, xml ) {\n			var i = matchers.length;\n			while ( i-- ) {\n				if ( !matchers[i]( elem, context, xml ) ) {\n					return false;\n				}\n			}\n			return true;\n		} :\n		matchers[0];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n	var i = 0,\n		len = contexts.length;\n	for ( ; i < len; i++ ) {\n		Sizzle( selector, contexts[i], results );\n	}\n	return results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n	var elem,\n		newUnmatched = [],\n		i = 0,\n		len = unmatched.length,\n		mapped = map != null;\n\n	for ( ; i < len; i++ ) {\n		if ( (elem = unmatched[i]) ) {\n			if ( !filter || filter( elem, context, xml ) ) {\n				newUnmatched.push( elem );\n				if ( mapped ) {\n					map.push( i );\n				}\n			}\n		}\n	}\n\n	return newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n	if ( postFilter && !postFilter[ expando ] ) {\n		postFilter = setMatcher( postFilter );\n	}\n	if ( postFinder && !postFinder[ expando ] ) {\n		postFinder = setMatcher( postFinder, postSelector );\n	}\n	return markFunction(function( seed, results, context, xml ) {\n		var temp, i, elem,\n			preMap = [],\n			postMap = [],\n			preexisting = results.length,\n\n			// Get initial elements from seed or context\n			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),\n\n			// Prefilter to get matcher input, preserving a map for seed-results synchronization\n			matcherIn = preFilter && ( seed || !selector ) ?\n				condense( elems, preMap, preFilter, context, xml ) :\n				elems,\n\n			matcherOut = matcher ?\n				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n					// ...intermediate processing is necessary\n					[] :\n\n					// ...otherwise use results directly\n					results :\n				matcherIn;\n\n		// Find primary matches\n		if ( matcher ) {\n			matcher( matcherIn, matcherOut, context, xml );\n		}\n\n		// Apply postFilter\n		if ( postFilter ) {\n			temp = condense( matcherOut, postMap );\n			postFilter( temp, [], context, xml );\n\n			// Un-match failing elements by moving them back to matcherIn\n			i = temp.length;\n			while ( i-- ) {\n				if ( (elem = temp[i]) ) {\n					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n				}\n			}\n		}\n\n		if ( seed ) {\n			if ( postFinder || preFilter ) {\n				if ( postFinder ) {\n					// Get the final matcherOut by condensing this intermediate into postFinder contexts\n					temp = [];\n					i = matcherOut.length;\n					while ( i-- ) {\n						if ( (elem = matcherOut[i]) ) {\n							// Restore matcherIn since elem is not yet a final match\n							temp.push( (matcherIn[i] = elem) );\n						}\n					}\n					postFinder( null, (matcherOut = []), temp, xml );\n				}\n\n				// Move matched elements from seed to results to keep them synchronized\n				i = matcherOut.length;\n				while ( i-- ) {\n					if ( (elem = matcherOut[i]) &&\n						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\n						seed[temp] = !(results[temp] = elem);\n					}\n				}\n			}\n\n		// Add elements to results, through postFinder if defined\n		} else {\n			matcherOut = condense(\n				matcherOut === results ?\n					matcherOut.splice( preexisting, matcherOut.length ) :\n					matcherOut\n			);\n			if ( postFinder ) {\n				postFinder( null, results, matcherOut, xml );\n			} else {\n				push.apply( results, matcherOut );\n			}\n		}\n	});\n}\n\nfunction matcherFromTokens( tokens ) {\n	var checkContext, matcher, j,\n		len = tokens.length,\n		leadingRelative = Expr.relative[ tokens[0].type ],\n		implicitRelative = leadingRelative || Expr.relative[" "],\n		i = leadingRelative ? 1 : 0,\n\n		// The foundational matcher ensures that elements are reachable from top-level context(s)\n		matchContext = addCombinator( function( elem ) {\n			return elem === checkContext;\n		}, implicitRelative, true ),\n		matchAnyContext = addCombinator( function( elem ) {\n			return indexOf( checkContext, elem ) > -1;\n		}, implicitRelative, true ),\n		matchers = [ function( elem, context, xml ) {\n			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n				(checkContext = context).nodeType ?\n					matchContext( elem, context, xml ) :\n					matchAnyContext( elem, context, xml ) );\n			// Avoid hanging onto element (issue #299)\n			checkContext = null;\n			return ret;\n		} ];\n\n	for ( ; i < len; i++ ) {\n		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n		} else {\n			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n			// Return special upon seeing a positional matcher\n			if ( matcher[ expando ] ) {\n				// Find the next relative operator (if any) for proper handling\n				j = ++i;\n				for ( ; j < len; j++ ) {\n					if ( Expr.relative[ tokens[j].type ] ) {\n						break;\n					}\n				}\n				return setMatcher(\n					i > 1 && elementMatcher( matchers ),\n					i > 1 && toSelector(\n						// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })\n					).replace( rtrim, "$1" ),\n					matcher,\n					i < j && matcherFromTokens( tokens.slice( i, j ) ),\n					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n					j < len && toSelector( tokens )\n				);\n			}\n			matchers.push( matcher );\n		}\n	}\n\n	return elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n	var bySet = setMatchers.length > 0,\n		byElement = elementMatchers.length > 0,\n		superMatcher = function( seed, context, xml, results, outermost ) {\n			var elem, j, matcher,\n				matchedCount = 0,\n				i = "0",\n				unmatched = seed && [],\n				setMatched = [],\n				contextBackup = outermostContext,\n				// We must always have either seed elements or outermost context\n				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),\n				// Use integer dirruns iff this is the outermost matcher\n				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n				len = elems.length;\n\n			if ( outermost ) {\n				outermostContext = context === document || context || outermost;\n			}\n\n			// Add elements passing elementMatchers directly to results\n			// Support: IE<9, Safari\n			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id\n			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n				if ( byElement && elem ) {\n					j = 0;\n					if ( !context && elem.ownerDocument !== document ) {\n						setDocument( elem );\n						xml = !documentIsHTML;\n					}\n					while ( (matcher = elementMatchers[j++]) ) {\n						if ( matcher( elem, context || document, xml) ) {\n							results.push( elem );\n							break;\n						}\n					}\n					if ( outermost ) {\n						dirruns = dirrunsUnique;\n					}\n				}\n\n				// Track unmatched elements for set filters\n				if ( bySet ) {\n					// They will have gone through all possible matchers\n					if ( (elem = !matcher && elem) ) {\n						matchedCount--;\n					}\n\n					// Lengthen the array for every element, matched or not\n					if ( seed ) {\n						unmatched.push( elem );\n					}\n				}\n			}\n\n			// `i` is now the count of elements visited above, and adding it to `matchedCount`\n			// makes the latter nonnegative.\n			matchedCount += i;\n\n			// Apply set filters to unmatched elements\n			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n			// equals `i`), unless we didn\'t visit _any_ elements in the above loop because we have\n			// no element matchers and no seed.\n			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that\n			// case, which will result in a "00" `matchedCount` that differs from `i` but is also\n			// numerically zero.\n			if ( bySet && i !== matchedCount ) {\n				j = 0;\n				while ( (matcher = setMatchers[j++]) ) {\n					matcher( unmatched, setMatched, context, xml );\n				}\n\n				if ( seed ) {\n					// Reintegrate element matches to eliminate the need for sorting\n					if ( matchedCount > 0 ) {\n						while ( i-- ) {\n							if ( !(unmatched[i] || setMatched[i]) ) {\n								setMatched[i] = pop.call( results );\n							}\n						}\n					}\n\n					// Discard index placeholder values to get only actual matches\n					setMatched = condense( setMatched );\n				}\n\n				// Add matches to results\n				push.apply( results, setMatched );\n\n				// Seedless set matches succeeding multiple successful matchers stipulate sorting\n				if ( outermost && !seed && setMatched.length > 0 &&\n					( matchedCount + setMatchers.length ) > 1 ) {\n\n					Sizzle.uniqueSort( results );\n				}\n			}\n\n			// Override manipulation of globals by nested matchers\n			if ( outermost ) {\n				dirruns = dirrunsUnique;\n				outermostContext = contextBackup;\n			}\n\n			return unmatched;\n		};\n\n	return bySet ?\n		markFunction( superMatcher ) :\n		superMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n	var i,\n		setMatchers = [],\n		elementMatchers = [],\n		cached = compilerCache[ selector + " " ];\n\n	if ( !cached ) {\n		// Generate a function of recursive functions that can be used to check each element\n		if ( !match ) {\n			match = tokenize( selector );\n		}\n		i = match.length;\n		while ( i-- ) {\n			cached = matcherFromTokens( match[i] );\n			if ( cached[ expando ] ) {\n				setMatchers.push( cached );\n			} else {\n				elementMatchers.push( cached );\n			}\n		}\n\n		// Cache the compiled function\n		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n		// Save selector and tokenization\n		cached.selector = selector;\n	}\n	return cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle\'s compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n	var i, tokens, token, type, find,\n		compiled = typeof selector === "function" && selector,\n		match = !seed && tokenize( (selector = compiled.selector || selector) );\n\n	results = results || [];\n\n	// Try to minimize operations if there is only one selector in the list and no seed\n	// (the latter of which guarantees us context)\n	if ( match.length === 1 ) {\n\n		// Reduce context if the leading compound selector is an ID\n		tokens = match[0] = match[0].slice( 0 );\n		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&\n				support.getById && context.nodeType === 9 && documentIsHTML &&\n				Expr.relative[ tokens[1].type ] ) {\n\n			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n			if ( !context ) {\n				return results;\n\n			// Precompiled matchers will still verify ancestry, so step up a level\n			} else if ( compiled ) {\n				context = context.parentNode;\n			}\n\n			selector = selector.slice( tokens.shift().value.length );\n		}\n\n		// Fetch a seed set for right-to-left matching\n		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;\n		while ( i-- ) {\n			token = tokens[i];\n\n			// Abort if we hit a combinator\n			if ( Expr.relative[ (type = token.type) ] ) {\n				break;\n			}\n			if ( (find = Expr.find[ type ]) ) {\n				// Search, expanding context for leading sibling combinators\n				if ( (seed = find(\n					token.matches[0].replace( runescape, funescape ),\n					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n				)) ) {\n\n					// If seed is empty or no tokens remain, we can return early\n					tokens.splice( i, 1 );\n					selector = seed.length && toSelector( tokens );\n					if ( !selector ) {\n						push.apply( results, seed );\n						return results;\n					}\n\n					break;\n				}\n			}\n		}\n	}\n\n	// Compile and execute a filtering function if one is not provided\n	// Provide `match` to avoid retokenization if we modified the selector above\n	( compiled || compile( selector, match ) )(\n		seed,\n		context,\n		!documentIsHTML,\n		results,\n		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n	);\n	return results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split("").sort( sortOrder ).join("") === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren\'t passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( div1 ) {\n	// Should return 1, but returns 4 (following)\n	return div1.compareDocumentPosition( document.createElement("div") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property "interpolation"\n// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( div ) {\n	div.innerHTML = "<a href=\'#\'></a>";\n	return div.firstChild.getAttribute("href") === "#" ;\n}) ) {\n	addHandle( "type|href|height|width", function( elem, name, isXML ) {\n		if ( !isXML ) {\n			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );\n		}\n	});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute("value")\nif ( !support.attributes || !assert(function( div ) {\n	div.innerHTML = "<input/>";\n	div.firstChild.setAttribute( "value", "" );\n	return div.firstChild.getAttribute( "value" ) === "";\n}) ) {\n	addHandle( "value", function( elem, name, isXML ) {\n		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {\n			return elem.defaultValue;\n		}\n	});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( div ) {\n	return div.getAttribute("disabled") == null;\n}) ) {\n	addHandle( booleans, function( elem, name, isXML ) {\n		var val;\n		if ( !isXML ) {\n			return elem[ name ] === true ? name.toLowerCase() :\n					(val = elem.getAttributeNode( name )) && val.specified ?\n					val.value :\n				null;\n		}\n	});\n}\n\nreturn Sizzle;\n\n})( window );\n\n\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\njQuery.expr[ ":" ] = jQuery.expr.pseudos;\njQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\n\n\n\nvar dir = function( elem, dir, until ) {\n	var matched = [],\n		truncate = until !== undefined;\n\n	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\n		if ( elem.nodeType === 1 ) {\n			if ( truncate && jQuery( elem ).is( until ) ) {\n				break;\n			}\n			matched.push( elem );\n		}\n	}\n	return matched;\n};\n\n\nvar siblings = function( n, elem ) {\n	var matched = [];\n\n	for ( ; n; n = n.nextSibling ) {\n		if ( n.nodeType === 1 && n !== elem ) {\n			matched.push( n );\n		}\n	}\n\n	return matched;\n};\n\n\nvar rneedsContext = jQuery.expr.match.needsContext;\n\nvar rsingleTag = ( /^<([\\w-]+)\\s*\\/?>(?:<\\/\\1>|)$/ );\n\n\n\nvar risSimple = /^.[^:#\\[\\.,]*$/;\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n	if ( jQuery.isFunction( qualifier ) ) {\n		return jQuery.grep( elements, function( elem, i ) {\n			/* jshint -W018 */\n			return !!qualifier.call( elem, i, elem ) !== not;\n		} );\n\n	}\n\n	if ( qualifier.nodeType ) {\n		return jQuery.grep( elements, function( elem ) {\n			return ( elem === qualifier ) !== not;\n		} );\n\n	}\n\n	if ( typeof qualifier === "string" ) {\n		if ( risSimple.test( qualifier ) ) {\n			return jQuery.filter( qualifier, elements, not );\n		}\n\n		qualifier = jQuery.filter( qualifier, elements );\n	}\n\n	return jQuery.grep( elements, function( elem ) {\n		return ( jQuery.inArray( elem, qualifier ) > -1 ) !== not;\n	} );\n}\n\njQuery.filter = function( expr, elems, not ) {\n	var elem = elems[ 0 ];\n\n	if ( not ) {\n		expr = ":not(" + expr + ")";\n	}\n\n	return elems.length === 1 && elem.nodeType === 1 ?\n		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :\n		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n			return elem.nodeType === 1;\n		} ) );\n};\n\njQuery.fn.extend( {\n	find: function( selector ) {\n		var i,\n			ret = [],\n			self = this,\n			len = self.length;\n\n		if ( typeof selector !== "string" ) {\n			return this.pushStack( jQuery( selector ).filter( function() {\n				for ( i = 0; i < len; i++ ) {\n					if ( jQuery.contains( self[ i ], this ) ) {\n						return true;\n					}\n				}\n			} ) );\n		}\n\n		for ( i = 0; i < len; i++ ) {\n			jQuery.find( selector, self[ i ], ret );\n		}\n\n		// Needed because $( selector, context ) becomes $( context ).find( selector )\n		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );\n		ret.selector = this.selector ? this.selector + " " + selector : selector;\n		return ret;\n	},\n	filter: function( selector ) {\n		return this.pushStack( winnow( this, selector || [], false ) );\n	},\n	not: function( selector ) {\n		return this.pushStack( winnow( this, selector || [], true ) );\n	},\n	is: function( selector ) {\n		return !!winnow(\n			this,\n\n			// If this is a positional/relative selector, check membership in the returned set\n			// so $("p:first").is("p:last") won\'t return true for a doc with two "p".\n			typeof selector === "string" && rneedsContext.test( selector ) ?\n				jQuery( selector ) :\n				selector || [],\n			false\n		).length;\n	}\n} );\n\n\n// Initialize a jQuery object\n\n\n// A central reference to the root jQuery(document)\nvar rootjQuery,\n\n	// A simple way to check for HTML strings\n	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n	// Strict HTML recognition (#11290: must start with <)\n	rquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n\n	init = jQuery.fn.init = function( selector, context, root ) {\n		var match, elem;\n\n		// HANDLE: $(""), $(null), $(undefined), $(false)\n		if ( !selector ) {\n			return this;\n		}\n\n		// init accepts an alternate rootjQuery\n		// so migrate can support jQuery.sub (gh-2101)\n		root = root || rootjQuery;\n\n		// Handle HTML strings\n		if ( typeof selector === "string" ) {\n			if ( selector.charAt( 0 ) === "<" &&\n				selector.charAt( selector.length - 1 ) === ">" &&\n				selector.length >= 3 ) {\n\n				// Assume that strings that start and end with <> are HTML and skip the regex check\n				match = [ null, selector, null ];\n\n			} else {\n				match = rquickExpr.exec( selector );\n			}\n\n			// Match html or make sure no context is specified for #id\n			if ( match && ( match[ 1 ] || !context ) ) {\n\n				// HANDLE: $(html) -> $(array)\n				if ( match[ 1 ] ) {\n					context = context instanceof jQuery ? context[ 0 ] : context;\n\n					// scripts is true for back-compat\n					// Intentionally let the error be thrown if parseHTML is not present\n					jQuery.merge( this, jQuery.parseHTML(\n						match[ 1 ],\n						context && context.nodeType ? context.ownerDocument || context : document,\n						true\n					) );\n\n					// HANDLE: $(html, props)\n					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\n						for ( match in context ) {\n\n							// Properties of context are called as methods if possible\n							if ( jQuery.isFunction( this[ match ] ) ) {\n								this[ match ]( context[ match ] );\n\n							// ...and otherwise set as attributes\n							} else {\n								this.attr( match, context[ match ] );\n							}\n						}\n					}\n\n					return this;\n\n				// HANDLE: $(#id)\n				} else {\n					elem = document.getElementById( match[ 2 ] );\n\n					// Check parentNode to catch when Blackberry 4.6 returns\n					// nodes that are no longer in the document #6963\n					if ( elem && elem.parentNode ) {\n\n						// Handle the case where IE and Opera return items\n						// by name instead of ID\n						if ( elem.id !== match[ 2 ] ) {\n							return rootjQuery.find( selector );\n						}\n\n						// Otherwise, we inject the element directly into the jQuery object\n						this.length = 1;\n						this[ 0 ] = elem;\n					}\n\n					this.context = document;\n					this.selector = selector;\n					return this;\n				}\n\n			// HANDLE: $(expr, $(...))\n			} else if ( !context || context.jquery ) {\n				return ( context || root ).find( selector );\n\n			// HANDLE: $(expr, context)\n			// (which is just equivalent to: $(context).find(expr)\n			} else {\n				return this.constructor( context ).find( selector );\n			}\n\n		// HANDLE: $(DOMElement)\n		} else if ( selector.nodeType ) {\n			this.context = this[ 0 ] = selector;\n			this.length = 1;\n			return this;\n\n		// HANDLE: $(function)\n		// Shortcut for document ready\n		} else if ( jQuery.isFunction( selector ) ) {\n			return typeof root.ready !== "undefined" ?\n				root.ready( selector ) :\n\n				// Execute immediately if ready is not present\n				selector( jQuery );\n		}\n\n		if ( selector.selector !== undefined ) {\n			this.selector = selector.selector;\n			this.context = selector.context;\n		}\n\n		return jQuery.makeArray( selector, this );\n	};\n\n// Give the init function the jQuery prototype for later instantiation\ninit.prototype = jQuery.fn;\n\n// Initialize central reference\nrootjQuery = jQuery( document );\n\n\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\n	// methods guaranteed to produce a unique set when starting from a unique set\n	guaranteedUnique = {\n		children: true,\n		contents: true,\n		next: true,\n		prev: true\n	};\n\njQuery.fn.extend( {\n	has: function( target ) {\n		var i,\n			targets = jQuery( target, this ),\n			len = targets.length;\n\n		return this.filter( function() {\n			for ( i = 0; i < len; i++ ) {\n				if ( jQuery.contains( this, targets[ i ] ) ) {\n					return true;\n				}\n			}\n		} );\n	},\n\n	closest: function( selectors, context ) {\n		var cur,\n			i = 0,\n			l = this.length,\n			matched = [],\n			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?\n				jQuery( selectors, context || this.context ) :\n				0;\n\n		for ( ; i < l; i++ ) {\n			for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\n\n				// Always skip document fragments\n				if ( cur.nodeType < 11 && ( pos ?\n					pos.index( cur ) > -1 :\n\n					// Don\'t pass non-elements to Sizzle\n					cur.nodeType === 1 &&\n						jQuery.find.matchesSelector( cur, selectors ) ) ) {\n\n					matched.push( cur );\n					break;\n				}\n			}\n		}\n\n		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\n	},\n\n	// Determine the position of an element within\n	// the matched set of elements\n	index: function( elem ) {\n\n		// No argument, return index in parent\n		if ( !elem ) {\n			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n		}\n\n		// index in selector\n		if ( typeof elem === "string" ) {\n			return jQuery.inArray( this[ 0 ], jQuery( elem ) );\n		}\n\n		// Locate the position of the desired element\n		return jQuery.inArray(\n\n			// If it receives a jQuery object, the first element is used\n			elem.jquery ? elem[ 0 ] : elem, this );\n	},\n\n	add: function( selector, context ) {\n		return this.pushStack(\n			jQuery.uniqueSort(\n				jQuery.merge( this.get(), jQuery( selector, context ) )\n			)\n		);\n	},\n\n	addBack: function( selector ) {\n		return this.add( selector == null ?\n			this.prevObject : this.prevObject.filter( selector )\n		);\n	}\n} );\n\nfunction sibling( cur, dir ) {\n	do {\n		cur = cur[ dir ];\n	} while ( cur && cur.nodeType !== 1 );\n\n	return cur;\n}\n\njQuery.each( {\n	parent: function( elem ) {\n		var parent = elem.parentNode;\n		return parent && parent.nodeType !== 11 ? parent : null;\n	},\n	parents: function( elem ) {\n		return dir( elem, "parentNode" );\n	},\n	parentsUntil: function( elem, i, until ) {\n		return dir( elem, "parentNode", until );\n	},\n	next: function( elem ) {\n		return sibling( elem, "nextSibling" );\n	},\n	prev: function( elem ) {\n		return sibling( elem, "previousSibling" );\n	},\n	nextAll: function( elem ) {\n		return dir( elem, "nextSibling" );\n	},\n	prevAll: function( elem ) {\n		return dir( elem, "previousSibling" );\n	},\n	nextUntil: function( elem, i, until ) {\n		return dir( elem, "nextSibling", until );\n	},\n	prevUntil: function( elem, i, until ) {\n		return dir( elem, "previousSibling", until );\n	},\n	siblings: function( elem ) {\n		return siblings( ( elem.parentNode || {} ).firstChild, elem );\n	},\n	children: function( elem ) {\n		return siblings( elem.firstChild );\n	},\n	contents: function( elem ) {\n		return jQuery.nodeName( elem, "iframe" ) ?\n			elem.contentDocument || elem.contentWindow.document :\n			jQuery.merge( [], elem.childNodes );\n	}\n}, function( name, fn ) {\n	jQuery.fn[ name ] = function( until, selector ) {\n		var ret = jQuery.map( this, fn, until );\n\n		if ( name.slice( -5 ) !== "Until" ) {\n			selector = until;\n		}\n\n		if ( selector && typeof selector === "string" ) {\n			ret = jQuery.filter( selector, ret );\n		}\n\n		if ( this.length > 1 ) {\n\n			// Remove duplicates\n			if ( !guaranteedUnique[ name ] ) {\n				ret = jQuery.uniqueSort( ret );\n			}\n\n			// Reverse order for parents* and prev-derivatives\n			if ( rparentsprev.test( name ) ) {\n				ret = ret.reverse();\n			}\n		}\n\n		return this.pushStack( ret );\n	};\n} );\nvar rnotwhite = ( /\\S+/g );\n\n\n\n// Convert String-formatted options into Object-formatted ones\nfunction createOptions( options ) {\n	var object = {};\n	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {\n		object[ flag ] = true;\n	} );\n	return object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *	options: an optional list of space-separated options that will change how\n *			the callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * "fired" multiple times.\n *\n * Possible options:\n *\n *	once:			will ensure the callback list can only be fired once (like a Deferred)\n *\n *	memory:			will keep track of previous values and will call any callback added\n *					after the list has been fired right away with the latest "memorized"\n *					values (like a Deferred)\n *\n *	unique:			will ensure a callback can only be added once (no duplicate in the list)\n *\n *	stopOnFalse:	interrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n	// Convert options from String-formatted to Object-formatted if needed\n	// (we check in cache first)\n	options = typeof options === "string" ?\n		createOptions( options ) :\n		jQuery.extend( {}, options );\n\n	var // Flag to know if list is currently firing\n		firing,\n\n		// Last fire value for non-forgettable lists\n		memory,\n\n		// Flag to know if list was already fired\n		fired,\n\n		// Flag to prevent firing\n		locked,\n\n		// Actual callback list\n		list = [],\n\n		// Queue of execution data for repeatable lists\n		queue = [],\n\n		// Index of currently firing callback (modified by add/remove as needed)\n		firingIndex = -1,\n\n		// Fire callbacks\n		fire = function() {\n\n			// Enforce single-firing\n			locked = options.once;\n\n			// Execute callbacks for all pending executions,\n			// respecting firingIndex overrides and runtime changes\n			fired = firing = true;\n			for ( ; queue.length; firingIndex = -1 ) {\n				memory = queue.shift();\n				while ( ++firingIndex < list.length ) {\n\n					// Run callback and check for early termination\n					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n						options.stopOnFalse ) {\n\n						// Jump to end and forget the data so .add doesn\'t re-fire\n						firingIndex = list.length;\n						memory = false;\n					}\n				}\n			}\n\n			// Forget the data if we\'re done with it\n			if ( !options.memory ) {\n				memory = false;\n			}\n\n			firing = false;\n\n			// Clean up if we\'re done firing for good\n			if ( locked ) {\n\n				// Keep an empty list if we have data for future add calls\n				if ( memory ) {\n					list = [];\n\n				// Otherwise, this object is spent\n				} else {\n					list = "";\n				}\n			}\n		},\n\n		// Actual Callbacks object\n		self = {\n\n			// Add a callback or a collection of callbacks to the list\n			add: function() {\n				if ( list ) {\n\n					// If we have memory from a past run, we should fire after adding\n					if ( memory && !firing ) {\n						firingIndex = list.length - 1;\n						queue.push( memory );\n					}\n\n					( function add( args ) {\n						jQuery.each( args, function( _, arg ) {\n							if ( jQuery.isFunction( arg ) ) {\n								if ( !options.unique || !self.has( arg ) ) {\n									list.push( arg );\n								}\n							} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {\n\n								// Inspect recursively\n								add( arg );\n							}\n						} );\n					} )( arguments );\n\n					if ( memory && !firing ) {\n						fire();\n					}\n				}\n				return this;\n			},\n\n			// Remove a callback from the list\n			remove: function() {\n				jQuery.each( arguments, function( _, arg ) {\n					var index;\n					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n						list.splice( index, 1 );\n\n						// Handle firing indexes\n						if ( index <= firingIndex ) {\n							firingIndex--;\n						}\n					}\n				} );\n				return this;\n			},\n\n			// Check if a given callback is in the list.\n			// If no argument is given, return whether or not list has callbacks attached.\n			has: function( fn ) {\n				return fn ?\n					jQuery.inArray( fn, list ) > -1 :\n					list.length > 0;\n			},\n\n			// Remove all callbacks from the list\n			empty: function() {\n				if ( list ) {\n					list = [];\n				}\n				return this;\n			},\n\n			// Disable .fire and .add\n			// Abort any current/pending executions\n			// Clear all callbacks and values\n			disable: function() {\n				locked = queue = [];\n				list = memory = "";\n				return this;\n			},\n			disabled: function() {\n				return !list;\n			},\n\n			// Disable .fire\n			// Also disable .add unless we have memory (since it would have no effect)\n			// Abort any pending executions\n			lock: function() {\n				locked = true;\n				if ( !memory ) {\n					self.disable();\n				}\n				return this;\n			},\n			locked: function() {\n				return !!locked;\n			},\n\n			// Call all callbacks with the given context and arguments\n			fireWith: function( context, args ) {\n				if ( !locked ) {\n					args = args || [];\n					args = [ context, args.slice ? args.slice() : args ];\n					queue.push( args );\n					if ( !firing ) {\n						fire();\n					}\n				}\n				return this;\n			},\n\n			// Call all the callbacks with the given arguments\n			fire: function() {\n				self.fireWith( this, arguments );\n				return this;\n			},\n\n			// To know if the callbacks have already been called at least once\n			fired: function() {\n				return !!fired;\n			}\n		};\n\n	return self;\n};\n\n\njQuery.extend( {\n\n	Deferred: function( func ) {\n		var tuples = [\n\n				// action, add listener, listener list, final state\n				[ "resolve", "done", jQuery.Callbacks( "once memory" ), "resolved" ],\n				[ "reject", "fail", jQuery.Callbacks( "once memory" ), "rejected" ],\n				[ "notify", "progress", jQuery.Callbacks( "memory" ) ]\n			],\n			state = "pending",\n			promise = {\n				state: function() {\n					return state;\n				},\n				always: function() {\n					deferred.done( arguments ).fail( arguments );\n					return this;\n				},\n				then: function( /* fnDone, fnFail, fnProgress */ ) {\n					var fns = arguments;\n					return jQuery.Deferred( function( newDefer ) {\n						jQuery.each( tuples, function( i, tuple ) {\n							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];\n\n							// deferred[ done | fail | progress ] for forwarding actions to newDefer\n							deferred[ tuple[ 1 ] ]( function() {\n								var returned = fn && fn.apply( this, arguments );\n								if ( returned && jQuery.isFunction( returned.promise ) ) {\n									returned.promise()\n										.progress( newDefer.notify )\n										.done( newDefer.resolve )\n										.fail( newDefer.reject );\n								} else {\n									newDefer[ tuple[ 0 ] + "With" ](\n										this === promise ? newDefer.promise() : this,\n										fn ? [ returned ] : arguments\n									);\n								}\n							} );\n						} );\n						fns = null;\n					} ).promise();\n				},\n\n				// Get a promise for this deferred\n				// If obj is provided, the promise aspect is added to the object\n				promise: function( obj ) {\n					return obj != null ? jQuery.extend( obj, promise ) : promise;\n				}\n			},\n			deferred = {};\n\n		// Keep pipe for back-compat\n		promise.pipe = promise.then;\n\n		// Add list-specific methods\n		jQuery.each( tuples, function( i, tuple ) {\n			var list = tuple[ 2 ],\n				stateString = tuple[ 3 ];\n\n			// promise[ done | fail | progress ] = list.add\n			promise[ tuple[ 1 ] ] = list.add;\n\n			// Handle state\n			if ( stateString ) {\n				list.add( function() {\n\n					// state = [ resolved | rejected ]\n					state = stateString;\n\n				// [ reject_list | resolve_list ].disable; progress_list.lock\n				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );\n			}\n\n			// deferred[ resolve | reject | notify ]\n			deferred[ tuple[ 0 ] ] = function() {\n				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? promise : this, arguments );\n				return this;\n			};\n			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;\n		} );\n\n		// Make the deferred a promise\n		promise.promise( deferred );\n\n		// Call given func if any\n		if ( func ) {\n			func.call( deferred, deferred );\n		}\n\n		// All done!\n		return deferred;\n	},\n\n	// Deferred helper\n	when: function( subordinate /* , ..., subordinateN */ ) {\n		var i = 0,\n			resolveValues = slice.call( arguments ),\n			length = resolveValues.length,\n\n			// the count of uncompleted subordinates\n			remaining = length !== 1 ||\n				( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,\n\n			// the master Deferred.\n			// If resolveValues consist of only a single Deferred, just use that.\n			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n\n			// Update function for both resolve and progress values\n			updateFunc = function( i, contexts, values ) {\n				return function( value ) {\n					contexts[ i ] = this;\n					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n					if ( values === progressValues ) {\n						deferred.notifyWith( contexts, values );\n\n					} else if ( !( --remaining ) ) {\n						deferred.resolveWith( contexts, values );\n					}\n				};\n			},\n\n			progressValues, progressContexts, resolveContexts;\n\n		// add listeners to Deferred subordinates; treat others as resolved\n		if ( length > 1 ) {\n			progressValues = new Array( length );\n			progressContexts = new Array( length );\n			resolveContexts = new Array( length );\n			for ( ; i < length; i++ ) {\n				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {\n					resolveValues[ i ].promise()\n						.progress( updateFunc( i, progressContexts, progressValues ) )\n						.done( updateFunc( i, resolveContexts, resolveValues ) )\n						.fail( deferred.reject );\n				} else {\n					--remaining;\n				}\n			}\n		}\n\n		// if we\'re not waiting on anything, resolve the master\n		if ( !remaining ) {\n			deferred.resolveWith( resolveContexts, resolveValues );\n		}\n\n		return deferred.promise();\n	}\n} );\n\n\n// The deferred used on DOM ready\nvar readyList;\n\njQuery.fn.ready = function( fn ) {\n\n	// Add the callback\n	jQuery.ready.promise().done( fn );\n\n	return this;\n};\n\njQuery.extend( {\n\n	// Is the DOM ready to be used? Set to true once it occurs.\n	isReady: false,\n\n	// A counter to track how many items to wait for before\n	// the ready event fires. See #6781\n	readyWait: 1,\n\n	// Hold (or release) the ready event\n	holdReady: function( hold ) {\n		if ( hold ) {\n			jQuery.readyWait++;\n		} else {\n			jQuery.ready( true );\n		}\n	},\n\n	// Handle when the DOM is ready\n	ready: function( wait ) {\n\n		// Abort if there are pending holds or we\'re already ready\n		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n			return;\n		}\n\n		// Remember that the DOM is ready\n		jQuery.isReady = true;\n\n		// If a normal DOM Ready event fired, decrement, and wait if need be\n		if ( wait !== true && --jQuery.readyWait > 0 ) {\n			return;\n		}\n\n		// If there are functions bound, to execute\n		readyList.resolveWith( document, [ jQuery ] );\n\n		// Trigger any bound ready events\n		if ( jQuery.fn.triggerHandler ) {\n			jQuery( document ).triggerHandler( "ready" );\n			jQuery( document ).off( "ready" );\n		}\n	}\n} );\n\n/**\n * Clean-up method for dom ready events\n */\nfunction detach() {\n	if ( document.addEventListener ) {\n		document.removeEventListener( "DOMContentLoaded", completed );\n		window.removeEventListener( "load", completed );\n\n	} else {\n		document.detachEvent( "onreadystatechange", completed );\n		window.detachEvent( "onload", completed );\n	}\n}\n\n/**\n * The ready event handler and self cleanup method\n */\nfunction completed() {\n\n	// readyState === "complete" is good enough for us to call the dom ready in oldIE\n	if ( document.addEventListener ||\n		window.event.type === "load" ||\n		document.readyState === "complete" ) {\n\n		detach();\n		jQuery.ready();\n	}\n}\n\njQuery.ready.promise = function( obj ) {\n	if ( !readyList ) {\n\n		readyList = jQuery.Deferred();\n\n		// Catch cases where $(document).ready() is called\n		// after the browser event has already occurred.\n		// Support: IE6-10\n		// Older IE sometimes signals "interactive" too soon\n		if ( document.readyState === "complete" ||\n			( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {\n\n			// Handle it asynchronously to allow scripts the opportunity to delay ready\n			window.setTimeout( jQuery.ready );\n\n		// Standards-based browsers support DOMContentLoaded\n		} else if ( document.addEventListener ) {\n\n			// Use the handy event callback\n			document.addEventListener( "DOMContentLoaded", completed );\n\n			// A fallback to window.onload, that will always work\n			window.addEventListener( "load", completed );\n\n		// If IE event model is used\n		} else {\n\n			// Ensure firing before onload, maybe late but safe also for iframes\n			document.attachEvent( "onreadystatechange", completed );\n\n			// A fallback to window.onload, that will always work\n			window.attachEvent( "onload", completed );\n\n			// If IE and not a frame\n			// continually check to see if the document is ready\n			var top = false;\n\n			try {\n				top = window.frameElement == null && document.documentElement;\n			} catch ( e ) {}\n\n			if ( top && top.doScroll ) {\n				( function doScrollCheck() {\n					if ( !jQuery.isReady ) {\n\n						try {\n\n							// Use the trick by Diego Perini\n							// http://javascript.nwbox.com/IEContentLoaded/\n							top.doScroll( "left" );\n						} catch ( e ) {\n							return window.setTimeout( doScrollCheck, 50 );\n						}\n\n						// detach all dom ready events\n						detach();\n\n						// and execute any waiting functions\n						jQuery.ready();\n					}\n				} )();\n			}\n		}\n	}\n	return readyList.promise( obj );\n};\n\n// Kick off the DOM ready check even if the user does not\njQuery.ready.promise();\n\n\n\n\n// Support: IE<9\n// Iteration over object\'s inherited properties before its own\nvar i;\nfor ( i in jQuery( support ) ) {\n	break;\n}\nsupport.ownFirst = i === "0";\n\n// Note: most support tests are defined in their respective modules.\n// false until the test is run\nsupport.inlineBlockNeedsLayout = false;\n\n// Execute ASAP in case we need to set body.style.zoom\njQuery( function() {\n\n	// Minified: var a,b,c,d\n	var val, div, body, container;\n\n	body = document.getElementsByTagName( "body" )[ 0 ];\n	if ( !body || !body.style ) {\n\n		// Return for frameset docs that don\'t have a body\n		return;\n	}\n\n	// Setup\n	div = document.createElement( "div" );\n	container = document.createElement( "div" );\n	container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";\n	body.appendChild( container ).appendChild( div );\n\n	if ( typeof div.style.zoom !== "undefined" ) {\n\n		// Support: IE<8\n		// Check if natively block-level elements act like inline-block\n		// elements when setting their display to \'inline\' and giving\n		// them layout\n		div.style.cssText = "display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1";\n\n		support.inlineBlockNeedsLayout = val = div.offsetWidth === 3;\n		if ( val ) {\n\n			// Prevent IE 6 from affecting layout for positioned elements #11048\n			// Prevent IE from shrinking the body in IE 7 mode #12869\n			// Support: IE<8\n			body.style.zoom = 1;\n		}\n	}\n\n	body.removeChild( container );\n} );\n\n\n( function() {\n	var div = document.createElement( "div" );\n\n	// Support: IE<9\n	support.deleteExpando = true;\n	try {\n		delete div.test;\n	} catch ( e ) {\n		support.deleteExpando = false;\n	}\n\n	// Null elements to avoid leaks in IE.\n	div = null;\n} )();\nvar acceptData = function( elem ) {\n	var noData = jQuery.noData[ ( elem.nodeName + " " ).toLowerCase() ],\n		nodeType = +elem.nodeType || 1;\n\n	// Do not set data on non-element DOM nodes because it will not be cleared (#8335).\n	return nodeType !== 1 && nodeType !== 9 ?\n		false :\n\n		// Nodes accept data unless otherwise specified; rejection can be conditional\n		!noData || noData !== true && elem.getAttribute( "classid" ) === noData;\n};\n\n\n\n\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n	rmultiDash = /([A-Z])/g;\n\nfunction dataAttr( elem, key, data ) {\n\n	// If nothing was found internally, try to fetch any\n	// data from the HTML5 data-* attribute\n	if ( data === undefined && elem.nodeType === 1 ) {\n\n		var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();\n\n		data = elem.getAttribute( name );\n\n		if ( typeof data === "string" ) {\n			try {\n				data = data === "true" ? true :\n					data === "false" ? false :\n					data === "null" ? null :\n\n					// Only convert to a number if it doesn\'t change the string\n					+data + "" === data ? +data :\n					rbrace.test( data ) ? jQuery.parseJSON( data ) :\n					data;\n			} catch ( e ) {}\n\n			// Make sure we set the data so it isn\'t changed later\n			jQuery.data( elem, key, data );\n\n		} else {\n			data = undefined;\n		}\n	}\n\n	return data;\n}\n\n// checks a cache object for emptiness\nfunction isEmptyDataObject( obj ) {\n	var name;\n	for ( name in obj ) {\n\n		// if the public data object is empty, the private is still empty\n		if ( name === "data" && jQuery.isEmptyObject( obj[ name ] ) ) {\n			continue;\n		}\n		if ( name !== "toJSON" ) {\n			return false;\n		}\n	}\n\n	return true;\n}\n\nfunction internalData( elem, name, data, pvt /* Internal Use Only */ ) {\n	if ( !acceptData( elem ) ) {\n		return;\n	}\n\n	var ret, thisCache,\n		internalKey = jQuery.expando,\n\n		// We have to handle DOM nodes and JS objects differently because IE6-7\n		// can\'t GC object references properly across the DOM-JS boundary\n		isNode = elem.nodeType,\n\n		// Only DOM nodes need the global jQuery cache; JS object data is\n		// attached directly to the object so GC can occur automatically\n		cache = isNode ? jQuery.cache : elem,\n\n		// Only defining an ID for JS objects if its cache already exists allows\n		// the code to shortcut on the same path as a DOM node with no cache\n		id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;\n\n	// Avoid doing any more work than we need to when trying to get data on an\n	// object that has no data at all\n	if ( ( !id || !cache[ id ] || ( !pvt && !cache[ id ].data ) ) &&\n		data === undefined && typeof name === "string" ) {\n		return;\n	}\n\n	if ( !id ) {\n\n		// Only DOM nodes need a new unique ID for each element since their data\n		// ends up in the global cache\n		if ( isNode ) {\n			id = elem[ internalKey ] = deletedIds.pop() || jQuery.guid++;\n		} else {\n			id = internalKey;\n		}\n	}\n\n	if ( !cache[ id ] ) {\n\n		// Avoid exposing jQuery metadata on plain JS objects when the object\n		// is serialized using JSON.stringify\n		cache[ id ] = isNode ? {} : { toJSON: jQuery.noop };\n	}\n\n	// An object can be passed to jQuery.data instead of a key/value pair; this gets\n	// shallow copied over onto the existing cache\n	if ( typeof name === "object" || typeof name === "function" ) {\n		if ( pvt ) {\n			cache[ id ] = jQuery.extend( cache[ id ], name );\n		} else {\n			cache[ id ].data = jQuery.extend( cache[ id ].data, name );\n		}\n	}\n\n	thisCache = cache[ id ];\n\n	// jQuery data() is stored in a separate object inside the object\'s internal data\n	// cache in order to avoid key collisions between internal data and user-defined\n	// data.\n	if ( !pvt ) {\n		if ( !thisCache.data ) {\n			thisCache.data = {};\n		}\n\n		thisCache = thisCache.data;\n	}\n\n	if ( data !== undefined ) {\n		thisCache[ jQuery.camelCase( name ) ] = data;\n	}\n\n	// Check for both converted-to-camel and non-converted data property names\n	// If a data property was specified\n	if ( typeof name === "string" ) {\n\n		// First Try to find as-is property data\n		ret = thisCache[ name ];\n\n		// Test for null|undefined property data\n		if ( ret == null ) {\n\n			// Try to find the camelCased property\n			ret = thisCache[ jQuery.camelCase( name ) ];\n		}\n	} else {\n		ret = thisCache;\n	}\n\n	return ret;\n}\n\nfunction internalRemoveData( elem, name, pvt ) {\n	if ( !acceptData( elem ) ) {\n		return;\n	}\n\n	var thisCache, i,\n		isNode = elem.nodeType,\n\n		// See jQuery.data for more information\n		cache = isNode ? jQuery.cache : elem,\n		id = isNode ? elem[ jQuery.expando ] : jQuery.expando;\n\n	// If there is already no cache entry for this object, there is no\n	// purpose in continuing\n	if ( !cache[ id ] ) {\n		return;\n	}\n\n	if ( name ) {\n\n		thisCache = pvt ? cache[ id ] : cache[ id ].data;\n\n		if ( thisCache ) {\n\n			// Support array or space separated string names for data keys\n			if ( !jQuery.isArray( name ) ) {\n\n				// try the string as a key before any manipulation\n				if ( name in thisCache ) {\n					name = [ name ];\n				} else {\n\n					// split the camel cased version by spaces unless a key with the spaces exists\n					name = jQuery.camelCase( name );\n					if ( name in thisCache ) {\n						name = [ name ];\n					} else {\n						name = name.split( " " );\n					}\n				}\n			} else {\n\n				// If "name" is an array of keys...\n				// When data is initially created, via ("key", "val") signature,\n				// keys will be converted to camelCase.\n				// Since there is no way to tell _how_ a key was added, remove\n				// both plain key and camelCase key. #12786\n				// This will only penalize the array argument path.\n				name = name.concat( jQuery.map( name, jQuery.camelCase ) );\n			}\n\n			i = name.length;\n			while ( i-- ) {\n				delete thisCache[ name[ i ] ];\n			}\n\n			// If there is no data left in the cache, we want to continue\n			// and let the cache object itself get destroyed\n			if ( pvt ? !isEmptyDataObject( thisCache ) : !jQuery.isEmptyObject( thisCache ) ) {\n				return;\n			}\n		}\n	}\n\n	// See jQuery.data for more information\n	if ( !pvt ) {\n		delete cache[ id ].data;\n\n		// Don\'t destroy the parent cache unless the internal data object\n		// had been the only thing left in it\n		if ( !isEmptyDataObject( cache[ id ] ) ) {\n			return;\n		}\n	}\n\n	// Destroy the cache\n	if ( isNode ) {\n		jQuery.cleanData( [ elem ], true );\n\n	// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)\n	/* jshint eqeqeq: false */\n	} else if ( support.deleteExpando || cache != cache.window ) {\n		/* jshint eqeqeq: true */\n		delete cache[ id ];\n\n	// When all else fails, undefined\n	} else {\n		cache[ id ] = undefined;\n	}\n}\n\njQuery.extend( {\n	cache: {},\n\n	// The following elements (space-suffixed to avoid Object.prototype collisions)\n	// throw uncatchable exceptions if you attempt to set expando properties\n	noData: {\n		"applet ": true,\n		"embed ": true,\n\n		// ...but Flash objects (which have this classid) *can* handle expandos\n		"object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"\n	},\n\n	hasData: function( elem ) {\n		elem = elem.nodeType ? jQuery.cache[ elem[ jQuery.expando ] ] : elem[ jQuery.expando ];\n		return !!elem && !isEmptyDataObject( elem );\n	},\n\n	data: function( elem, name, data ) {\n		return internalData( elem, name, data );\n	},\n\n	removeData: function( elem, name ) {\n		return internalRemoveData( elem, name );\n	},\n\n	// For internal use only.\n	_data: function( elem, name, data ) {\n		return internalData( elem, name, data, true );\n	},\n\n	_removeData: function( elem, name ) {\n		return internalRemoveData( elem, name, true );\n	}\n} );\n\njQuery.fn.extend( {\n	data: function( key, value ) {\n		var i, name, data,\n			elem = this[ 0 ],\n			attrs = elem && elem.attributes;\n\n		// Special expections of .data basically thwart jQuery.access,\n		// so implement the relevant behavior ourselves\n\n		// Gets all values\n		if ( key === undefined ) {\n			if ( this.length ) {\n				data = jQuery.data( elem );\n\n				if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {\n					i = attrs.length;\n					while ( i-- ) {\n\n						// Support: IE11+\n						// The attrs elements can be null (#14894)\n						if ( attrs[ i ] ) {\n							name = attrs[ i ].name;\n							if ( name.indexOf( "data-" ) === 0 ) {\n								name = jQuery.camelCase( name.slice( 5 ) );\n								dataAttr( elem, name, data[ name ] );\n							}\n						}\n					}\n					jQuery._data( elem, "parsedAttrs", true );\n				}\n			}\n\n			return data;\n		}\n\n		// Sets multiple values\n		if ( typeof key === "object" ) {\n			return this.each( function() {\n				jQuery.data( this, key );\n			} );\n		}\n\n		return arguments.length > 1 ?\n\n			// Sets one value\n			this.each( function() {\n				jQuery.data( this, key, value );\n			} ) :\n\n			// Gets one value\n			// Try to fetch any internally stored data first\n			elem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : undefined;\n	},\n\n	removeData: function( key ) {\n		return this.each( function() {\n			jQuery.removeData( this, key );\n		} );\n	}\n} );\n\n\njQuery.extend( {\n	queue: function( elem, type, data ) {\n		var queue;\n\n		if ( elem ) {\n			type = ( type || "fx" ) + "queue";\n			queue = jQuery._data( elem, type );\n\n			// Speed up dequeue by getting out quickly if this is just a lookup\n			if ( data ) {\n				if ( !queue || jQuery.isArray( data ) ) {\n					queue = jQuery._data( elem, type, jQuery.makeArray( data ) );\n				} else {\n					queue.push( data );\n				}\n			}\n			return queue || [];\n		}\n	},\n\n	dequeue: function( elem, type ) {\n		type = type || "fx";\n\n		var queue = jQuery.queue( elem, type ),\n			startLength = queue.length,\n			fn = queue.shift(),\n			hooks = jQuery._queueHooks( elem, type ),\n			next = function() {\n				jQuery.dequeue( elem, type );\n			};\n\n		// If the fx queue is dequeued, always remove the progress sentinel\n		if ( fn === "inprogress" ) {\n			fn = queue.shift();\n			startLength--;\n		}\n\n		if ( fn ) {\n\n			// Add a progress sentinel to prevent the fx queue from being\n			// automatically dequeued\n			if ( type === "fx" ) {\n				queue.unshift( "inprogress" );\n			}\n\n			// clear up the last queue stop function\n			delete hooks.stop;\n			fn.call( elem, next, hooks );\n		}\n\n		if ( !startLength && hooks ) {\n			hooks.empty.fire();\n		}\n	},\n\n	// not intended for public consumption - generates a queueHooks object,\n	// or returns the current one\n	_queueHooks: function( elem, type ) {\n		var key = type + "queueHooks";\n		return jQuery._data( elem, key ) || jQuery._data( elem, key, {\n			empty: jQuery.Callbacks( "once memory" ).add( function() {\n				jQuery._removeData( elem, type + "queue" );\n				jQuery._removeData( elem, key );\n			} )\n		} );\n	}\n} );\n\njQuery.fn.extend( {\n	queue: function( type, data ) {\n		var setter = 2;\n\n		if ( typeof type !== "string" ) {\n			data = type;\n			type = "fx";\n			setter--;\n		}\n\n		if ( arguments.length < setter ) {\n			return jQuery.queue( this[ 0 ], type );\n		}\n\n		return data === undefined ?\n			this :\n			this.each( function() {\n				var queue = jQuery.queue( this, type, data );\n\n				// ensure a hooks for this queue\n				jQuery._queueHooks( this, type );\n\n				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {\n					jQuery.dequeue( this, type );\n				}\n			} );\n	},\n	dequeue: function( type ) {\n		return this.each( function() {\n			jQuery.dequeue( this, type );\n		} );\n	},\n	clearQueue: function( type ) {\n		return this.queue( type || "fx", [] );\n	},\n\n	// Get a promise resolved when queues of a certain type\n	// are emptied (fx is the type by default)\n	promise: function( type, obj ) {\n		var tmp,\n			count = 1,\n			defer = jQuery.Deferred(),\n			elements = this,\n			i = this.length,\n			resolve = function() {\n				if ( !( --count ) ) {\n					defer.resolveWith( elements, [ elements ] );\n				}\n			};\n\n		if ( typeof type !== "string" ) {\n			obj = type;\n			type = undefined;\n		}\n		type = type || "fx";\n\n		while ( i-- ) {\n			tmp = jQuery._data( elements[ i ], type + "queueHooks" );\n			if ( tmp && tmp.empty ) {\n				count++;\n				tmp.empty.add( resolve );\n			}\n		}\n		resolve();\n		return defer.promise( obj );\n	}\n} );\n\n\n( function() {\n	var shrinkWrapBlocksVal;\n\n	support.shrinkWrapBlocks = function() {\n		if ( shrinkWrapBlocksVal != null ) {\n			return shrinkWrapBlocksVal;\n		}\n\n		// Will be changed later if needed.\n		shrinkWrapBlocksVal = false;\n\n		// Minified: var b,c,d\n		var div, body, container;\n\n		body = document.getElementsByTagName( "body" )[ 0 ];\n		if ( !body || !body.style ) {\n\n			// Test fired too early or in an unsupported environment, exit.\n			return;\n		}\n\n		// Setup\n		div = document.createElement( "div" );\n		container = document.createElement( "div" );\n		container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";\n		body.appendChild( container ).appendChild( div );\n\n		// Support: IE6\n		// Check if elements with layout shrink-wrap their children\n		if ( typeof div.style.zoom !== "undefined" ) {\n\n			// Reset CSS: box-sizing; display; margin; border\n			div.style.cssText =\n\n				// Support: Firefox<29, Android 2.3\n				// Vendor-prefix box-sizing\n				"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +\n				"box-sizing:content-box;display:block;margin:0;border:0;" +\n				"padding:1px;width:1px;zoom:1";\n			div.appendChild( document.createElement( "div" ) ).style.width = "5px";\n			shrinkWrapBlocksVal = div.offsetWidth !== 3;\n		}\n\n		body.removeChild( container );\n\n		return shrinkWrapBlocksVal;\n	};\n\n} )();\nvar pnum = ( /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/ ).source;\n\nvar rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );\n\n\nvar cssExpand = [ "Top", "Right", "Bottom", "Left" ];\n\nvar isHidden = function( elem, el ) {\n\n		// isHidden might be called from jQuery#filter function;\n		// in that case, element will be second argument\n		elem = el || elem;\n		return jQuery.css( elem, "display" ) === "none" ||\n			!jQuery.contains( elem.ownerDocument, elem );\n	};\n\n\n\nfunction adjustCSS( elem, prop, valueParts, tween ) {\n	var adjusted,\n		scale = 1,\n		maxIterations = 20,\n		currentValue = tween ?\n			function() { return tween.cur(); } :\n			function() { return jQuery.css( elem, prop, "" ); },\n		initial = currentValue(),\n		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),\n\n		// Starting value computation is required for potential unit mismatches\n		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&\n			rcssNum.exec( jQuery.css( elem, prop ) );\n\n	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\n\n		// Trust units reported by jQuery.css\n		unit = unit || initialInUnit[ 3 ];\n\n		// Make sure we update the tween properties later on\n		valueParts = valueParts || [];\n\n		// Iteratively approximate from a nonzero starting point\n		initialInUnit = +initial || 1;\n\n		do {\n\n			// If previous iteration zeroed out, double until we get *something*.\n			// Use string for doubling so we don\'t accidentally see scale as unchanged below\n			scale = scale || ".5";\n\n			// Adjust and apply\n			initialInUnit = initialInUnit / scale;\n			jQuery.style( elem, prop, initialInUnit + unit );\n\n		// Update scale, tolerating zero or NaN from tween.cur()\n		// Break the loop if scale is unchanged or perfect, or if we\'ve just had enough.\n		} while (\n			scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations\n		);\n	}\n\n	if ( valueParts ) {\n		initialInUnit = +initialInUnit || +initial || 0;\n\n		// Apply relative offset (+=/-=) if specified\n		adjusted = valueParts[ 1 ] ?\n			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\n			+valueParts[ 2 ];\n		if ( tween ) {\n			tween.unit = unit;\n			tween.start = initialInUnit;\n			tween.end = adjusted;\n		}\n	}\n	return adjusted;\n}\n\n\n// Multifunctional method to get and set values of a collection\n// The value/s can optionally be executed if it\'s a function\nvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n	var i = 0,\n		length = elems.length,\n		bulk = key == null;\n\n	// Sets many values\n	if ( jQuery.type( key ) === "object" ) {\n		chainable = true;\n		for ( i in key ) {\n			access( elems, fn, i, key[ i ], true, emptyGet, raw );\n		}\n\n	// Sets one value\n	} else if ( value !== undefined ) {\n		chainable = true;\n\n		if ( !jQuery.isFunction( value ) ) {\n			raw = true;\n		}\n\n		if ( bulk ) {\n\n			// Bulk operations run against the entire set\n			if ( raw ) {\n				fn.call( elems, value );\n				fn = null;\n\n			// ...except when executing function values\n			} else {\n				bulk = fn;\n				fn = function( elem, key, value ) {\n					return bulk.call( jQuery( elem ), value );\n				};\n			}\n		}\n\n		if ( fn ) {\n			for ( ; i < length; i++ ) {\n				fn(\n					elems[ i ],\n					key,\n					raw ? value : value.call( elems[ i ], i, fn( elems[ i ], key ) )\n				);\n			}\n		}\n	}\n\n	return chainable ?\n		elems :\n\n		// Gets\n		bulk ?\n			fn.call( elems ) :\n			length ? fn( elems[ 0 ], key ) : emptyGet;\n};\nvar rcheckableType = ( /^(?:checkbox|radio)$/i );\n\nvar rtagName = ( /<([\\w:-]+)/ );\n\nvar rscriptType = ( /^$|\\/(?:java|ecma)script/i );\n\nvar rleadingWhitespace = ( /^\\s+/ );\n\nvar nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|" +\n		"details|dialog|figcaption|figure|footer|header|hgroup|main|" +\n		"mark|meter|nav|output|picture|progress|section|summary|template|time|video";\n\n\n\nfunction createSafeFragment( document ) {\n	var list = nodeNames.split( "|" ),\n		safeFrag = document.createDocumentFragment();\n\n	if ( safeFrag.createElement ) {\n		while ( list.length ) {\n			safeFrag.createElement(\n				list.pop()\n			);\n		}\n	}\n	return safeFrag;\n}\n\n\n( function() {\n	var div = document.createElement( "div" ),\n		fragment = document.createDocumentFragment(),\n		input = document.createElement( "input" );\n\n	// Setup\n	div.innerHTML = "  <link/><table></table><a href=\'/a\'>a</a><input type=\'checkbox\'/>";\n\n	// IE strips leading whitespace when .innerHTML is used\n	support.leadingWhitespace = div.firstChild.nodeType === 3;\n\n	// Make sure that tbody elements aren\'t automatically inserted\n	// IE will insert them into empty tables\n	support.tbody = !div.getElementsByTagName( "tbody" ).length;\n\n	// Make sure that link elements get serialized correctly by innerHTML\n	// This requires a wrapper element in IE\n	support.htmlSerialize = !!div.getElementsByTagName( "link" ).length;\n\n	// Makes sure cloning an html5 element does not cause problems\n	// Where outerHTML is undefined, this still works\n	support.html5Clone =\n		document.createElement( "nav" ).cloneNode( true ).outerHTML !== "<:nav></:nav>";\n\n	// Check if a disconnected checkbox will retain its checked\n	// value of true after appended to the DOM (IE6/7)\n	input.type = "checkbox";\n	input.checked = true;\n	fragment.appendChild( input );\n	support.appendChecked = input.checked;\n\n	// Make sure textarea (and checkbox) defaultValue is properly cloned\n	// Support: IE6-IE11+\n	div.innerHTML = "<textarea>x</textarea>";\n	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n\n	// #11217 - WebKit loses check when the name is after the checked attribute\n	fragment.appendChild( div );\n\n	// Support: Windows Web Apps (WWA)\n	// `name` and `type` must use .setAttribute for WWA (#14901)\n	input = document.createElement( "input" );\n	input.setAttribute( "type", "radio" );\n	input.setAttribute( "checked", "checked" );\n	input.setAttribute( "name", "t" );\n\n	div.appendChild( input );\n\n	// Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3\n	// old WebKit doesn\'t clone checked state correctly in fragments\n	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n	// Support: IE<9\n	// Cloned elements keep attachEvent handlers, we use addEventListener on IE9+\n	support.noCloneEvent = !!div.addEventListener;\n\n	// Support: IE<9\n	// Since attributes and properties are the same in IE,\n	// cleanData must set properties to undefined rather than use removeAttribute\n	div[ jQuery.expando ] = 1;\n	support.attributes = !div.getAttribute( jQuery.expando );\n} )();\n\n\n// We have to close these tags to support XHTML (#13200)\nvar wrapMap = {\n	option: [ 1, "<select multiple=\'multiple\'>", "</select>" ],\n	legend: [ 1, "<fieldset>", "</fieldset>" ],\n	area: [ 1, "<map>", "</map>" ],\n\n	// Support: IE8\n	param: [ 1, "<object>", "</object>" ],\n	thead: [ 1, "<table>", "</table>" ],\n	tr: [ 2, "<table><tbody>", "</tbody></table>" ],\n	col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],\n	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],\n\n	// IE6-8 can\'t serialize link, script, style, or any html5 (NoScope) tags,\n	// unless wrapped in a div with non-breaking characters in front of it.\n	_default: support.htmlSerialize ? [ 0, "", "" ] : [ 1, "X<div>", "</div>" ]\n};\n\n// Support: IE8-IE9\nwrapMap.optgroup = wrapMap.option;\n\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n\nfunction getAll( context, tag ) {\n	var elems, elem,\n		i = 0,\n		found = typeof context.getElementsByTagName !== "undefined" ?\n			context.getElementsByTagName( tag || "*" ) :\n			typeof context.querySelectorAll !== "undefined" ?\n				context.querySelectorAll( tag || "*" ) :\n				undefined;\n\n	if ( !found ) {\n		for ( found = [], elems = context.childNodes || context;\n			( elem = elems[ i ] ) != null;\n			i++\n		) {\n			if ( !tag || jQuery.nodeName( elem, tag ) ) {\n				found.push( elem );\n			} else {\n				jQuery.merge( found, getAll( elem, tag ) );\n			}\n		}\n	}\n\n	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?\n		jQuery.merge( [ context ], found ) :\n		found;\n}\n\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n	var elem,\n		i = 0;\n	for ( ; ( elem = elems[ i ] ) != null; i++ ) {\n		jQuery._data(\n			elem,\n			"globalEval",\n			!refElements || jQuery._data( refElements[ i ], "globalEval" )\n		);\n	}\n}\n\n\nvar rhtml = /<|&#?\\w+;/,\n	rtbody = /<tbody/i;\n\nfunction fixDefaultChecked( elem ) {\n	if ( rcheckableType.test( elem.type ) ) {\n		elem.defaultChecked = elem.checked;\n	}\n}\n\nfunction buildFragment( elems, context, scripts, selection, ignored ) {\n	var j, elem, contains,\n		tmp, tag, tbody, wrap,\n		l = elems.length,\n\n		// Ensure a safe fragment\n		safe = createSafeFragment( context ),\n\n		nodes = [],\n		i = 0;\n\n	for ( ; i < l; i++ ) {\n		elem = elems[ i ];\n\n		if ( elem || elem === 0 ) {\n\n			// Add nodes directly\n			if ( jQuery.type( elem ) === "object" ) {\n				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n			// Convert non-html into a text node\n			} else if ( !rhtml.test( elem ) ) {\n				nodes.push( context.createTextNode( elem ) );\n\n			// Convert html into DOM nodes\n			} else {\n				tmp = tmp || safe.appendChild( context.createElement( "div" ) );\n\n				// Deserialize a standard representation\n				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();\n				wrap = wrapMap[ tag ] || wrapMap._default;\n\n				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\n\n				// Descend through wrappers to the right content\n				j = wrap[ 0 ];\n				while ( j-- ) {\n					tmp = tmp.lastChild;\n				}\n\n				// Manually add leading whitespace removed by IE\n				if ( !support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {\n					nodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[ 0 ] ) );\n				}\n\n				// Remove IE\'s autoinserted <tbody> from table fragments\n				if ( !support.tbody ) {\n\n					// String was a <table>, *may* have spurious <tbody>\n					elem = tag === "table" && !rtbody.test( elem ) ?\n						tmp.firstChild :\n\n						// String was a bare <thead> or <tfoot>\n						wrap[ 1 ] === "<table>" && !rtbody.test( elem ) ?\n							tmp :\n							0;\n\n					j = elem && elem.childNodes.length;\n					while ( j-- ) {\n						if ( jQuery.nodeName( ( tbody = elem.childNodes[ j ] ), "tbody" ) &&\n							!tbody.childNodes.length ) {\n\n							elem.removeChild( tbody );\n						}\n					}\n				}\n\n				jQuery.merge( nodes, tmp.childNodes );\n\n				// Fix #12392 for WebKit and IE > 9\n				tmp.textContent = "";\n\n				// Fix #12392 for oldIE\n				while ( tmp.firstChild ) {\n					tmp.removeChild( tmp.firstChild );\n				}\n\n				// Remember the top-level container for proper cleanup\n				tmp = safe.lastChild;\n			}\n		}\n	}\n\n	// Fix #11356: Clear elements from fragment\n	if ( tmp ) {\n		safe.removeChild( tmp );\n	}\n\n	// Reset defaultChecked for any radios and checkboxes\n	// about to be appended to the DOM in IE 6/7 (#8060)\n	if ( !support.appendChecked ) {\n		jQuery.grep( getAll( nodes, "input" ), fixDefaultChecked );\n	}\n\n	i = 0;\n	while ( ( elem = nodes[ i++ ] ) ) {\n\n		// Skip elements already in the context collection (trac-4087)\n		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {\n			if ( ignored ) {\n				ignored.push( elem );\n			}\n\n			continue;\n		}\n\n		contains = jQuery.contains( elem.ownerDocument, elem );\n\n		// Append to fragment\n		tmp = getAll( safe.appendChild( elem ), "script" );\n\n		// Preserve script evaluation history\n		if ( contains ) {\n			setGlobalEval( tmp );\n		}\n\n		// Capture executables\n		if ( scripts ) {\n			j = 0;\n			while ( ( elem = tmp[ j++ ] ) ) {\n				if ( rscriptType.test( elem.type || "" ) ) {\n					scripts.push( elem );\n				}\n			}\n		}\n	}\n\n	tmp = null;\n\n	return safe;\n}\n\n\n( function() {\n	var i, eventName,\n		div = document.createElement( "div" );\n\n	// Support: IE<9 (lack submit/change bubble), Firefox (lack focus(in | out) events)\n	for ( i in { submit: true, change: true, focusin: true } ) {\n		eventName = "on" + i;\n\n		if ( !( support[ i ] = eventName in window ) ) {\n\n			// Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)\n			div.setAttribute( eventName, "t" );\n			support[ i ] = div.attributes[ eventName ].expando === false;\n		}\n	}\n\n	// Null elements to avoid leaks in IE.\n	div = null;\n} )();\n\n\nvar rformElems = /^(?:input|select|textarea)$/i,\n	rkeyEvent = /^key/,\n	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n	rtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\nfunction returnTrue() {\n	return true;\n}\n\nfunction returnFalse() {\n	return false;\n}\n\n// Support: IE9\n// See #13393 for more info\nfunction safeActiveElement() {\n	try {\n		return document.activeElement;\n	} catch ( err ) { }\n}\n\nfunction on( elem, types, selector, data, fn, one ) {\n	var origFn, type;\n\n	// Types can be a map of types/handlers\n	if ( typeof types === "object" ) {\n\n		// ( types-Object, selector, data )\n		if ( typeof selector !== "string" ) {\n\n			// ( types-Object, data )\n			data = data || selector;\n			selector = undefined;\n		}\n		for ( type in types ) {\n			on( elem, type, selector, data, types[ type ], one );\n		}\n		return elem;\n	}\n\n	if ( data == null && fn == null ) {\n\n		// ( types, fn )\n		fn = selector;\n		data = selector = undefined;\n	} else if ( fn == null ) {\n		if ( typeof selector === "string" ) {\n\n			// ( types, selector, fn )\n			fn = data;\n			data = undefined;\n		} else {\n\n			// ( types, data, fn )\n			fn = data;\n			data = selector;\n			selector = undefined;\n		}\n	}\n	if ( fn === false ) {\n		fn = returnFalse;\n	} else if ( !fn ) {\n		return elem;\n	}\n\n	if ( one === 1 ) {\n		origFn = fn;\n		fn = function( event ) {\n\n			// Can use an empty set, since event contains the info\n			jQuery().off( event );\n			return origFn.apply( this, arguments );\n		};\n\n		// Use same guid so caller can remove using origFn\n		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n	}\n	return elem.each( function() {\n		jQuery.event.add( this, types, fn, data, selector );\n	} );\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards\' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n	global: {},\n\n	add: function( elem, types, handler, data, selector ) {\n		var tmp, events, t, handleObjIn,\n			special, eventHandle, handleObj,\n			handlers, type, namespaces, origType,\n			elemData = jQuery._data( elem );\n\n		// Don\'t attach events to noData or text/comment nodes (but allow plain objects)\n		if ( !elemData ) {\n			return;\n		}\n\n		// Caller can pass in an object of custom data in lieu of the handler\n		if ( handler.handler ) {\n			handleObjIn = handler;\n			handler = handleObjIn.handler;\n			selector = handleObjIn.selector;\n		}\n\n		// Make sure that the handler has a unique ID, used to find/remove it later\n		if ( !handler.guid ) {\n			handler.guid = jQuery.guid++;\n		}\n\n		// Init the element\'s event structure and main handler, if this is the first\n		if ( !( events = elemData.events ) ) {\n			events = elemData.events = {};\n		}\n		if ( !( eventHandle = elemData.handle ) ) {\n			eventHandle = elemData.handle = function( e ) {\n\n				// Discard the second event of a jQuery.event.trigger() and\n				// when an event is called after a page has unloaded\n				return typeof jQuery !== "undefined" &&\n					( !e || jQuery.event.triggered !== e.type ) ?\n					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :\n					undefined;\n			};\n\n			// Add elem as a property of the handle fn to prevent a memory leak\n			// with IE non-native events\n			eventHandle.elem = elem;\n		}\n\n		// Handle multiple events separated by a space\n		types = ( types || "" ).match( rnotwhite ) || [ "" ];\n		t = types.length;\n		while ( t-- ) {\n			tmp = rtypenamespace.exec( types[ t ] ) || [];\n			type = origType = tmp[ 1 ];\n			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();\n\n			// There *must* be a type, no attaching namespace-only handlers\n			if ( !type ) {\n				continue;\n			}\n\n			// If event changes its type, use the special event handlers for the changed type\n			special = jQuery.event.special[ type ] || {};\n\n			// If selector defined, determine special event api type, otherwise given type\n			type = ( selector ? special.delegateType : special.bindType ) || type;\n\n			// Update special based on newly reset type\n			special = jQuery.event.special[ type ] || {};\n\n			// handleObj is passed to all event handlers\n			handleObj = jQuery.extend( {\n				type: type,\n				origType: origType,\n				data: data,\n				handler: handler,\n				guid: handler.guid,\n				selector: selector,\n				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n				namespace: namespaces.join( "." )\n			}, handleObjIn );\n\n			// Init the event handler queue if we\'re the first\n			if ( !( handlers = events[ type ] ) ) {\n				handlers = events[ type ] = [];\n				handlers.delegateCount = 0;\n\n				// Only use addEventListener/attachEvent if the special events handler returns false\n				if ( !special.setup ||\n					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\n					// Bind the global event handler to the element\n					if ( elem.addEventListener ) {\n						elem.addEventListener( type, eventHandle, false );\n\n					} else if ( elem.attachEvent ) {\n						elem.attachEvent( "on" + type, eventHandle );\n					}\n				}\n			}\n\n			if ( special.add ) {\n				special.add.call( elem, handleObj );\n\n				if ( !handleObj.handler.guid ) {\n					handleObj.handler.guid = handler.guid;\n				}\n			}\n\n			// Add to the element\'s handler list, delegates in front\n			if ( selector ) {\n				handlers.splice( handlers.delegateCount++, 0, handleObj );\n			} else {\n				handlers.push( handleObj );\n			}\n\n			// Keep track of which events have ever been used, for event optimization\n			jQuery.event.global[ type ] = true;\n		}\n\n		// Nullify elem to prevent memory leaks in IE\n		elem = null;\n	},\n\n	// Detach an event or set of events from an element\n	remove: function( elem, types, handler, selector, mappedTypes ) {\n		var j, handleObj, tmp,\n			origCount, t, events,\n			special, handlers, type,\n			namespaces, origType,\n			elemData = jQuery.hasData( elem ) && jQuery._data( elem );\n\n		if ( !elemData || !( events = elemData.events ) ) {\n			return;\n		}\n\n		// Once for each type.namespace in types; type may be omitted\n		types = ( types || "" ).match( rnotwhite ) || [ "" ];\n		t = types.length;\n		while ( t-- ) {\n			tmp = rtypenamespace.exec( types[ t ] ) || [];\n			type = origType = tmp[ 1 ];\n			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();\n\n			// Unbind all events (on this namespace, if provided) for the element\n			if ( !type ) {\n				for ( type in events ) {\n					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n				}\n				continue;\n			}\n\n			special = jQuery.event.special[ type ] || {};\n			type = ( selector ? special.delegateType : special.bindType ) || type;\n			handlers = events[ type ] || [];\n			tmp = tmp[ 2 ] &&\n				new RegExp( "(^|\\\\.)" + namespaces.join( "\\\\.(?:.*\\\\.|)" ) + "(\\\\.|$)" );\n\n			// Remove matching events\n			origCount = j = handlers.length;\n			while ( j-- ) {\n				handleObj = handlers[ j ];\n\n				if ( ( mappedTypes || origType === handleObj.origType ) &&\n					( !handler || handler.guid === handleObj.guid ) &&\n					( !tmp || tmp.test( handleObj.namespace ) ) &&\n					( !selector || selector === handleObj.selector ||\n						selector === "**" && handleObj.selector ) ) {\n					handlers.splice( j, 1 );\n\n					if ( handleObj.selector ) {\n						handlers.delegateCount--;\n					}\n					if ( special.remove ) {\n						special.remove.call( elem, handleObj );\n					}\n				}\n			}\n\n			// Remove generic event handler if we removed something and no more handlers exist\n			// (avoids potential for endless recursion during removal of special event handlers)\n			if ( origCount && !handlers.length ) {\n				if ( !special.teardown ||\n					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\n					jQuery.removeEvent( elem, type, elemData.handle );\n				}\n\n				delete events[ type ];\n			}\n		}\n\n		// Remove the expando if it\'s no longer used\n		if ( jQuery.isEmptyObject( events ) ) {\n			delete elemData.handle;\n\n			// removeData also checks for emptiness and clears the expando if empty\n			// so use it instead of delete\n			jQuery._removeData( elem, "events" );\n		}\n	},\n\n	trigger: function( event, data, elem, onlyHandlers ) {\n		var handle, ontype, cur,\n			bubbleType, special, tmp, i,\n			eventPath = [ elem || document ],\n			type = hasOwn.call( event, "type" ) ? event.type : event,\n			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];\n\n		cur = tmp = elem = elem || document;\n\n		// Don\'t do events on text and comment nodes\n		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n			return;\n		}\n\n		// focus/blur morphs to focusin/out; ensure we\'re not firing them right now\n		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n			return;\n		}\n\n		if ( type.indexOf( "." ) > -1 ) {\n\n			// Namespaced trigger; create a regexp to match event type in handle()\n			namespaces = type.split( "." );\n			type = namespaces.shift();\n			namespaces.sort();\n		}\n		ontype = type.indexOf( ":" ) < 0 && "on" + type;\n\n		// Caller can pass in a jQuery.Event object, Object, or just an event type string\n		event = event[ jQuery.expando ] ?\n			event :\n			new jQuery.Event( type, typeof event === "object" && event );\n\n		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n		event.isTrigger = onlyHandlers ? 2 : 3;\n		event.namespace = namespaces.join( "." );\n		event.rnamespace = event.namespace ?\n			new RegExp( "(^|\\\\.)" + namespaces.join( "\\\\.(?:.*\\\\.|)" ) + "(\\\\.|$)" ) :\n			null;\n\n		// Clean up the event in case it is being reused\n		event.result = undefined;\n		if ( !event.target ) {\n			event.target = elem;\n		}\n\n		// Clone any incoming data and prepend the event, creating the handler arg list\n		data = data == null ?\n			[ event ] :\n			jQuery.makeArray( data, [ event ] );\n\n		// Allow special events to draw outside the lines\n		special = jQuery.event.special[ type ] || {};\n		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n			return;\n		}\n\n		// Determine event propagation path in advance, per W3C events spec (#9951)\n		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\n			bubbleType = special.delegateType || type;\n			if ( !rfocusMorph.test( bubbleType + type ) ) {\n				cur = cur.parentNode;\n			}\n			for ( ; cur; cur = cur.parentNode ) {\n				eventPath.push( cur );\n				tmp = cur;\n			}\n\n			// Only add window if we got to document (e.g., not plain obj or detached DOM)\n			if ( tmp === ( elem.ownerDocument || document ) ) {\n				eventPath.push( tmp.defaultView || tmp.parentWindow || window );\n			}\n		}\n\n		// Fire handlers on the event path\n		i = 0;\n		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\n\n			event.type = i > 1 ?\n				bubbleType :\n				special.bindType || type;\n\n			// jQuery handler\n			handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] &&\n				jQuery._data( cur, "handle" );\n\n			if ( handle ) {\n				handle.apply( cur, data );\n			}\n\n			// Native handler\n			handle = ontype && cur[ ontype ];\n			if ( handle && handle.apply && acceptData( cur ) ) {\n				event.result = handle.apply( cur, data );\n				if ( event.result === false ) {\n					event.preventDefault();\n				}\n			}\n		}\n		event.type = type;\n\n		// If nobody prevented the default action, do it now\n		if ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n			if (\n				( !special._default ||\n				 special._default.apply( eventPath.pop(), data ) === false\n				) && acceptData( elem )\n			) {\n\n				// Call a native DOM method on the target with the same name name as the event.\n				// Can\'t use an .isFunction() check here because IE6/7 fails that test.\n				// Don\'t do default actions on window, that\'s where global variables be (#6170)\n				if ( ontype && elem[ type ] && !jQuery.isWindow( elem ) ) {\n\n					// Don\'t re-trigger an onFOO event when we call its FOO() method\n					tmp = elem[ ontype ];\n\n					if ( tmp ) {\n						elem[ ontype ] = null;\n					}\n\n					// Prevent re-triggering of the same event, since we already bubbled it above\n					jQuery.event.triggered = type;\n					try {\n						elem[ type ]();\n					} catch ( e ) {\n\n						// IE<9 dies on focus/blur to hidden element (#1486,#12518)\n						// only reproducible on winXP IE8 native, not IE9 in IE8 mode\n					}\n					jQuery.event.triggered = undefined;\n\n					if ( tmp ) {\n						elem[ ontype ] = tmp;\n					}\n				}\n			}\n		}\n\n		return event.result;\n	},\n\n	dispatch: function( event ) {\n\n		// Make a writable jQuery.Event from the native event object\n		event = jQuery.event.fix( event );\n\n		var i, j, ret, matched, handleObj,\n			handlerQueue = [],\n			args = slice.call( arguments ),\n			handlers = ( jQuery._data( this, "events" ) || {} )[ event.type ] || [],\n			special = jQuery.event.special[ event.type ] || {};\n\n		// Use the fix-ed jQuery.Event rather than the (read-only) native event\n		args[ 0 ] = event;\n		event.delegateTarget = this;\n\n		// Call the preDispatch hook for the mapped type, and let it bail if desired\n		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n			return;\n		}\n\n		// Determine handlers\n		handlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n		// Run delegates first; they may want to stop propagation beneath us\n		i = 0;\n		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\n			event.currentTarget = matched.elem;\n\n			j = 0;\n			while ( ( handleObj = matched.handlers[ j++ ] ) &&\n				!event.isImmediatePropagationStopped() ) {\n\n				// Triggered event must either 1) have no namespace, or 2) have namespace(s)\n				// a subset or equal to those in the bound event (both can have no namespace).\n				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {\n\n					event.handleObj = handleObj;\n					event.data = handleObj.data;\n\n					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\n						handleObj.handler ).apply( matched.elem, args );\n\n					if ( ret !== undefined ) {\n						if ( ( event.result = ret ) === false ) {\n							event.preventDefault();\n							event.stopPropagation();\n						}\n					}\n				}\n			}\n		}\n\n		// Call the postDispatch hook for the mapped type\n		if ( special.postDispatch ) {\n			special.postDispatch.call( this, event );\n		}\n\n		return event.result;\n	},\n\n	handlers: function( event, handlers ) {\n		var i, matches, sel, handleObj,\n			handlerQueue = [],\n			delegateCount = handlers.delegateCount,\n			cur = event.target;\n\n		// Support (at least): Chrome, IE9\n		// Find delegate handlers\n		// Black-hole SVG <use> instance trees (#13180)\n		//\n		// Support: Firefox<=42+\n		// Avoid non-left-click in FF but don\'t block IE radio events (#3861, gh-2343)\n		if ( delegateCount && cur.nodeType &&\n			( event.type !== "click" || isNaN( event.button ) || event.button < 1 ) ) {\n\n			/* jshint eqeqeq: false */\n			for ( ; cur != this; cur = cur.parentNode || this ) {\n				/* jshint eqeqeq: true */\n\n				// Don\'t check non-elements (#13208)\n				// Don\'t process clicks on disabled elements (#6911, #8165, #11382, #11764)\n				if ( cur.nodeType === 1 && ( cur.disabled !== true || event.type !== "click" ) ) {\n					matches = [];\n					for ( i = 0; i < delegateCount; i++ ) {\n						handleObj = handlers[ i ];\n\n						// Don\'t conflict with Object.prototype properties (#13203)\n						sel = handleObj.selector + " ";\n\n						if ( matches[ sel ] === undefined ) {\n							matches[ sel ] = handleObj.needsContext ?\n								jQuery( sel, this ).index( cur ) > -1 :\n								jQuery.find( sel, this, null, [ cur ] ).length;\n						}\n						if ( matches[ sel ] ) {\n							matches.push( handleObj );\n						}\n					}\n					if ( matches.length ) {\n						handlerQueue.push( { elem: cur, handlers: matches } );\n					}\n				}\n			}\n		}\n\n		// Add the remaining (directly-bound) handlers\n		if ( delegateCount < handlers.length ) {\n			handlerQueue.push( { elem: this, handlers: handlers.slice( delegateCount ) } );\n		}\n\n		return handlerQueue;\n	},\n\n	fix: function( event ) {\n		if ( event[ jQuery.expando ] ) {\n			return event;\n		}\n\n		// Create a writable copy of the event object and normalize some properties\n		var i, prop, copy,\n			type = event.type,\n			originalEvent = event,\n			fixHook = this.fixHooks[ type ];\n\n		if ( !fixHook ) {\n			this.fixHooks[ type ] = fixHook =\n				rmouseEvent.test( type ) ? this.mouseHooks :\n				rkeyEvent.test( type ) ? this.keyHooks :\n				{};\n		}\n		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;\n\n		event = new jQuery.Event( originalEvent );\n\n		i = copy.length;\n		while ( i-- ) {\n			prop = copy[ i ];\n			event[ prop ] = originalEvent[ prop ];\n		}\n\n		// Support: IE<9\n		// Fix target property (#1925)\n		if ( !event.target ) {\n			event.target = originalEvent.srcElement || document;\n		}\n\n		// Support: Safari 6-8+\n		// Target should not be a text node (#504, #13143)\n		if ( event.target.nodeType === 3 ) {\n			event.target = event.target.parentNode;\n		}\n\n		// Support: IE<9\n		// For mouse/key events, metaKey==false if it\'s undefined (#3368, #11328)\n		event.metaKey = !!event.metaKey;\n\n		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;\n	},\n\n	// Includes some event props shared by KeyEvent and MouseEvent\n	props: ( "altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " +\n		"metaKey relatedTarget shiftKey target timeStamp view which" ).split( " " ),\n\n	fixHooks: {},\n\n	keyHooks: {\n		props: "char charCode key keyCode".split( " " ),\n		filter: function( event, original ) {\n\n			// Add which for key events\n			if ( event.which == null ) {\n				event.which = original.charCode != null ? original.charCode : original.keyCode;\n			}\n\n			return event;\n		}\n	},\n\n	mouseHooks: {\n		props: ( "button buttons clientX clientY fromElement offsetX offsetY " +\n			"pageX pageY screenX screenY toElement" ).split( " " ),\n		filter: function( event, original ) {\n			var body, eventDoc, doc,\n				button = original.button,\n				fromElement = original.fromElement;\n\n			// Calculate pageX/Y if missing and clientX/Y available\n			if ( event.pageX == null && original.clientX != null ) {\n				eventDoc = event.target.ownerDocument || document;\n				doc = eventDoc.documentElement;\n				body = eventDoc.body;\n\n				event.pageX = original.clientX +\n					( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) -\n					( doc && doc.clientLeft || body && body.clientLeft || 0 );\n				event.pageY = original.clientY +\n					( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) -\n					( doc && doc.clientTop  || body && body.clientTop  || 0 );\n			}\n\n			// Add relatedTarget, if necessary\n			if ( !event.relatedTarget && fromElement ) {\n				event.relatedTarget = fromElement === event.target ?\n					original.toElement :\n					fromElement;\n			}\n\n			// Add which for click: 1 === left; 2 === middle; 3 === right\n			// Note: button is not normalized, so don\'t use it\n			if ( !event.which && button !== undefined ) {\n				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );\n			}\n\n			return event;\n		}\n	},\n\n	special: {\n		load: {\n\n			// Prevent triggered image.load events from bubbling to window.load\n			noBubble: true\n		},\n		focus: {\n\n			// Fire native event if possible so blur/focus sequence is correct\n			trigger: function() {\n				if ( this !== safeActiveElement() && this.focus ) {\n					try {\n						this.focus();\n						return false;\n					} catch ( e ) {\n\n						// Support: IE<9\n						// If we error on focus to hidden element (#1486, #12518),\n						// let .trigger() run the handlers\n					}\n				}\n			},\n			delegateType: "focusin"\n		},\n		blur: {\n			trigger: function() {\n				if ( this === safeActiveElement() && this.blur ) {\n					this.blur();\n					return false;\n				}\n			},\n			delegateType: "focusout"\n		},\n		click: {\n\n			// For checkbox, fire native event so checked state will be right\n			trigger: function() {\n				if ( jQuery.nodeName( this, "input" ) && this.type === "checkbox" && this.click ) {\n					this.click();\n					return false;\n				}\n			},\n\n			// For cross-browser consistency, don\'t fire native .click() on links\n			_default: function( event ) {\n				return jQuery.nodeName( event.target, "a" );\n			}\n		},\n\n		beforeunload: {\n			postDispatch: function( event ) {\n\n				// Support: Firefox 20+\n				// Firefox doesn\'t alert if the returnValue field is not set.\n				if ( event.result !== undefined && event.originalEvent ) {\n					event.originalEvent.returnValue = event.result;\n				}\n			}\n		}\n	},\n\n	// Piggyback on a donor event to simulate a different one\n	simulate: function( type, elem, event ) {\n		var e = jQuery.extend(\n			new jQuery.Event(),\n			event,\n			{\n				type: type,\n				isSimulated: true\n\n				// Previously, `originalEvent: {}` was set here, so stopPropagation call\n				// would not be triggered on donor event, since in our own\n				// jQuery.event.stopPropagation function we had a check for existence of\n				// originalEvent.stopPropagation method, so, consequently it would be a noop.\n				//\n				// Guard for simulated events was moved to jQuery.event.stopPropagation function\n				// since `originalEvent` should point to the original event for the\n				// constancy with other events and for more focused logic\n			}\n		);\n\n		jQuery.event.trigger( e, null, elem );\n\n		if ( e.isDefaultPrevented() ) {\n			event.preventDefault();\n		}\n	}\n};\n\njQuery.removeEvent = document.removeEventListener ?\n	function( elem, type, handle ) {\n\n		// This "if" is needed for plain objects\n		if ( elem.removeEventListener ) {\n			elem.removeEventListener( type, handle );\n		}\n	} :\n	function( elem, type, handle ) {\n		var name = "on" + type;\n\n		if ( elem.detachEvent ) {\n\n			// #8545, #7054, preventing memory leaks for custom events in IE6-8\n			// detachEvent needed property on element, by name of that event,\n			// to properly expose it to GC\n			if ( typeof elem[ name ] === "undefined" ) {\n				elem[ name ] = null;\n			}\n\n			elem.detachEvent( name, handle );\n		}\n	};\n\njQuery.Event = function( src, props ) {\n\n	// Allow instantiation without the \'new\' keyword\n	if ( !( this instanceof jQuery.Event ) ) {\n		return new jQuery.Event( src, props );\n	}\n\n	// Event object\n	if ( src && src.type ) {\n		this.originalEvent = src;\n		this.type = src.type;\n\n		// Events bubbling up the document may have been marked as prevented\n		// by a handler lower down the tree; reflect the correct value.\n		this.isDefaultPrevented = src.defaultPrevented ||\n				src.defaultPrevented === undefined &&\n\n				// Support: IE < 9, Android < 4.0\n				src.returnValue === false ?\n			returnTrue :\n			returnFalse;\n\n	// Event type\n	} else {\n		this.type = src;\n	}\n\n	// Put explicitly provided properties onto the event object\n	if ( props ) {\n		jQuery.extend( this, props );\n	}\n\n	// Create a timestamp if incoming event doesn\'t have one\n	this.timeStamp = src && src.timeStamp || jQuery.now();\n\n	// Mark it as fixed\n	this[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n	constructor: jQuery.Event,\n	isDefaultPrevented: returnFalse,\n	isPropagationStopped: returnFalse,\n	isImmediatePropagationStopped: returnFalse,\n\n	preventDefault: function() {\n		var e = this.originalEvent;\n\n		this.isDefaultPrevented = returnTrue;\n		if ( !e ) {\n			return;\n		}\n\n		// If preventDefault exists, run it on the original event\n		if ( e.preventDefault ) {\n			e.preventDefault();\n\n		// Support: IE\n		// Otherwise set the returnValue property of the original event to false\n		} else {\n			e.returnValue = false;\n		}\n	},\n	stopPropagation: function() {\n		var e = this.originalEvent;\n\n		this.isPropagationStopped = returnTrue;\n\n		if ( !e || this.isSimulated ) {\n			return;\n		}\n\n		// If stopPropagation exists, run it on the original event\n		if ( e.stopPropagation ) {\n			e.stopPropagation();\n		}\n\n		// Support: IE\n		// Set the cancelBubble property of the original event to true\n		e.cancelBubble = true;\n	},\n	stopImmediatePropagation: function() {\n		var e = this.originalEvent;\n\n		this.isImmediatePropagationStopped = returnTrue;\n\n		if ( e && e.stopImmediatePropagation ) {\n			e.stopImmediatePropagation();\n		}\n\n		this.stopPropagation();\n	}\n};\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// so that event delegation works in jQuery.\n// Do the same for pointerenter/pointerleave and pointerover/pointerout\n//\n// Support: Safari 7 only\n// Safari sends mouseenter too often; see:\n// https://code.google.com/p/chromium/issues/detail?id=470258\n// for the description of the bug (it existed in older Chrome versions as well).\njQuery.each( {\n	mouseenter: "mouseover",\n	mouseleave: "mouseout",\n	pointerenter: "pointerover",\n	pointerleave: "pointerout"\n}, function( orig, fix ) {\n	jQuery.event.special[ orig ] = {\n		delegateType: fix,\n		bindType: fix,\n\n		handle: function( event ) {\n			var ret,\n				target = this,\n				related = event.relatedTarget,\n				handleObj = event.handleObj;\n\n			// For mouseenter/leave call the handler if related is outside the target.\n			// NB: No relatedTarget if the mouse left/entered the browser window\n			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\n				event.type = handleObj.origType;\n				ret = handleObj.handler.apply( this, arguments );\n				event.type = fix;\n			}\n			return ret;\n		}\n	};\n} );\n\n// IE submit delegation\nif ( !support.submit ) {\n\n	jQuery.event.special.submit = {\n		setup: function() {\n\n			// Only need this for delegated form submit events\n			if ( jQuery.nodeName( this, "form" ) ) {\n				return false;\n			}\n\n			// Lazy-add a submit handler when a descendant form may potentially be submitted\n			jQuery.event.add( this, "click._submit keypress._submit", function( e ) {\n\n				// Node name check avoids a VML-related crash in IE (#9807)\n				var elem = e.target,\n					form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ?\n\n						// Support: IE <=8\n						// We use jQuery.prop instead of elem.form\n						// to allow fixing the IE8 delegated submit issue (gh-2332)\n						// by 3rd party polyfills/workarounds.\n						jQuery.prop( elem, "form" ) :\n						undefined;\n\n				if ( form && !jQuery._data( form, "submit" ) ) {\n					jQuery.event.add( form, "submit._submit", function( event ) {\n						event._submitBubble = true;\n					} );\n					jQuery._data( form, "submit", true );\n				}\n			} );\n\n			// return undefined since we don\'t need an event listener\n		},\n\n		postDispatch: function( event ) {\n\n			// If form was submitted by the user, bubble the event up the tree\n			if ( event._submitBubble ) {\n				delete event._submitBubble;\n				if ( this.parentNode && !event.isTrigger ) {\n					jQuery.event.simulate( "submit", this.parentNode, event );\n				}\n			}\n		},\n\n		teardown: function() {\n\n			// Only need this for delegated form submit events\n			if ( jQuery.nodeName( this, "form" ) ) {\n				return false;\n			}\n\n			// Remove delegated handlers; cleanData eventually reaps submit handlers attached above\n			jQuery.event.remove( this, "._submit" );\n		}\n	};\n}\n\n// IE change delegation and checkbox/radio fix\nif ( !support.change ) {\n\n	jQuery.event.special.change = {\n\n		setup: function() {\n\n			if ( rformElems.test( this.nodeName ) ) {\n\n				// IE doesn\'t fire change on a check/radio until blur; trigger it on click\n				// after a propertychange. Eat the blur-change in special.change.handle.\n				// This still fires onchange a second time for check/radio after blur.\n				if ( this.type === "checkbox" || this.type === "radio" ) {\n					jQuery.event.add( this, "propertychange._change", function( event ) {\n						if ( event.originalEvent.propertyName === "checked" ) {\n							this._justChanged = true;\n						}\n					} );\n					jQuery.event.add( this, "click._change", function( event ) {\n						if ( this._justChanged && !event.isTrigger ) {\n							this._justChanged = false;\n						}\n\n						// Allow triggered, simulated change events (#11500)\n						jQuery.event.simulate( "change", this, event );\n					} );\n				}\n				return false;\n			}\n\n			// Delegated event; lazy-add a change handler on descendant inputs\n			jQuery.event.add( this, "beforeactivate._change", function( e ) {\n				var elem = e.target;\n\n				if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, "change" ) ) {\n					jQuery.event.add( elem, "change._change", function( event ) {\n						if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {\n							jQuery.event.simulate( "change", this.parentNode, event );\n						}\n					} );\n					jQuery._data( elem, "change", true );\n				}\n			} );\n		},\n\n		handle: function( event ) {\n			var elem = event.target;\n\n			// Swallow native change events from checkbox/radio, we already triggered them above\n			if ( this !== elem || event.isSimulated || event.isTrigger ||\n				( elem.type !== "radio" && elem.type !== "checkbox" ) ) {\n\n				return event.handleObj.handler.apply( this, arguments );\n			}\n		},\n\n		teardown: function() {\n			jQuery.event.remove( this, "._change" );\n\n			return !rformElems.test( this.nodeName );\n		}\n	};\n}\n\n// Support: Firefox\n// Firefox doesn\'t have focus(in | out) events\n// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n//\n// Support: Chrome, Safari\n// focus(in | out) events fire after focus & blur events,\n// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n// Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857\nif ( !support.focusin ) {\n	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {\n\n		// Attach a single capturing handler on the document while someone wants focusin/focusout\n		var handler = function( event ) {\n			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\n		};\n\n		jQuery.event.special[ fix ] = {\n			setup: function() {\n				var doc = this.ownerDocument || this,\n					attaches = jQuery._data( doc, fix );\n\n				if ( !attaches ) {\n					doc.addEventListener( orig, handler, true );\n				}\n				jQuery._data( doc, fix, ( attaches || 0 ) + 1 );\n			},\n			teardown: function() {\n				var doc = this.ownerDocument || this,\n					attaches = jQuery._data( doc, fix ) - 1;\n\n				if ( !attaches ) {\n					doc.removeEventListener( orig, handler, true );\n					jQuery._removeData( doc, fix );\n				} else {\n					jQuery._data( doc, fix, attaches );\n				}\n			}\n		};\n	} );\n}\n\njQuery.fn.extend( {\n\n	on: function( types, selector, data, fn ) {\n		return on( this, types, selector, data, fn );\n	},\n	one: function( types, selector, data, fn ) {\n		return on( this, types, selector, data, fn, 1 );\n	},\n	off: function( types, selector, fn ) {\n		var handleObj, type;\n		if ( types && types.preventDefault && types.handleObj ) {\n\n			// ( event )  dispatched jQuery.Event\n			handleObj = types.handleObj;\n			jQuery( types.delegateTarget ).off(\n				handleObj.namespace ?\n					handleObj.origType + "." + handleObj.namespace :\n					handleObj.origType,\n				handleObj.selector,\n				handleObj.handler\n			);\n			return this;\n		}\n		if ( typeof types === "object" ) {\n\n			// ( types-object [, selector] )\n			for ( type in types ) {\n				this.off( type, selector, types[ type ] );\n			}\n			return this;\n		}\n		if ( selector === false || typeof selector === "function" ) {\n\n			// ( types [, fn] )\n			fn = selector;\n			selector = undefined;\n		}\n		if ( fn === false ) {\n			fn = returnFalse;\n		}\n		return this.each( function() {\n			jQuery.event.remove( this, types, fn, selector );\n		} );\n	},\n\n	trigger: function( type, data ) {\n		return this.each( function() {\n			jQuery.event.trigger( type, data, this );\n		} );\n	},\n	triggerHandler: function( type, data ) {\n		var elem = this[ 0 ];\n		if ( elem ) {\n			return jQuery.event.trigger( type, data, elem, true );\n		}\n	}\n} );\n\n\nvar rinlinejQuery = / jQuery\\d+="(?:null|\\d+)"/g,\n	rnoshimcache = new RegExp( "<(?:" + nodeNames + ")[\\\\s/>]", "i" ),\n	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:-]+)[^>]*)\\/>/gi,\n\n	// Support: IE 10-11, Edge 10240+\n	// In IE/Edge using regex groups here causes severe slowdowns.\n	// See https://connect.microsoft.com/IE/feedback/details/1736512/\n	rnoInnerhtml = /<script|<style|<link/i,\n\n	// checked="checked" or checked\n	rchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n	rscriptTypeMasked = /^true\\/(.*)/,\n	rcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,\n	safeFragment = createSafeFragment( document ),\n	fragmentDiv = safeFragment.appendChild( document.createElement( "div" ) );\n\n// Support: IE<8\n// Manipulating tables requires a tbody\nfunction manipulationTarget( elem, content ) {\n	return jQuery.nodeName( elem, "table" ) &&\n		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?\n\n		elem.getElementsByTagName( "tbody" )[ 0 ] ||\n			elem.appendChild( elem.ownerDocument.createElement( "tbody" ) ) :\n		elem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n	elem.type = ( jQuery.find.attr( elem, "type" ) !== null ) + "/" + elem.type;\n	return elem;\n}\nfunction restoreScript( elem ) {\n	var match = rscriptTypeMasked.exec( elem.type );\n	if ( match ) {\n		elem.type = match[ 1 ];\n	} else {\n		elem.removeAttribute( "type" );\n	}\n	return elem;\n}\n\nfunction cloneCopyEvent( src, dest ) {\n	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {\n		return;\n	}\n\n	var type, i, l,\n		oldData = jQuery._data( src ),\n		curData = jQuery._data( dest, oldData ),\n		events = oldData.events;\n\n	if ( events ) {\n		delete curData.handle;\n		curData.events = {};\n\n		for ( type in events ) {\n			for ( i = 0, l = events[ type ].length; i < l; i++ ) {\n				jQuery.event.add( dest, type, events[ type ][ i ] );\n			}\n		}\n	}\n\n	// make the cloned public data object a copy from the original\n	if ( curData.data ) {\n		curData.data = jQuery.extend( {}, curData.data );\n	}\n}\n\nfunction fixCloneNodeIssues( src, dest ) {\n	var nodeName, e, data;\n\n	// We do not need to do anything for non-Elements\n	if ( dest.nodeType !== 1 ) {\n		return;\n	}\n\n	nodeName = dest.nodeName.toLowerCase();\n\n	// IE6-8 copies events bound via attachEvent when using cloneNode.\n	if ( !support.noCloneEvent && dest[ jQuery.expando ] ) {\n		data = jQuery._data( dest );\n\n		for ( e in data.events ) {\n			jQuery.removeEvent( dest, e, data.handle );\n		}\n\n		// Event data gets referenced instead of copied if the expando gets copied too\n		dest.removeAttribute( jQuery.expando );\n	}\n\n	// IE blanks contents when cloning scripts, and tries to evaluate newly-set text\n	if ( nodeName === "script" && dest.text !== src.text ) {\n		disableScript( dest ).text = src.text;\n		restoreScript( dest );\n\n	// IE6-10 improperly clones children of object elements using classid.\n	// IE10 throws NoModificationAllowedError if parent is null, #12132.\n	} else if ( nodeName === "object" ) {\n		if ( dest.parentNode ) {\n			dest.outerHTML = src.outerHTML;\n		}\n\n		// This path appears unavoidable for IE9. When cloning an object\n		// element in IE9, the outerHTML strategy above is not sufficient.\n		// If the src has innerHTML and the destination does not,\n		// copy the src.innerHTML into the dest.innerHTML. #10324\n		if ( support.html5Clone && ( src.innerHTML && !jQuery.trim( dest.innerHTML ) ) ) {\n			dest.innerHTML = src.innerHTML;\n		}\n\n	} else if ( nodeName === "input" && rcheckableType.test( src.type ) ) {\n\n		// IE6-8 fails to persist the checked state of a cloned checkbox\n		// or radio button. Worse, IE6-7 fail to give the cloned element\n		// a checked appearance if the defaultChecked value isn\'t also set\n\n		dest.defaultChecked = dest.checked = src.checked;\n\n		// IE6-7 get confused and end up setting the value of a cloned\n		// checkbox/radio button to an empty string instead of "on"\n		if ( dest.value !== src.value ) {\n			dest.value = src.value;\n		}\n\n	// IE6-8 fails to return the selected option to the default selected\n	// state when cloning options\n	} else if ( nodeName === "option" ) {\n		dest.defaultSelected = dest.selected = src.defaultSelected;\n\n	// IE6-8 fails to set the defaultValue to the correct value when\n	// cloning other types of input fields\n	} else if ( nodeName === "input" || nodeName === "textarea" ) {\n		dest.defaultValue = src.defaultValue;\n	}\n}\n\nfunction domManip( collection, args, callback, ignored ) {\n\n	// Flatten any nested arrays\n	args = concat.apply( [], args );\n\n	var first, node, hasScripts,\n		scripts, doc, fragment,\n		i = 0,\n		l = collection.length,\n		iNoClone = l - 1,\n		value = args[ 0 ],\n		isFunction = jQuery.isFunction( value );\n\n	// We can\'t cloneNode fragments that contain checked, in WebKit\n	if ( isFunction ||\n			( l > 1 && typeof value === "string" &&\n				!support.checkClone && rchecked.test( value ) ) ) {\n		return collection.each( function( index ) {\n			var self = collection.eq( index );\n			if ( isFunction ) {\n				args[ 0 ] = value.call( this, index, self.html() );\n			}\n			domManip( self, args, callback, ignored );\n		} );\n	}\n\n	if ( l ) {\n		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\n		first = fragment.firstChild;\n\n		if ( fragment.childNodes.length === 1 ) {\n			fragment = first;\n		}\n\n		// Require either new content or an interest in ignored elements to invoke the callback\n		if ( first || ignored ) {\n			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );\n			hasScripts = scripts.length;\n\n			// Use the original fragment for the last item\n			// instead of the first because it can end up\n			// being emptied incorrectly in certain situations (#8070).\n			for ( ; i < l; i++ ) {\n				node = fragment;\n\n				if ( i !== iNoClone ) {\n					node = jQuery.clone( node, true, true );\n\n					// Keep references to cloned scripts for later restoration\n					if ( hasScripts ) {\n\n						// Support: Android<4.1, PhantomJS<2\n						// push.apply(_, arraylike) throws on ancient WebKit\n						jQuery.merge( scripts, getAll( node, "script" ) );\n					}\n				}\n\n				callback.call( collection[ i ], node, i );\n			}\n\n			if ( hasScripts ) {\n				doc = scripts[ scripts.length - 1 ].ownerDocument;\n\n				// Reenable scripts\n				jQuery.map( scripts, restoreScript );\n\n				// Evaluate executable scripts on first document insertion\n				for ( i = 0; i < hasScripts; i++ ) {\n					node = scripts[ i ];\n					if ( rscriptType.test( node.type || "" ) &&\n						!jQuery._data( node, "globalEval" ) &&\n						jQuery.contains( doc, node ) ) {\n\n						if ( node.src ) {\n\n							// Optional AJAX dependency, but won\'t run scripts if not present\n							if ( jQuery._evalUrl ) {\n								jQuery._evalUrl( node.src );\n							}\n						} else {\n							jQuery.globalEval(\n								( node.text || node.textContent || node.innerHTML || "" )\n									.replace( rcleanScript, "" )\n							);\n						}\n					}\n				}\n			}\n\n			// Fix #11809: Avoid leaking memory\n			fragment = first = null;\n		}\n	}\n\n	return collection;\n}\n\nfunction remove( elem, selector, keepData ) {\n	var node,\n		elems = selector ? jQuery.filter( selector, elem ) : elem,\n		i = 0;\n\n	for ( ; ( node = elems[ i ] ) != null; i++ ) {\n\n		if ( !keepData && node.nodeType === 1 ) {\n			jQuery.cleanData( getAll( node ) );\n		}\n\n		if ( node.parentNode ) {\n			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {\n				setGlobalEval( getAll( node, "script" ) );\n			}\n			node.parentNode.removeChild( node );\n		}\n	}\n\n	return elem;\n}\n\njQuery.extend( {\n	htmlPrefilter: function( html ) {\n		return html.replace( rxhtmlTag, "<$1></$2>" );\n	},\n\n	clone: function( elem, dataAndEvents, deepDataAndEvents ) {\n		var destElements, node, clone, i, srcElements,\n			inPage = jQuery.contains( elem.ownerDocument, elem );\n\n		if ( support.html5Clone || jQuery.isXMLDoc( elem ) ||\n			!rnoshimcache.test( "<" + elem.nodeName + ">" ) ) {\n\n			clone = elem.cloneNode( true );\n\n		// IE<=8 does not properly clone detached, unknown element nodes\n		} else {\n			fragmentDiv.innerHTML = elem.outerHTML;\n			fragmentDiv.removeChild( clone = fragmentDiv.firstChild );\n		}\n\n		if ( ( !support.noCloneEvent || !support.noCloneChecked ) &&\n				( elem.nodeType === 1 || elem.nodeType === 11 ) && !jQuery.isXMLDoc( elem ) ) {\n\n			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2\n			destElements = getAll( clone );\n			srcElements = getAll( elem );\n\n			// Fix all IE cloning issues\n			for ( i = 0; ( node = srcElements[ i ] ) != null; ++i ) {\n\n				// Ensure that the destination node is not null; Fixes #9587\n				if ( destElements[ i ] ) {\n					fixCloneNodeIssues( node, destElements[ i ] );\n				}\n			}\n		}\n\n		// Copy the events from the original to the clone\n		if ( dataAndEvents ) {\n			if ( deepDataAndEvents ) {\n				srcElements = srcElements || getAll( elem );\n				destElements = destElements || getAll( clone );\n\n				for ( i = 0; ( node = srcElements[ i ] ) != null; i++ ) {\n					cloneCopyEvent( node, destElements[ i ] );\n				}\n			} else {\n				cloneCopyEvent( elem, clone );\n			}\n		}\n\n		// Preserve script evaluation history\n		destElements = getAll( clone, "script" );\n		if ( destElements.length > 0 ) {\n			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );\n		}\n\n		destElements = srcElements = node = null;\n\n		// Return the cloned set\n		return clone;\n	},\n\n	cleanData: function( elems, /* internal */ forceAcceptData ) {\n		var elem, type, id, data,\n			i = 0,\n			internalKey = jQuery.expando,\n			cache = jQuery.cache,\n			attributes = support.attributes,\n			special = jQuery.event.special;\n\n		for ( ; ( elem = elems[ i ] ) != null; i++ ) {\n			if ( forceAcceptData || acceptData( elem ) ) {\n\n				id = elem[ internalKey ];\n				data = id && cache[ id ];\n\n				if ( data ) {\n					if ( data.events ) {\n						for ( type in data.events ) {\n							if ( special[ type ] ) {\n								jQuery.event.remove( elem, type );\n\n							// This is a shortcut to avoid jQuery.event.remove\'s overhead\n							} else {\n								jQuery.removeEvent( elem, type, data.handle );\n							}\n						}\n					}\n\n					// Remove cache only if it was not already removed by jQuery.event.remove\n					if ( cache[ id ] ) {\n\n						delete cache[ id ];\n\n						// Support: IE<9\n						// IE does not allow us to delete expando properties from nodes\n						// IE creates expando attributes along with the property\n						// IE does not have a removeAttribute function on Document nodes\n						if ( !attributes && typeof elem.removeAttribute !== "undefined" ) {\n							elem.removeAttribute( internalKey );\n\n						// Webkit & Blink performance suffers when deleting properties\n						// from DOM nodes, so set to undefined instead\n						// https://code.google.com/p/chromium/issues/detail?id=378607\n						} else {\n							elem[ internalKey ] = undefined;\n						}\n\n						deletedIds.push( id );\n					}\n				}\n			}\n		}\n	}\n} );\n\njQuery.fn.extend( {\n\n	// Keep domManip exposed until 3.0 (gh-2225)\n	domManip: domManip,\n\n	detach: function( selector ) {\n		return remove( this, selector, true );\n	},\n\n	remove: function( selector ) {\n		return remove( this, selector );\n	},\n\n	text: function( value ) {\n		return access( this, function( value ) {\n			return value === undefined ?\n				jQuery.text( this ) :\n				this.empty().append(\n					( this[ 0 ] && this[ 0 ].ownerDocument || document ).createTextNode( value )\n				);\n		}, null, value, arguments.length );\n	},\n\n	append: function() {\n		return domManip( this, arguments, function( elem ) {\n			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n				var target = manipulationTarget( this, elem );\n				target.appendChild( elem );\n			}\n		} );\n	},\n\n	prepend: function() {\n		return domManip( this, arguments, function( elem ) {\n			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n				var target = manipulationTarget( this, elem );\n				target.insertBefore( elem, target.firstChild );\n			}\n		} );\n	},\n\n	before: function() {\n		return domManip( this, arguments, function( elem ) {\n			if ( this.parentNode ) {\n				this.parentNode.insertBefore( elem, this );\n			}\n		} );\n	},\n\n	after: function() {\n		return domManip( this, arguments, function( elem ) {\n			if ( this.parentNode ) {\n				this.parentNode.insertBefore( elem, this.nextSibling );\n			}\n		} );\n	},\n\n	empty: function() {\n		var elem,\n			i = 0;\n\n		for ( ; ( elem = this[ i ] ) != null; i++ ) {\n\n			// Remove element nodes and prevent memory leaks\n			if ( elem.nodeType === 1 ) {\n				jQuery.cleanData( getAll( elem, false ) );\n			}\n\n			// Remove any remaining nodes\n			while ( elem.firstChild ) {\n				elem.removeChild( elem.firstChild );\n			}\n\n			// If this is a select, ensure that it displays empty (#12336)\n			// Support: IE<9\n			if ( elem.options && jQuery.nodeName( elem, "select" ) ) {\n				elem.options.length = 0;\n			}\n		}\n\n		return this;\n	},\n\n	clone: function( dataAndEvents, deepDataAndEvents ) {\n		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n		return this.map( function() {\n			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n		} );\n	},\n\n	html: function( value ) {\n		return access( this, function( value ) {\n			var elem = this[ 0 ] || {},\n				i = 0,\n				l = this.length;\n\n			if ( value === undefined ) {\n				return elem.nodeType === 1 ?\n					elem.innerHTML.replace( rinlinejQuery, "" ) :\n					undefined;\n			}\n\n			// See if we can take a shortcut and just use innerHTML\n			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&\n				( support.htmlSerialize || !rnoshimcache.test( value )  ) &&\n				( support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&\n				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {\n\n				value = jQuery.htmlPrefilter( value );\n\n				try {\n					for ( ; i < l; i++ ) {\n\n						// Remove element nodes and prevent memory leaks\n						elem = this[ i ] || {};\n						if ( elem.nodeType === 1 ) {\n							jQuery.cleanData( getAll( elem, false ) );\n							elem.innerHTML = value;\n						}\n					}\n\n					elem = 0;\n\n				// If using innerHTML throws an exception, use the fallback method\n				} catch ( e ) {}\n			}\n\n			if ( elem ) {\n				this.empty().append( value );\n			}\n		}, null, value, arguments.length );\n	},\n\n	replaceWith: function() {\n		var ignored = [];\n\n		// Make the changes, replacing each non-ignored context element with the new content\n		return domManip( this, arguments, function( elem ) {\n			var parent = this.parentNode;\n\n			if ( jQuery.inArray( this, ignored ) < 0 ) {\n				jQuery.cleanData( getAll( this ) );\n				if ( parent ) {\n					parent.replaceChild( elem, this );\n				}\n			}\n\n		// Force callback invocation\n		}, ignored );\n	}\n} );\n\njQuery.each( {\n	appendTo: "append",\n	prependTo: "prepend",\n	insertBefore: "before",\n	insertAfter: "after",\n	replaceAll: "replaceWith"\n}, function( name, original ) {\n	jQuery.fn[ name ] = function( selector ) {\n		var elems,\n			i = 0,\n			ret = [],\n			insert = jQuery( selector ),\n			last = insert.length - 1;\n\n		for ( ; i <= last; i++ ) {\n			elems = i === last ? this : this.clone( true );\n			jQuery( insert[ i ] )[ original ]( elems );\n\n			// Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()\n			push.apply( ret, elems.get() );\n		}\n\n		return this.pushStack( ret );\n	};\n} );\n\n\nvar iframe,\n	elemdisplay = {\n\n		// Support: Firefox\n		// We have to pre-define these values for FF (#10227)\n		HTML: "block",\n		BODY: "block"\n	};\n\n/**\n * Retrieve the actual display of a element\n * @param {String} name nodeName of the element\n * @param {Object} doc Document object\n */\n\n// Called only from within defaultDisplay\nfunction actualDisplay( name, doc ) {\n	var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),\n\n		display = jQuery.css( elem[ 0 ], "display" );\n\n	// We don\'t have any data stored on the element,\n	// so use "detach" method as fast way to get rid of the element\n	elem.detach();\n\n	return display;\n}\n\n/**\n * Try to determine the default display value of an element\n * @param {String} nodeName\n */\nfunction defaultDisplay( nodeName ) {\n	var doc = document,\n		display = elemdisplay[ nodeName ];\n\n	if ( !display ) {\n		display = actualDisplay( nodeName, doc );\n\n		// If the simple way fails, read from inside an iframe\n		if ( display === "none" || !display ) {\n\n			// Use the already-created iframe if possible\n			iframe = ( iframe || jQuery( "<iframe frameborder=\'0\' width=\'0\' height=\'0\'/>" ) )\n				.appendTo( doc.documentElement );\n\n			// Always write a new HTML skeleton so Webkit and Firefox don\'t choke on reuse\n			doc = ( iframe[ 0 ].contentWindow || iframe[ 0 ].contentDocument ).document;\n\n			// Support: IE\n			doc.write();\n			doc.close();\n\n			display = actualDisplay( nodeName, doc );\n			iframe.detach();\n		}\n\n		// Store the correct default display\n		elemdisplay[ nodeName ] = display;\n	}\n\n	return display;\n}\nvar rmargin = ( /^margin/ );\n\nvar rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );\n\nvar swap = function( elem, options, callback, args ) {\n	var ret, name,\n		old = {};\n\n	// Remember the old values, and insert the new ones\n	for ( name in options ) {\n		old[ name ] = elem.style[ name ];\n		elem.style[ name ] = options[ name ];\n	}\n\n	ret = callback.apply( elem, args || [] );\n\n	// Revert the old values\n	for ( name in options ) {\n		elem.style[ name ] = old[ name ];\n	}\n\n	return ret;\n};\n\n\nvar documentElement = document.documentElement;\n\n\n\n( function() {\n	var pixelPositionVal, pixelMarginRightVal, boxSizingReliableVal,\n		reliableHiddenOffsetsVal, reliableMarginRightVal, reliableMarginLeftVal,\n		container = document.createElement( "div" ),\n		div = document.createElement( "div" );\n\n	// Finish early in limited (non-browser) environments\n	if ( !div.style ) {\n		return;\n	}\n\n	div.style.cssText = "float:left;opacity:.5";\n\n	// Support: IE<9\n	// Make sure that element opacity exists (as opposed to filter)\n	support.opacity = div.style.opacity === "0.5";\n\n	// Verify style float existence\n	// (IE uses styleFloat instead of cssFloat)\n	support.cssFloat = !!div.style.cssFloat;\n\n	div.style.backgroundClip = "content-box";\n	div.cloneNode( true ).style.backgroundClip = "";\n	support.clearCloneStyle = div.style.backgroundClip === "content-box";\n\n	container = document.createElement( "div" );\n	container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +\n		"padding:0;margin-top:1px;position:absolute";\n	div.innerHTML = "";\n	container.appendChild( div );\n\n	// Support: Firefox<29, Android 2.3\n	// Vendor-prefix box-sizing\n	support.boxSizing = div.style.boxSizing === "" || div.style.MozBoxSizing === "" ||\n		div.style.WebkitBoxSizing === "";\n\n	jQuery.extend( support, {\n		reliableHiddenOffsets: function() {\n			if ( pixelPositionVal == null ) {\n				computeStyleTests();\n			}\n			return reliableHiddenOffsetsVal;\n		},\n\n		boxSizingReliable: function() {\n\n			// We\'re checking for pixelPositionVal here instead of boxSizingReliableVal\n			// since that compresses better and they\'re computed together anyway.\n			if ( pixelPositionVal == null ) {\n				computeStyleTests();\n			}\n			return boxSizingReliableVal;\n		},\n\n		pixelMarginRight: function() {\n\n			// Support: Android 4.0-4.3\n			if ( pixelPositionVal == null ) {\n				computeStyleTests();\n			}\n			return pixelMarginRightVal;\n		},\n\n		pixelPosition: function() {\n			if ( pixelPositionVal == null ) {\n				computeStyleTests();\n			}\n			return pixelPositionVal;\n		},\n\n		reliableMarginRight: function() {\n\n			// Support: Android 2.3\n			if ( pixelPositionVal == null ) {\n				computeStyleTests();\n			}\n			return reliableMarginRightVal;\n		},\n\n		reliableMarginLeft: function() {\n\n			// Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37\n			if ( pixelPositionVal == null ) {\n				computeStyleTests();\n			}\n			return reliableMarginLeftVal;\n		}\n	} );\n\n	function computeStyleTests() {\n		var contents, divStyle,\n			documentElement = document.documentElement;\n\n		// Setup\n		documentElement.appendChild( container );\n\n		div.style.cssText =\n\n			// Support: Android 2.3\n			// Vendor-prefix box-sizing\n			"-webkit-box-sizing:border-box;box-sizing:border-box;" +\n			"position:relative;display:block;" +\n			"margin:auto;border:1px;padding:1px;" +\n			"top:1%;width:50%";\n\n		// Support: IE<9\n		// Assume reasonable values in the absence of getComputedStyle\n		pixelPositionVal = boxSizingReliableVal = reliableMarginLeftVal = false;\n		pixelMarginRightVal = reliableMarginRightVal = true;\n\n		// Check for getComputedStyle so that this code is not run in IE<9.\n		if ( window.getComputedStyle ) {\n			divStyle = window.getComputedStyle( div );\n			pixelPositionVal = ( divStyle || {} ).top !== "1%";\n			reliableMarginLeftVal = ( divStyle || {} ).marginLeft === "2px";\n			boxSizingReliableVal = ( divStyle || { width: "4px" } ).width === "4px";\n\n			// Support: Android 4.0 - 4.3 only\n			// Some styles come back with percentage values, even though they shouldn\'t\n			div.style.marginRight = "50%";\n			pixelMarginRightVal = ( divStyle || { marginRight: "4px" } ).marginRight === "4px";\n\n			// Support: Android 2.3 only\n			// Div with explicit width and no margin-right incorrectly\n			// gets computed margin-right based on width of container (#3333)\n			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n			contents = div.appendChild( document.createElement( "div" ) );\n\n			// Reset CSS: box-sizing; display; margin; border; padding\n			contents.style.cssText = div.style.cssText =\n\n				// Support: Android 2.3\n				// Vendor-prefix box-sizing\n				"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +\n				"box-sizing:content-box;display:block;margin:0;border:0;padding:0";\n			contents.style.marginRight = contents.style.width = "0";\n			div.style.width = "1px";\n\n			reliableMarginRightVal =\n				!parseFloat( ( window.getComputedStyle( contents ) || {} ).marginRight );\n\n			div.removeChild( contents );\n		}\n\n		// Support: IE6-8\n		// First check that getClientRects works as expected\n		// Check if table cells still have offsetWidth/Height when they are set\n		// to display:none and there are still other visible table cells in a\n		// table row; if so, offsetWidth/Height are not reliable for use when\n		// determining if an element has been hidden directly using\n		// display:none (it is still safe to use offsets if a parent element is\n		// hidden; don safety goggles and see bug #4512 for more information).\n		div.style.display = "none";\n		reliableHiddenOffsetsVal = div.getClientRects().length === 0;\n		if ( reliableHiddenOffsetsVal ) {\n			div.style.display = "";\n			div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";\n			contents = div.getElementsByTagName( "td" );\n			contents[ 0 ].style.cssText = "margin:0;border:0;padding:0;display:none";\n			reliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;\n			if ( reliableHiddenOffsetsVal ) {\n				contents[ 0 ].style.display = "";\n				contents[ 1 ].style.display = "none";\n				reliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;\n			}\n		}\n\n		// Teardown\n		documentElement.removeChild( container );\n	}\n\n} )();\n\n\nvar getStyles, curCSS,\n	rposition = /^(top|right|bottom|left)$/;\n\nif ( window.getComputedStyle ) {\n	getStyles = function( elem ) {\n\n		// Support: IE<=11+, Firefox<=30+ (#15098, #14150)\n		// IE throws on elements created in popups\n		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"\n		var view = elem.ownerDocument.defaultView;\n\n		if ( !view || !view.opener ) {\n			view = window;\n		}\n\n		return view.getComputedStyle( elem );\n	};\n\n	curCSS = function( elem, name, computed ) {\n		var width, minWidth, maxWidth, ret,\n			style = elem.style;\n\n		computed = computed || getStyles( elem );\n\n		// getPropertyValue is only needed for .css(\'filter\') in IE9, see #12537\n		ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;\n\n		// Support: Opera 12.1x only\n		// Fall back to style even without computed\n		// computed is undefined for elems on document fragments\n		if ( ( ret === "" || ret === undefined ) && !jQuery.contains( elem.ownerDocument, elem ) ) {\n			ret = jQuery.style( elem, name );\n		}\n\n		if ( computed ) {\n\n			// A tribute to the "awesome hack by Dean Edwards"\n			// Chrome < 17 and Safari 5.0 uses "computed value"\n			// instead of "used value" for margin-right\n			// Safari 5.1.7 (at least) returns percentage for a larger set of values,\n			// but width seems to be reliably pixels\n			// this is against the CSSOM draft spec:\n			// http://dev.w3.org/csswg/cssom/#resolved-values\n			if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\n				// Remember the original values\n				width = style.width;\n				minWidth = style.minWidth;\n				maxWidth = style.maxWidth;\n\n				// Put in the new values to get a computed value out\n				style.minWidth = style.maxWidth = style.width = ret;\n				ret = computed.width;\n\n				// Revert the changed values\n				style.width = width;\n				style.minWidth = minWidth;\n				style.maxWidth = maxWidth;\n			}\n		}\n\n		// Support: IE\n		// IE returns zIndex value as an integer.\n		return ret === undefined ?\n			ret :\n			ret + "";\n	};\n} else if ( documentElement.currentStyle ) {\n	getStyles = function( elem ) {\n		return elem.currentStyle;\n	};\n\n	curCSS = function( elem, name, computed ) {\n		var left, rs, rsLeft, ret,\n			style = elem.style;\n\n		computed = computed || getStyles( elem );\n		ret = computed ? computed[ name ] : undefined;\n\n		// Avoid setting ret to empty string here\n		// so we don\'t default to auto\n		if ( ret == null && style && style[ name ] ) {\n			ret = style[ name ];\n		}\n\n		// From the awesome hack by Dean Edwards\n		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291\n\n		// If we\'re not dealing with a regular pixel number\n		// but a number that has a weird ending, we need to convert it to pixels\n		// but not position css attributes, as those are\n		// proportional to the parent element instead\n		// and we can\'t measure the parent instead because it\n		// might trigger a "stacking dolls" problem\n		if ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {\n\n			// Remember the original values\n			left = style.left;\n			rs = elem.runtimeStyle;\n			rsLeft = rs && rs.left;\n\n			// Put in the new values to get a computed value out\n			if ( rsLeft ) {\n				rs.left = elem.currentStyle.left;\n			}\n			style.left = name === "fontSize" ? "1em" : ret;\n			ret = style.pixelLeft + "px";\n\n			// Revert the changed values\n			style.left = left;\n			if ( rsLeft ) {\n				rs.left = rsLeft;\n			}\n		}\n\n		// Support: IE\n		// IE returns zIndex value as an integer.\n		return ret === undefined ?\n			ret :\n			ret + "" || "auto";\n	};\n}\n\n\n\n\nfunction addGetHookIf( conditionFn, hookFn ) {\n\n	// Define the hook, we\'ll check on the first run if it\'s really needed.\n	return {\n		get: function() {\n			if ( conditionFn() ) {\n\n				// Hook not needed (or it\'s not possible to use it due\n				// to missing dependency), remove it.\n				delete this.get;\n				return;\n			}\n\n			// Hook needed; redefine it so that the support test is not executed again.\n			return ( this.get = hookFn ).apply( this, arguments );\n		}\n	};\n}\n\n\nvar\n\n		ralpha = /alpha\\([^)]*\\)/i,\n	ropacity = /opacity\\s*=\\s*([^)]*)/i,\n\n	// swappable if display is none or starts with table except\n	// "table", "table-cell", or "table-caption"\n	// see here for display values:\n	// https://developer.mozilla.org/en-US/docs/CSS/display\n	rdisplayswap = /^(none|table(?!-c[ea]).+)/,\n	rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),\n\n	cssShow = { position: "absolute", visibility: "hidden", display: "block" },\n	cssNormalTransform = {\n		letterSpacing: "0",\n		fontWeight: "400"\n	},\n\n	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ],\n	emptyStyle = document.createElement( "div" ).style;\n\n\n// return a css property mapped to a potentially vendor prefixed property\nfunction vendorPropName( name ) {\n\n	// shortcut for names that are not vendor prefixed\n	if ( name in emptyStyle ) {\n		return name;\n	}\n\n	// check for vendor prefixed names\n	var capName = name.charAt( 0 ).toUpperCase() + name.slice( 1 ),\n		i = cssPrefixes.length;\n\n	while ( i-- ) {\n		name = cssPrefixes[ i ] + capName;\n		if ( name in emptyStyle ) {\n			return name;\n		}\n	}\n}\n\nfunction showHide( elements, show ) {\n	var display, elem, hidden,\n		values = [],\n		index = 0,\n		length = elements.length;\n\n	for ( ; index < length; index++ ) {\n		elem = elements[ index ];\n		if ( !elem.style ) {\n			continue;\n		}\n\n		values[ index ] = jQuery._data( elem, "olddisplay" );\n		display = elem.style.display;\n		if ( show ) {\n\n			// Reset the inline display of this element to learn if it is\n			// being hidden by cascaded rules or not\n			if ( !values[ index ] && display === "none" ) {\n				elem.style.display = "";\n			}\n\n			// Set elements which have been overridden with display: none\n			// in a stylesheet to whatever the default browser style is\n			// for such an element\n			if ( elem.style.display === "" && isHidden( elem ) ) {\n				values[ index ] =\n					jQuery._data( elem, "olddisplay", defaultDisplay( elem.nodeName ) );\n			}\n		} else {\n			hidden = isHidden( elem );\n\n			if ( display && display !== "none" || !hidden ) {\n				jQuery._data(\n					elem,\n					"olddisplay",\n					hidden ? display : jQuery.css( elem, "display" )\n				);\n			}\n		}\n	}\n\n	// Set the display of most of the elements in a second loop\n	// to avoid the constant reflow\n	for ( index = 0; index < length; index++ ) {\n		elem = elements[ index ];\n		if ( !elem.style ) {\n			continue;\n		}\n		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {\n			elem.style.display = show ? values[ index ] || "" : "none";\n		}\n	}\n\n	return elements;\n}\n\nfunction setPositiveNumber( elem, value, subtract ) {\n	var matches = rnumsplit.exec( value );\n	return matches ?\n\n		// Guard against undefined "subtract", e.g., when used as in cssHooks\n		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :\n		value;\n}\n\nfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n	var i = extra === ( isBorderBox ? "border" : "content" ) ?\n\n		// If we already have the right measurement, avoid augmentation\n		4 :\n\n		// Otherwise initialize for horizontal or vertical properties\n		name === "width" ? 1 : 0,\n\n		val = 0;\n\n	for ( ; i < 4; i += 2 ) {\n\n		// both box models exclude margin, so add it if we want it\n		if ( extra === "margin" ) {\n			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n		}\n\n		if ( isBorderBox ) {\n\n			// border-box includes padding, so remove it if we want content\n			if ( extra === "content" ) {\n				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );\n			}\n\n			// at this point, extra isn\'t border nor margin, so remove border\n			if ( extra !== "margin" ) {\n				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );\n			}\n		} else {\n\n			// at this point, extra isn\'t content, so add padding\n			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );\n\n			// at this point, extra isn\'t content nor padding, so add border\n			if ( extra !== "padding" ) {\n				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );\n			}\n		}\n	}\n\n	return val;\n}\n\nfunction getWidthOrHeight( elem, name, extra ) {\n\n	// Start with offset property, which is equivalent to the border-box value\n	var valueIsBorderBox = true,\n		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,\n		styles = getStyles( elem ),\n		isBorderBox = support.boxSizing &&\n			jQuery.css( elem, "boxSizing", false, styles ) === "border-box";\n\n	// Support: IE11 only\n	// In IE 11 fullscreen elements inside of an iframe have\n	// 100x too small dimensions (gh-1764).\n	if ( document.msFullscreenElement && window.top !== window ) {\n\n		// Support: IE11 only\n		// Running getBoundingClientRect on a disconnected node\n		// in IE throws an error.\n		if ( elem.getClientRects().length ) {\n			val = Math.round( elem.getBoundingClientRect()[ name ] * 100 );\n		}\n	}\n\n	// some non-html elements return undefined for offsetWidth, so check for null/undefined\n	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n	if ( val <= 0 || val == null ) {\n\n		// Fall back to computed then uncomputed css if necessary\n		val = curCSS( elem, name, styles );\n		if ( val < 0 || val == null ) {\n			val = elem.style[ name ];\n		}\n\n		// Computed unit is not pixels. Stop here and return.\n		if ( rnumnonpx.test( val ) ) {\n			return val;\n		}\n\n		// we need the check for style in case a browser which returns unreliable values\n		// for getComputedStyle silently falls back to the reliable elem.style\n		valueIsBorderBox = isBorderBox &&\n			( support.boxSizingReliable() || val === elem.style[ name ] );\n\n		// Normalize "", auto, and prepare for extra\n		val = parseFloat( val ) || 0;\n	}\n\n	// use the active box-sizing model to add/subtract irrelevant styles\n	return ( val +\n		augmentWidthOrHeight(\n			elem,\n			name,\n			extra || ( isBorderBox ? "border" : "content" ),\n			valueIsBorderBox,\n			styles\n		)\n	) + "px";\n}\n\njQuery.extend( {\n\n	// Add in style property hooks for overriding the default\n	// behavior of getting and setting a style property\n	cssHooks: {\n		opacity: {\n			get: function( elem, computed ) {\n				if ( computed ) {\n\n					// We should always get a number back from opacity\n					var ret = curCSS( elem, "opacity" );\n					return ret === "" ? "1" : ret;\n				}\n			}\n		}\n	},\n\n	// Don\'t automatically add "px" to these possibly-unitless properties\n	cssNumber: {\n		"animationIterationCount": true,\n		"columnCount": true,\n		"fillOpacity": true,\n		"flexGrow": true,\n		"flexShrink": true,\n		"fontWeight": true,\n		"lineHeight": true,\n		"opacity": true,\n		"order": true,\n		"orphans": true,\n		"widows": true,\n		"zIndex": true,\n		"zoom": true\n	},\n\n	// Add in properties whose names you wish to fix before\n	// setting or getting the value\n	cssProps: {\n\n		// normalize float css property\n		"float": support.cssFloat ? "cssFloat" : "styleFloat"\n	},\n\n	// Get and set the style property on a DOM Node\n	style: function( elem, name, value, extra ) {\n\n		// Don\'t set styles on text and comment nodes\n		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n			return;\n		}\n\n		// Make sure that we\'re working with the right name\n		var ret, type, hooks,\n			origName = jQuery.camelCase( name ),\n			style = elem.style;\n\n		name = jQuery.cssProps[ origName ] ||\n			( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );\n\n		// gets hook for the prefixed version\n		// followed by the unprefixed version\n		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n		// Check if we\'re setting a value\n		if ( value !== undefined ) {\n			type = typeof value;\n\n			// Convert "+=" or "-=" to relative numbers (#7345)\n			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\n				value = adjustCSS( elem, name, ret );\n\n				// Fixes bug #9237\n				type = "number";\n			}\n\n			// Make sure that null and NaN values aren\'t set. See: #7116\n			if ( value == null || value !== value ) {\n				return;\n			}\n\n			// If a number was passed in, add the unit (except for certain CSS properties)\n			if ( type === "number" ) {\n				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );\n			}\n\n			// Fixes #8908, it can be done more correctly by specifing setters in cssHooks,\n			// but it would mean to define eight\n			// (for every problematic property) identical functions\n			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {\n				style[ name ] = "inherit";\n			}\n\n			// If a hook was provided, use that value, otherwise just set the specified value\n			if ( !hooks || !( "set" in hooks ) ||\n				( value = hooks.set( elem, value, extra ) ) !== undefined ) {\n\n				// Support: IE\n				// Swallow errors from \'invalid\' CSS values (#5509)\n				try {\n					style[ name ] = value;\n				} catch ( e ) {}\n			}\n\n		} else {\n\n			// If a hook was provided get the non-computed value from there\n			if ( hooks && "get" in hooks &&\n				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\n\n				return ret;\n			}\n\n			// Otherwise just get the value from the style object\n			return style[ name ];\n		}\n	},\n\n	css: function( elem, name, extra, styles ) {\n		var num, val, hooks,\n			origName = jQuery.camelCase( name );\n\n		// Make sure that we\'re working with the right name\n		name = jQuery.cssProps[ origName ] ||\n			( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );\n\n		// gets hook for the prefixed version\n		// followed by the unprefixed version\n		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n		// If a hook was provided get the computed value from there\n		if ( hooks && "get" in hooks ) {\n			val = hooks.get( elem, true, extra );\n		}\n\n		// Otherwise, if a way to get the computed value exists, use that\n		if ( val === undefined ) {\n			val = curCSS( elem, name, styles );\n		}\n\n		//convert "normal" to computed value\n		if ( val === "normal" && name in cssNormalTransform ) {\n			val = cssNormalTransform[ name ];\n		}\n\n		// Return, converting to number if forced or a qualifier was provided and val looks numeric\n		if ( extra === "" || extra ) {\n			num = parseFloat( val );\n			return extra === true || isFinite( num ) ? num || 0 : val;\n		}\n		return val;\n	}\n} );\n\njQuery.each( [ "height", "width" ], function( i, name ) {\n	jQuery.cssHooks[ name ] = {\n		get: function( elem, computed, extra ) {\n			if ( computed ) {\n\n				// certain elements can have dimension info if we invisibly show them\n				// however, it must have a current display style that would benefit from this\n				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&\n					elem.offsetWidth === 0 ?\n						swap( elem, cssShow, function() {\n							return getWidthOrHeight( elem, name, extra );\n						} ) :\n						getWidthOrHeight( elem, name, extra );\n			}\n		},\n\n		set: function( elem, value, extra ) {\n			var styles = extra && getStyles( elem );\n			return setPositiveNumber( elem, value, extra ?\n				augmentWidthOrHeight(\n					elem,\n					name,\n					extra,\n					support.boxSizing &&\n						jQuery.css( elem, "boxSizing", false, styles ) === "border-box",\n					styles\n				) : 0\n			);\n		}\n	};\n} );\n\nif ( !support.opacity ) {\n	jQuery.cssHooks.opacity = {\n		get: function( elem, computed ) {\n\n			// IE uses filters for opacity\n			return ropacity.test( ( computed && elem.currentStyle ?\n				elem.currentStyle.filter :\n				elem.style.filter ) || "" ) ?\n					( 0.01 * parseFloat( RegExp.$1 ) ) + "" :\n					computed ? "1" : "";\n		},\n\n		set: function( elem, value ) {\n			var style = elem.style,\n				currentStyle = elem.currentStyle,\n				opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",\n				filter = currentStyle && currentStyle.filter || style.filter || "";\n\n			// IE has trouble with opacity if it does not have layout\n			// Force it by setting the zoom level\n			style.zoom = 1;\n\n			// if setting opacity to 1, and no other filters exist -\n			// attempt to remove filter attribute #6652\n			// if value === "", then remove inline opacity #12685\n			if ( ( value >= 1 || value === "" ) &&\n					jQuery.trim( filter.replace( ralpha, "" ) ) === "" &&\n					style.removeAttribute ) {\n\n				// Setting style.filter to null, "" & " " still leave "filter:" in the cssText\n				// if "filter:" is present at all, clearType is disabled, we want to avoid this\n				// style.removeAttribute is IE Only, but so apparently is this code path...\n				style.removeAttribute( "filter" );\n\n				// if there is no filter style applied in a css rule\n				// or unset inline opacity, we are done\n				if ( value === "" || currentStyle && !currentStyle.filter ) {\n					return;\n				}\n			}\n\n			// otherwise, set new filter values\n			style.filter = ralpha.test( filter ) ?\n				filter.replace( ralpha, opacity ) :\n				filter + " " + opacity;\n		}\n	};\n}\n\njQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,\n	function( elem, computed ) {\n		if ( computed ) {\n			return swap( elem, { "display": "inline-block" },\n				curCSS, [ elem, "marginRight" ] );\n		}\n	}\n);\n\njQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\n	function( elem, computed ) {\n		if ( computed ) {\n			return (\n				parseFloat( curCSS( elem, "marginLeft" ) ) ||\n\n				// Support: IE<=11+\n				// Running getBoundingClientRect on a disconnected node in IE throws an error\n				// Support: IE8 only\n				// getClientRects() errors on disconnected elems\n				( jQuery.contains( elem.ownerDocument, elem ) ?\n					elem.getBoundingClientRect().left -\n						swap( elem, { marginLeft: 0 }, function() {\n							return elem.getBoundingClientRect().left;\n						} ) :\n					0\n				)\n			) + "px";\n		}\n	}\n);\n\n// These hooks are used by animate to expand properties\njQuery.each( {\n	margin: "",\n	padding: "",\n	border: "Width"\n}, function( prefix, suffix ) {\n	jQuery.cssHooks[ prefix + suffix ] = {\n		expand: function( value ) {\n			var i = 0,\n				expanded = {},\n\n				// assumes a single number if not a string\n				parts = typeof value === "string" ? value.split( " " ) : [ value ];\n\n			for ( ; i < 4; i++ ) {\n				expanded[ prefix + cssExpand[ i ] + suffix ] =\n					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n			}\n\n			return expanded;\n		}\n	};\n\n	if ( !rmargin.test( prefix ) ) {\n		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n	}\n} );\n\njQuery.fn.extend( {\n	css: function( name, value ) {\n		return access( this, function( elem, name, value ) {\n			var styles, len,\n				map = {},\n				i = 0;\n\n			if ( jQuery.isArray( name ) ) {\n				styles = getStyles( elem );\n				len = name.length;\n\n				for ( ; i < len; i++ ) {\n					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n				}\n\n				return map;\n			}\n\n			return value !== undefined ?\n				jQuery.style( elem, name, value ) :\n				jQuery.css( elem, name );\n		}, name, value, arguments.length > 1 );\n	},\n	show: function() {\n		return showHide( this, true );\n	},\n	hide: function() {\n		return showHide( this );\n	},\n	toggle: function( state ) {\n		if ( typeof state === "boolean" ) {\n			return state ? this.show() : this.hide();\n		}\n\n		return this.each( function() {\n			if ( isHidden( this ) ) {\n				jQuery( this ).show();\n			} else {\n				jQuery( this ).hide();\n			}\n		} );\n	}\n} );\n\n\nfunction Tween( elem, options, prop, end, easing ) {\n	return new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n	constructor: Tween,\n	init: function( elem, options, prop, end, easing, unit ) {\n		this.elem = elem;\n		this.prop = prop;\n		this.easing = easing || jQuery.easing._default;\n		this.options = options;\n		this.start = this.now = this.cur();\n		this.end = end;\n		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );\n	},\n	cur: function() {\n		var hooks = Tween.propHooks[ this.prop ];\n\n		return hooks && hooks.get ?\n			hooks.get( this ) :\n			Tween.propHooks._default.get( this );\n	},\n	run: function( percent ) {\n		var eased,\n			hooks = Tween.propHooks[ this.prop ];\n\n		if ( this.options.duration ) {\n			this.pos = eased = jQuery.easing[ this.easing ](\n				percent, this.options.duration * percent, 0, 1, this.options.duration\n			);\n		} else {\n			this.pos = eased = percent;\n		}\n		this.now = ( this.end - this.start ) * eased + this.start;\n\n		if ( this.options.step ) {\n			this.options.step.call( this.elem, this.now, this );\n		}\n\n		if ( hooks && hooks.set ) {\n			hooks.set( this );\n		} else {\n			Tween.propHooks._default.set( this );\n		}\n		return this;\n	}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n	_default: {\n		get: function( tween ) {\n			var result;\n\n			// Use a property on the element directly when it is not a DOM element,\n			// or when there is no matching style property that exists.\n			if ( tween.elem.nodeType !== 1 ||\n				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\n				return tween.elem[ tween.prop ];\n			}\n\n			// passing an empty string as a 3rd parameter to .css will automatically\n			// attempt a parseFloat and fallback to a string if the parse fails\n			// so, simple values such as "10px" are parsed to Float.\n			// complex values such as "rotate(1rad)" are returned as is.\n			result = jQuery.css( tween.elem, tween.prop, "" );\n\n			// Empty strings, null, undefined and "auto" are converted to 0.\n			return !result || result === "auto" ? 0 : result;\n		},\n		set: function( tween ) {\n\n			// use step hook for back compat - use cssHook if its there - use .style if its\n			// available and use plain properties where available\n			if ( jQuery.fx.step[ tween.prop ] ) {\n				jQuery.fx.step[ tween.prop ]( tween );\n			} else if ( tween.elem.nodeType === 1 &&\n				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||\n					jQuery.cssHooks[ tween.prop ] ) ) {\n				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n			} else {\n				tween.elem[ tween.prop ] = tween.now;\n			}\n		}\n	}\n};\n\n// Support: IE <=9\n// Panic based approach to setting things on disconnected nodes\n\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n	set: function( tween ) {\n		if ( tween.elem.nodeType && tween.elem.parentNode ) {\n			tween.elem[ tween.prop ] = tween.now;\n		}\n	}\n};\n\njQuery.easing = {\n	linear: function( p ) {\n		return p;\n	},\n	swing: function( p ) {\n		return 0.5 - Math.cos( p * Math.PI ) / 2;\n	},\n	_default: "swing"\n};\n\njQuery.fx = Tween.prototype.init;\n\n// Back Compat <1.8 extension point\njQuery.fx.step = {};\n\n\n\n\nvar\n	fxNow, timerId,\n	rfxtypes = /^(?:toggle|show|hide)$/,\n	rrun = /queueHooks$/;\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n	window.setTimeout( function() {\n		fxNow = undefined;\n	} );\n	return ( fxNow = jQuery.now() );\n}\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n	var which,\n		attrs = { height: type },\n		i = 0;\n\n	// if we include width, step value is 1 to do all cssExpand values,\n	// if we don\'t include width, step value is 2 to skip over Left and Right\n	includeWidth = includeWidth ? 1 : 0;\n	for ( ; i < 4 ; i += 2 - includeWidth ) {\n		which = cssExpand[ i ];\n		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;\n	}\n\n	if ( includeWidth ) {\n		attrs.opacity = attrs.width = type;\n	}\n\n	return attrs;\n}\n\nfunction createTween( value, prop, animation ) {\n	var tween,\n		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),\n		index = 0,\n		length = collection.length;\n	for ( ; index < length; index++ ) {\n		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\n\n			// we\'re done with this property\n			return tween;\n		}\n	}\n}\n\nfunction defaultPrefilter( elem, props, opts ) {\n	/* jshint validthis: true */\n	var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,\n		anim = this,\n		orig = {},\n		style = elem.style,\n		hidden = elem.nodeType && isHidden( elem ),\n		dataShow = jQuery._data( elem, "fxshow" );\n\n	// handle queue: false promises\n	if ( !opts.queue ) {\n		hooks = jQuery._queueHooks( elem, "fx" );\n		if ( hooks.unqueued == null ) {\n			hooks.unqueued = 0;\n			oldfire = hooks.empty.fire;\n			hooks.empty.fire = function() {\n				if ( !hooks.unqueued ) {\n					oldfire();\n				}\n			};\n		}\n		hooks.unqueued++;\n\n		anim.always( function() {\n\n			// doing this makes sure that the complete handler will be called\n			// before this completes\n			anim.always( function() {\n				hooks.unqueued--;\n				if ( !jQuery.queue( elem, "fx" ).length ) {\n					hooks.empty.fire();\n				}\n			} );\n		} );\n	}\n\n	// height/width overflow pass\n	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {\n\n		// Make sure that nothing sneaks out\n		// Record all 3 overflow attributes because IE does not\n		// change the overflow attribute when overflowX and\n		// overflowY are set to the same value\n		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n		// Set display property to inline-block for height/width\n		// animations on inline elements that are having width/height animated\n		display = jQuery.css( elem, "display" );\n\n		// Test default display if display is currently "none"\n		checkDisplay = display === "none" ?\n			jQuery._data( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;\n\n		if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {\n\n			// inline-level elements accept inline-block;\n			// block-level elements need to be inline with layout\n			if ( !support.inlineBlockNeedsLayout || defaultDisplay( elem.nodeName ) === "inline" ) {\n				style.display = "inline-block";\n			} else {\n				style.zoom = 1;\n			}\n		}\n	}\n\n	if ( opts.overflow ) {\n		style.overflow = "hidden";\n		if ( !support.shrinkWrapBlocks() ) {\n			anim.always( function() {\n				style.overflow = opts.overflow[ 0 ];\n				style.overflowX = opts.overflow[ 1 ];\n				style.overflowY = opts.overflow[ 2 ];\n			} );\n		}\n	}\n\n	// show/hide pass\n	for ( prop in props ) {\n		value = props[ prop ];\n		if ( rfxtypes.exec( value ) ) {\n			delete props[ prop ];\n			toggle = toggle || value === "toggle";\n			if ( value === ( hidden ? "hide" : "show" ) ) {\n\n				// If there is dataShow left over from a stopped hide or show\n				// and we are going to proceed with show, we should pretend to be hidden\n				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {\n					hidden = true;\n				} else {\n					continue;\n				}\n			}\n			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\n		// Any non-fx value stops us from restoring the original display value\n		} else {\n			display = undefined;\n		}\n	}\n\n	if ( !jQuery.isEmptyObject( orig ) ) {\n		if ( dataShow ) {\n			if ( "hidden" in dataShow ) {\n				hidden = dataShow.hidden;\n			}\n		} else {\n			dataShow = jQuery._data( elem, "fxshow", {} );\n		}\n\n		// store state if its toggle - enables .stop().toggle() to "reverse"\n		if ( toggle ) {\n			dataShow.hidden = !hidden;\n		}\n		if ( hidden ) {\n			jQuery( elem ).show();\n		} else {\n			anim.done( function() {\n				jQuery( elem ).hide();\n			} );\n		}\n		anim.done( function() {\n			var prop;\n			jQuery._removeData( elem, "fxshow" );\n			for ( prop in orig ) {\n				jQuery.style( elem, prop, orig[ prop ] );\n			}\n		} );\n		for ( prop in orig ) {\n			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\n			if ( !( prop in dataShow ) ) {\n				dataShow[ prop ] = tween.start;\n				if ( hidden ) {\n					tween.end = tween.start;\n					tween.start = prop === "width" || prop === "height" ? 1 : 0;\n				}\n			}\n		}\n\n	// If this is a noop like .hide().hide(), restore an overwritten display value\n	} else if ( ( display === "none" ? defaultDisplay( elem.nodeName ) : display ) === "inline" ) {\n		style.display = display;\n	}\n}\n\nfunction propFilter( props, specialEasing ) {\n	var index, name, easing, value, hooks;\n\n	// camelCase, specialEasing and expand cssHook pass\n	for ( index in props ) {\n		name = jQuery.camelCase( index );\n		easing = specialEasing[ name ];\n		value = props[ index ];\n		if ( jQuery.isArray( value ) ) {\n			easing = value[ 1 ];\n			value = props[ index ] = value[ 0 ];\n		}\n\n		if ( index !== name ) {\n			props[ name ] = value;\n			delete props[ index ];\n		}\n\n		hooks = jQuery.cssHooks[ name ];\n		if ( hooks && "expand" in hooks ) {\n			value = hooks.expand( value );\n			delete props[ name ];\n\n			// not quite $.extend, this wont overwrite keys already present.\n			// also - reusing \'index\' from above because we have the correct "name"\n			for ( index in value ) {\n				if ( !( index in props ) ) {\n					props[ index ] = value[ index ];\n					specialEasing[ index ] = easing;\n				}\n			}\n		} else {\n			specialEasing[ name ] = easing;\n		}\n	}\n}\n\nfunction Animation( elem, properties, options ) {\n	var result,\n		stopped,\n		index = 0,\n		length = Animation.prefilters.length,\n		deferred = jQuery.Deferred().always( function() {\n\n			// don\'t match elem in the :animated selector\n			delete tick.elem;\n		} ),\n		tick = function() {\n			if ( stopped ) {\n				return false;\n			}\n			var currentTime = fxNow || createFxNow(),\n				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\n				// Support: Android 2.3\n				// Archaic crash bug won\'t allow us to use `1 - ( 0.5 || 0 )` (#12497)\n				temp = remaining / animation.duration || 0,\n				percent = 1 - temp,\n				index = 0,\n				length = animation.tweens.length;\n\n			for ( ; index < length ; index++ ) {\n				animation.tweens[ index ].run( percent );\n			}\n\n			deferred.notifyWith( elem, [ animation, percent, remaining ] );\n\n			if ( percent < 1 && length ) {\n				return remaining;\n			} else {\n				deferred.resolveWith( elem, [ animation ] );\n				return false;\n			}\n		},\n		animation = deferred.promise( {\n			elem: elem,\n			props: jQuery.extend( {}, properties ),\n			opts: jQuery.extend( true, {\n				specialEasing: {},\n				easing: jQuery.easing._default\n			}, options ),\n			originalProperties: properties,\n			originalOptions: options,\n			startTime: fxNow || createFxNow(),\n			duration: options.duration,\n			tweens: [],\n			createTween: function( prop, end ) {\n				var tween = jQuery.Tween( elem, animation.opts, prop, end,\n						animation.opts.specialEasing[ prop ] || animation.opts.easing );\n				animation.tweens.push( tween );\n				return tween;\n			},\n			stop: function( gotoEnd ) {\n				var index = 0,\n\n					// if we are going to the end, we want to run all the tweens\n					// otherwise we skip this part\n					length = gotoEnd ? animation.tweens.length : 0;\n				if ( stopped ) {\n					return this;\n				}\n				stopped = true;\n				for ( ; index < length ; index++ ) {\n					animation.tweens[ index ].run( 1 );\n				}\n\n				// resolve when we played the last frame\n				// otherwise, reject\n				if ( gotoEnd ) {\n					deferred.notifyWith( elem, [ animation, 1, 0 ] );\n					deferred.resolveWith( elem, [ animation, gotoEnd ] );\n				} else {\n					deferred.rejectWith( elem, [ animation, gotoEnd ] );\n				}\n				return this;\n			}\n		} ),\n		props = animation.props;\n\n	propFilter( props, animation.opts.specialEasing );\n\n	for ( ; index < length ; index++ ) {\n		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\n		if ( result ) {\n			if ( jQuery.isFunction( result.stop ) ) {\n				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\n					jQuery.proxy( result.stop, result );\n			}\n			return result;\n		}\n	}\n\n	jQuery.map( props, createTween, animation );\n\n	if ( jQuery.isFunction( animation.opts.start ) ) {\n		animation.opts.start.call( elem, animation );\n	}\n\n	jQuery.fx.timer(\n		jQuery.extend( tick, {\n			elem: elem,\n			anim: animation,\n			queue: animation.opts.queue\n		} )\n	);\n\n	// attach callbacks from options\n	return animation.progress( animation.opts.progress )\n		.done( animation.opts.done, animation.opts.complete )\n		.fail( animation.opts.fail )\n		.always( animation.opts.always );\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n	tweeners: {\n		"*": [ function( prop, value ) {\n			var tween = this.createTween( prop, value );\n			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\n			return tween;\n		} ]\n	},\n\n	tweener: function( props, callback ) {\n		if ( jQuery.isFunction( props ) ) {\n			callback = props;\n			props = [ "*" ];\n		} else {\n			props = props.match( rnotwhite );\n		}\n\n		var prop,\n			index = 0,\n			length = props.length;\n\n		for ( ; index < length ; index++ ) {\n			prop = props[ index ];\n			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\n			Animation.tweeners[ prop ].unshift( callback );\n		}\n	},\n\n	prefilters: [ defaultPrefilter ],\n\n	prefilter: function( callback, prepend ) {\n		if ( prepend ) {\n			Animation.prefilters.unshift( callback );\n		} else {\n			Animation.prefilters.push( callback );\n		}\n	}\n} );\n\njQuery.speed = function( speed, easing, fn ) {\n	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {\n		complete: fn || !fn && easing ||\n			jQuery.isFunction( speed ) && speed,\n		duration: speed,\n		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n	};\n\n	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :\n		opt.duration in jQuery.fx.speeds ?\n			jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;\n\n	// normalize opt.queue - true/undefined/null -> "fx"\n	if ( opt.queue == null || opt.queue === true ) {\n		opt.queue = "fx";\n	}\n\n	// Queueing\n	opt.old = opt.complete;\n\n	opt.complete = function() {\n		if ( jQuery.isFunction( opt.old ) ) {\n			opt.old.call( this );\n		}\n\n		if ( opt.queue ) {\n			jQuery.dequeue( this, opt.queue );\n		}\n	};\n\n	return opt;\n};\n\njQuery.fn.extend( {\n	fadeTo: function( speed, to, easing, callback ) {\n\n		// show any hidden elements after setting opacity to 0\n		return this.filter( isHidden ).css( "opacity", 0 ).show()\n\n			// animate to the value specified\n			.end().animate( { opacity: to }, speed, easing, callback );\n	},\n	animate: function( prop, speed, easing, callback ) {\n		var empty = jQuery.isEmptyObject( prop ),\n			optall = jQuery.speed( speed, easing, callback ),\n			doAnimation = function() {\n\n				// Operate on a copy of prop so per-property easing won\'t be lost\n				var anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n				// Empty animations, or finishing resolves immediately\n				if ( empty || jQuery._data( this, "finish" ) ) {\n					anim.stop( true );\n				}\n			};\n			doAnimation.finish = doAnimation;\n\n		return empty || optall.queue === false ?\n			this.each( doAnimation ) :\n			this.queue( optall.queue, doAnimation );\n	},\n	stop: function( type, clearQueue, gotoEnd ) {\n		var stopQueue = function( hooks ) {\n			var stop = hooks.stop;\n			delete hooks.stop;\n			stop( gotoEnd );\n		};\n\n		if ( typeof type !== "string" ) {\n			gotoEnd = clearQueue;\n			clearQueue = type;\n			type = undefined;\n		}\n		if ( clearQueue && type !== false ) {\n			this.queue( type || "fx", [] );\n		}\n\n		return this.each( function() {\n			var dequeue = true,\n				index = type != null && type + "queueHooks",\n				timers = jQuery.timers,\n				data = jQuery._data( this );\n\n			if ( index ) {\n				if ( data[ index ] && data[ index ].stop ) {\n					stopQueue( data[ index ] );\n				}\n			} else {\n				for ( index in data ) {\n					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n						stopQueue( data[ index ] );\n					}\n				}\n			}\n\n			for ( index = timers.length; index--; ) {\n				if ( timers[ index ].elem === this &&\n					( type == null || timers[ index ].queue === type ) ) {\n\n					timers[ index ].anim.stop( gotoEnd );\n					dequeue = false;\n					timers.splice( index, 1 );\n				}\n			}\n\n			// start the next in the queue if the last step wasn\'t forced\n			// timers currently will call their complete callbacks, which will dequeue\n			// but only if they were gotoEnd\n			if ( dequeue || !gotoEnd ) {\n				jQuery.dequeue( this, type );\n			}\n		} );\n	},\n	finish: function( type ) {\n		if ( type !== false ) {\n			type = type || "fx";\n		}\n		return this.each( function() {\n			var index,\n				data = jQuery._data( this ),\n				queue = data[ type + "queue" ],\n				hooks = data[ type + "queueHooks" ],\n				timers = jQuery.timers,\n				length = queue ? queue.length : 0;\n\n			// enable finishing flag on private data\n			data.finish = true;\n\n			// empty the queue first\n			jQuery.queue( this, type, [] );\n\n			if ( hooks && hooks.stop ) {\n				hooks.stop.call( this, true );\n			}\n\n			// look for any active animations, and finish them\n			for ( index = timers.length; index--; ) {\n				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n					timers[ index ].anim.stop( true );\n					timers.splice( index, 1 );\n				}\n			}\n\n			// look for any animations in the old queue and finish them\n			for ( index = 0; index < length; index++ ) {\n				if ( queue[ index ] && queue[ index ].finish ) {\n					queue[ index ].finish.call( this );\n				}\n			}\n\n			// turn off finishing flag\n			delete data.finish;\n		} );\n	}\n} );\n\njQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {\n	var cssFn = jQuery.fn[ name ];\n	jQuery.fn[ name ] = function( speed, easing, callback ) {\n		return speed == null || typeof speed === "boolean" ?\n			cssFn.apply( this, arguments ) :\n			this.animate( genFx( name, true ), speed, easing, callback );\n	};\n} );\n\n// Generate shortcuts for custom animations\njQuery.each( {\n	slideDown: genFx( "show" ),\n	slideUp: genFx( "hide" ),\n	slideToggle: genFx( "toggle" ),\n	fadeIn: { opacity: "show" },\n	fadeOut: { opacity: "hide" },\n	fadeToggle: { opacity: "toggle" }\n}, function( name, props ) {\n	jQuery.fn[ name ] = function( speed, easing, callback ) {\n		return this.animate( props, speed, easing, callback );\n	};\n} );\n\njQuery.timers = [];\njQuery.fx.tick = function() {\n	var timer,\n		timers = jQuery.timers,\n		i = 0;\n\n	fxNow = jQuery.now();\n\n	for ( ; i < timers.length; i++ ) {\n		timer = timers[ i ];\n\n		// Checks the timer has not already been removed\n		if ( !timer() && timers[ i ] === timer ) {\n			timers.splice( i--, 1 );\n		}\n	}\n\n	if ( !timers.length ) {\n		jQuery.fx.stop();\n	}\n	fxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n	jQuery.timers.push( timer );\n	if ( timer() ) {\n		jQuery.fx.start();\n	} else {\n		jQuery.timers.pop();\n	}\n};\n\njQuery.fx.interval = 13;\n\njQuery.fx.start = function() {\n	if ( !timerId ) {\n		timerId = window.setInterval( jQuery.fx.tick, jQuery.fx.interval );\n	}\n};\n\njQuery.fx.stop = function() {\n	window.clearInterval( timerId );\n	timerId = null;\n};\n\njQuery.fx.speeds = {\n	slow: 600,\n	fast: 200,\n\n	// Default speed\n	_default: 400\n};\n\n\n// Based off of the plugin by Clint Helfers, with permission.\n// http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\njQuery.fn.delay = function( time, type ) {\n	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n	type = type || "fx";\n\n	return this.queue( type, function( next, hooks ) {\n		var timeout = window.setTimeout( next, time );\n		hooks.stop = function() {\n			window.clearTimeout( timeout );\n		};\n	} );\n};\n\n\n( function() {\n	var a,\n		input = document.createElement( "input" ),\n		div = document.createElement( "div" ),\n		select = document.createElement( "select" ),\n		opt = select.appendChild( document.createElement( "option" ) );\n\n	// Setup\n	div = document.createElement( "div" );\n	div.setAttribute( "className", "t" );\n	div.innerHTML = "  <link/><table></table><a href=\'/a\'>a</a><input type=\'checkbox\'/>";\n	a = div.getElementsByTagName( "a" )[ 0 ];\n\n	// Support: Windows Web Apps (WWA)\n	// `type` must use .setAttribute for WWA (#14901)\n	input.setAttribute( "type", "checkbox" );\n	div.appendChild( input );\n\n	a = div.getElementsByTagName( "a" )[ 0 ];\n\n	// First batch of tests.\n	a.style.cssText = "top:1px";\n\n	// Test setAttribute on camelCase class.\n	// If it works, we need attrFixes when doing get/setAttribute (ie6/7)\n	support.getSetAttribute = div.className !== "t";\n\n	// Get the style information from getAttribute\n	// (IE uses .cssText instead)\n	support.style = /top/.test( a.getAttribute( "style" ) );\n\n	// Make sure that URLs aren\'t manipulated\n	// (IE normalizes it by default)\n	support.hrefNormalized = a.getAttribute( "href" ) === "/a";\n\n	// Check the default checkbox/radio value ("" on WebKit; "on" elsewhere)\n	support.checkOn = !!input.value;\n\n	// Make sure that a selected-by-default option has a working selected property.\n	// (WebKit defaults to false instead of true, IE too, if it\'s in an optgroup)\n	support.optSelected = opt.selected;\n\n	// Tests for enctype support on a form (#6743)\n	support.enctype = !!document.createElement( "form" ).enctype;\n\n	// Make sure that the options inside disabled selects aren\'t marked as disabled\n	// (WebKit marks them as disabled)\n	select.disabled = true;\n	support.optDisabled = !opt.disabled;\n\n	// Support: IE8 only\n	// Check if we can trust getAttribute("value")\n	input = document.createElement( "input" );\n	input.setAttribute( "value", "" );\n	support.input = input.getAttribute( "value" ) === "";\n\n	// Check if an input maintains its value after becoming a radio\n	input.value = "t";\n	input.setAttribute( "type", "radio" );\n	support.radioValue = input.value === "t";\n} )();\n\n\nvar rreturn = /\\r/g,\n	rspaces = /[\\x20\\t\\r\\n\\f]+/g;\n\njQuery.fn.extend( {\n	val: function( value ) {\n		var hooks, ret, isFunction,\n			elem = this[ 0 ];\n\n		if ( !arguments.length ) {\n			if ( elem ) {\n				hooks = jQuery.valHooks[ elem.type ] ||\n					jQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n				if (\n					hooks &&\n					"get" in hooks &&\n					( ret = hooks.get( elem, "value" ) ) !== undefined\n				) {\n					return ret;\n				}\n\n				ret = elem.value;\n\n				return typeof ret === "string" ?\n\n					// handle most common string cases\n					ret.replace( rreturn, "" ) :\n\n					// handle cases where value is null/undef or number\n					ret == null ? "" : ret;\n			}\n\n			return;\n		}\n\n		isFunction = jQuery.isFunction( value );\n\n		return this.each( function( i ) {\n			var val;\n\n			if ( this.nodeType !== 1 ) {\n				return;\n			}\n\n			if ( isFunction ) {\n				val = value.call( this, i, jQuery( this ).val() );\n			} else {\n				val = value;\n			}\n\n			// Treat null/undefined as ""; convert numbers to string\n			if ( val == null ) {\n				val = "";\n			} else if ( typeof val === "number" ) {\n				val += "";\n			} else if ( jQuery.isArray( val ) ) {\n				val = jQuery.map( val, function( value ) {\n					return value == null ? "" : value + "";\n				} );\n			}\n\n			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n			// If set returns undefined, fall back to normal setting\n			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {\n				this.value = val;\n			}\n		} );\n	}\n} );\n\njQuery.extend( {\n	valHooks: {\n		option: {\n			get: function( elem ) {\n				var val = jQuery.find.attr( elem, "value" );\n				return val != null ?\n					val :\n\n					// Support: IE10-11+\n					// option.text throws exceptions (#14686, #14858)\n					// Strip and collapse whitespace\n					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n					jQuery.trim( jQuery.text( elem ) ).replace( rspaces, " " );\n			}\n		},\n		select: {\n			get: function( elem ) {\n				var value, option,\n					options = elem.options,\n					index = elem.selectedIndex,\n					one = elem.type === "select-one" || index < 0,\n					values = one ? null : [],\n					max = one ? index + 1 : options.length,\n					i = index < 0 ?\n						max :\n						one ? index : 0;\n\n				// Loop through all the selected options\n				for ( ; i < max; i++ ) {\n					option = options[ i ];\n\n					// oldIE doesn\'t update selected after form reset (#2551)\n					if ( ( option.selected || i === index ) &&\n\n							// Don\'t return options that are disabled or in a disabled optgroup\n							( support.optDisabled ?\n								!option.disabled :\n								option.getAttribute( "disabled" ) === null ) &&\n							( !option.parentNode.disabled ||\n								!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {\n\n						// Get the specific value for the option\n						value = jQuery( option ).val();\n\n						// We don\'t need an array for one selects\n						if ( one ) {\n							return value;\n						}\n\n						// Multi-Selects return an array\n						values.push( value );\n					}\n				}\n\n				return values;\n			},\n\n			set: function( elem, value ) {\n				var optionSet, option,\n					options = elem.options,\n					values = jQuery.makeArray( value ),\n					i = options.length;\n\n				while ( i-- ) {\n					option = options[ i ];\n\n					if ( jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1 ) {\n\n						// Support: IE6\n						// When new option element is added to select box we need to\n						// force reflow of newly added node in order to workaround delay\n						// of initialization properties\n						try {\n							option.selected = optionSet = true;\n\n						} catch ( _ ) {\n\n							// Will be executed only in IE6\n							option.scrollHeight;\n						}\n\n					} else {\n						option.selected = false;\n					}\n				}\n\n				// Force browsers to behave consistently when non-matching value is set\n				if ( !optionSet ) {\n					elem.selectedIndex = -1;\n				}\n\n				return options;\n			}\n		}\n	}\n} );\n\n// Radios and checkboxes getter/setter\njQuery.each( [ "radio", "checkbox" ], function() {\n	jQuery.valHooks[ this ] = {\n		set: function( elem, value ) {\n			if ( jQuery.isArray( value ) ) {\n				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\n			}\n		}\n	};\n	if ( !support.checkOn ) {\n		jQuery.valHooks[ this ].get = function( elem ) {\n			return elem.getAttribute( "value" ) === null ? "on" : elem.value;\n		};\n	}\n} );\n\n\n\n\nvar nodeHook, boolHook,\n	attrHandle = jQuery.expr.attrHandle,\n	ruseDefault = /^(?:checked|selected)$/i,\n	getSetAttribute = support.getSetAttribute,\n	getSetInput = support.input;\n\njQuery.fn.extend( {\n	attr: function( name, value ) {\n		return access( this, jQuery.attr, name, value, arguments.length > 1 );\n	},\n\n	removeAttr: function( name ) {\n		return this.each( function() {\n			jQuery.removeAttr( this, name );\n		} );\n	}\n} );\n\njQuery.extend( {\n	attr: function( elem, name, value ) {\n		var ret, hooks,\n			nType = elem.nodeType;\n\n		// Don\'t get/set attributes on text, comment and attribute nodes\n		if ( nType === 3 || nType === 8 || nType === 2 ) {\n			return;\n		}\n\n		// Fallback to prop when attributes are not supported\n		if ( typeof elem.getAttribute === "undefined" ) {\n			return jQuery.prop( elem, name, value );\n		}\n\n		// All attributes are lowercase\n		// Grab necessary hook if one is defined\n		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n			name = name.toLowerCase();\n			hooks = jQuery.attrHooks[ name ] ||\n				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );\n		}\n\n		if ( value !== undefined ) {\n			if ( value === null ) {\n				jQuery.removeAttr( elem, name );\n				return;\n			}\n\n			if ( hooks && "set" in hooks &&\n				( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n				return ret;\n			}\n\n			elem.setAttribute( name, value + "" );\n			return value;\n		}\n\n		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n			return ret;\n		}\n\n		ret = jQuery.find.attr( elem, name );\n\n		// Non-existent attributes return null, we normalize to undefined\n		return ret == null ? undefined : ret;\n	},\n\n	attrHooks: {\n		type: {\n			set: function( elem, value ) {\n				if ( !support.radioValue && value === "radio" &&\n					jQuery.nodeName( elem, "input" ) ) {\n\n					// Setting the type on a radio button after the value resets the value in IE8-9\n					// Reset value to default in case type is set after value during creation\n					var val = elem.value;\n					elem.setAttribute( "type", value );\n					if ( val ) {\n						elem.value = val;\n					}\n					return value;\n				}\n			}\n		}\n	},\n\n	removeAttr: function( elem, value ) {\n		var name, propName,\n			i = 0,\n			attrNames = value && value.match( rnotwhite );\n\n		if ( attrNames && elem.nodeType === 1 ) {\n			while ( ( name = attrNames[ i++ ] ) ) {\n				propName = jQuery.propFix[ name ] || name;\n\n				// Boolean attributes get special treatment (#10870)\n				if ( jQuery.expr.match.bool.test( name ) ) {\n\n					// Set corresponding property to false\n					if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {\n						elem[ propName ] = false;\n\n					// Support: IE<9\n					// Also clear defaultChecked/defaultSelected (if appropriate)\n					} else {\n						elem[ jQuery.camelCase( "default-" + name ) ] =\n							elem[ propName ] = false;\n					}\n\n				// See #9699 for explanation of this approach (setting first, then removal)\n				} else {\n					jQuery.attr( elem, name, "" );\n				}\n\n				elem.removeAttribute( getSetAttribute ? name : propName );\n			}\n		}\n	}\n} );\n\n// Hooks for boolean attributes\nboolHook = {\n	set: function( elem, value, name ) {\n		if ( value === false ) {\n\n			// Remove boolean attributes when set to false\n			jQuery.removeAttr( elem, name );\n		} else if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {\n\n			// IE<8 needs the *property* name\n			elem.setAttribute( !getSetAttribute && jQuery.propFix[ name ] || name, name );\n\n		} else {\n\n			// Support: IE<9\n			// Use defaultChecked and defaultSelected for oldIE\n			elem[ jQuery.camelCase( "default-" + name ) ] = elem[ name ] = true;\n		}\n		return name;\n	}\n};\n\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n	var getter = attrHandle[ name ] || jQuery.find.attr;\n\n	if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {\n		attrHandle[ name ] = function( elem, name, isXML ) {\n			var ret, handle;\n			if ( !isXML ) {\n\n				// Avoid an infinite loop by temporarily removing this function from the getter\n				handle = attrHandle[ name ];\n				attrHandle[ name ] = ret;\n				ret = getter( elem, name, isXML ) != null ?\n					name.toLowerCase() :\n					null;\n				attrHandle[ name ] = handle;\n			}\n			return ret;\n		};\n	} else {\n		attrHandle[ name ] = function( elem, name, isXML ) {\n			if ( !isXML ) {\n				return elem[ jQuery.camelCase( "default-" + name ) ] ?\n					name.toLowerCase() :\n					null;\n			}\n		};\n	}\n} );\n\n// fix oldIE attroperties\nif ( !getSetInput || !getSetAttribute ) {\n	jQuery.attrHooks.value = {\n		set: function( elem, value, name ) {\n			if ( jQuery.nodeName( elem, "input" ) ) {\n\n				// Does not return so that setAttribute is also used\n				elem.defaultValue = value;\n			} else {\n\n				// Use nodeHook if defined (#1954); otherwise setAttribute is fine\n				return nodeHook && nodeHook.set( elem, value, name );\n			}\n		}\n	};\n}\n\n// IE6/7 do not support getting/setting some attributes with get/setAttribute\nif ( !getSetAttribute ) {\n\n	// Use this for any attribute in IE6/7\n	// This fixes almost every IE6/7 issue\n	nodeHook = {\n		set: function( elem, value, name ) {\n\n			// Set the existing or create a new attribute node\n			var ret = elem.getAttributeNode( name );\n			if ( !ret ) {\n				elem.setAttributeNode(\n					( ret = elem.ownerDocument.createAttribute( name ) )\n				);\n			}\n\n			ret.value = value += "";\n\n			// Break association with cloned elements by also using setAttribute (#9646)\n			if ( name === "value" || value === elem.getAttribute( name ) ) {\n				return value;\n			}\n		}\n	};\n\n	// Some attributes are constructed with empty-string values when not defined\n	attrHandle.id = attrHandle.name = attrHandle.coords =\n		function( elem, name, isXML ) {\n			var ret;\n			if ( !isXML ) {\n				return ( ret = elem.getAttributeNode( name ) ) && ret.value !== "" ?\n					ret.value :\n					null;\n			}\n		};\n\n	// Fixing value retrieval on a button requires this module\n	jQuery.valHooks.button = {\n		get: function( elem, name ) {\n			var ret = elem.getAttributeNode( name );\n			if ( ret && ret.specified ) {\n				return ret.value;\n			}\n		},\n		set: nodeHook.set\n	};\n\n	// Set contenteditable to false on removals(#10429)\n	// Setting to empty string throws an error as an invalid value\n	jQuery.attrHooks.contenteditable = {\n		set: function( elem, value, name ) {\n			nodeHook.set( elem, value === "" ? false : value, name );\n		}\n	};\n\n	// Set width and height to auto instead of 0 on empty string( Bug #8150 )\n	// This is for removals\n	jQuery.each( [ "width", "height" ], function( i, name ) {\n		jQuery.attrHooks[ name ] = {\n			set: function( elem, value ) {\n				if ( value === "" ) {\n					elem.setAttribute( name, "auto" );\n					return value;\n				}\n			}\n		};\n	} );\n}\n\nif ( !support.style ) {\n	jQuery.attrHooks.style = {\n		get: function( elem ) {\n\n			// Return undefined in the case of empty string\n			// Note: IE uppercases css property names, but if we were to .toLowerCase()\n			// .cssText, that would destroy case sensitivity in URL\'s, like in "background"\n			return elem.style.cssText || undefined;\n		},\n		set: function( elem, value ) {\n			return ( elem.style.cssText = value + "" );\n		}\n	};\n}\n\n\n\n\nvar rfocusable = /^(?:input|select|textarea|button|object)$/i,\n	rclickable = /^(?:a|area)$/i;\n\njQuery.fn.extend( {\n	prop: function( name, value ) {\n		return access( this, jQuery.prop, name, value, arguments.length > 1 );\n	},\n\n	removeProp: function( name ) {\n		name = jQuery.propFix[ name ] || name;\n		return this.each( function() {\n\n			// try/catch handles cases where IE balks (such as removing a property on window)\n			try {\n				this[ name ] = undefined;\n				delete this[ name ];\n			} catch ( e ) {}\n		} );\n	}\n} );\n\njQuery.extend( {\n	prop: function( elem, name, value ) {\n		var ret, hooks,\n			nType = elem.nodeType;\n\n		// Don\'t get/set properties on text, comment and attribute nodes\n		if ( nType === 3 || nType === 8 || nType === 2 ) {\n			return;\n		}\n\n		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\n			// Fix name and attach hooks\n			name = jQuery.propFix[ name ] || name;\n			hooks = jQuery.propHooks[ name ];\n		}\n\n		if ( value !== undefined ) {\n			if ( hooks && "set" in hooks &&\n				( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n				return ret;\n			}\n\n			return ( elem[ name ] = value );\n		}\n\n		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n			return ret;\n		}\n\n		return elem[ name ];\n	},\n\n	propHooks: {\n		tabIndex: {\n			get: function( elem ) {\n\n				// elem.tabIndex doesn\'t always return the\n				// correct value when it hasn\'t been explicitly set\n				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n				// Use proper attribute retrieval(#12072)\n				var tabindex = jQuery.find.attr( elem, "tabindex" );\n\n				return tabindex ?\n					parseInt( tabindex, 10 ) :\n					rfocusable.test( elem.nodeName ) ||\n						rclickable.test( elem.nodeName ) && elem.href ?\n							0 :\n							-1;\n			}\n		}\n	},\n\n	propFix: {\n		"for": "htmlFor",\n		"class": "className"\n	}\n} );\n\n// Some attributes require a special call on IE\n// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !support.hrefNormalized ) {\n\n	// href/src property should get the full normalized URL (#10299/#12915)\n	jQuery.each( [ "href", "src" ], function( i, name ) {\n		jQuery.propHooks[ name ] = {\n			get: function( elem ) {\n				return elem.getAttribute( name, 4 );\n			}\n		};\n	} );\n}\n\n// Support: Safari, IE9+\n// Accessing the selectedIndex property\n// forces the browser to respect setting selected\n// on the option\n// The getter ensures a default option is selected\n// when in an optgroup\nif ( !support.optSelected ) {\n	jQuery.propHooks.selected = {\n		get: function( elem ) {\n			var parent = elem.parentNode;\n\n			if ( parent ) {\n				parent.selectedIndex;\n\n				// Make sure that it also works with optgroups, see #5701\n				if ( parent.parentNode ) {\n					parent.parentNode.selectedIndex;\n				}\n			}\n			return null;\n		},\n		set: function( elem ) {\n			var parent = elem.parentNode;\n			if ( parent ) {\n				parent.selectedIndex;\n\n				if ( parent.parentNode ) {\n					parent.parentNode.selectedIndex;\n				}\n			}\n		}\n	};\n}\n\njQuery.each( [\n	"tabIndex",\n	"readOnly",\n	"maxLength",\n	"cellSpacing",\n	"cellPadding",\n	"rowSpan",\n	"colSpan",\n	"useMap",\n	"frameBorder",\n	"contentEditable"\n], function() {\n	jQuery.propFix[ this.toLowerCase() ] = this;\n} );\n\n// IE6/7 call enctype encoding\nif ( !support.enctype ) {\n	jQuery.propFix.enctype = "encoding";\n}\n\n\n\n\nvar rclass = /[\\t\\r\\n\\f]/g;\n\nfunction getClass( elem ) {\n	return jQuery.attr( elem, "class" ) || "";\n}\n\njQuery.fn.extend( {\n	addClass: function( value ) {\n		var classes, elem, cur, curValue, clazz, j, finalValue,\n			i = 0;\n\n		if ( jQuery.isFunction( value ) ) {\n			return this.each( function( j ) {\n				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\n			} );\n		}\n\n		if ( typeof value === "string" && value ) {\n			classes = value.match( rnotwhite ) || [];\n\n			while ( ( elem = this[ i++ ] ) ) {\n				curValue = getClass( elem );\n				cur = elem.nodeType === 1 &&\n					( " " + curValue + " " ).replace( rclass, " " );\n\n				if ( cur ) {\n					j = 0;\n					while ( ( clazz = classes[ j++ ] ) ) {\n						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {\n							cur += clazz + " ";\n						}\n					}\n\n					// only assign if different to avoid unneeded rendering.\n					finalValue = jQuery.trim( cur );\n					if ( curValue !== finalValue ) {\n						jQuery.attr( elem, "class", finalValue );\n					}\n				}\n			}\n		}\n\n		return this;\n	},\n\n	removeClass: function( value ) {\n		var classes, elem, cur, curValue, clazz, j, finalValue,\n			i = 0;\n\n		if ( jQuery.isFunction( value ) ) {\n			return this.each( function( j ) {\n				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\n			} );\n		}\n\n		if ( !arguments.length ) {\n			return this.attr( "class", "" );\n		}\n\n		if ( typeof value === "string" && value ) {\n			classes = value.match( rnotwhite ) || [];\n\n			while ( ( elem = this[ i++ ] ) ) {\n				curValue = getClass( elem );\n\n				// This expression is here for better compressibility (see addClass)\n				cur = elem.nodeType === 1 &&\n					( " " + curValue + " " ).replace( rclass, " " );\n\n				if ( cur ) {\n					j = 0;\n					while ( ( clazz = classes[ j++ ] ) ) {\n\n						// Remove *all* instances\n						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {\n							cur = cur.replace( " " + clazz + " ", " " );\n						}\n					}\n\n					// Only assign if different to avoid unneeded rendering.\n					finalValue = jQuery.trim( cur );\n					if ( curValue !== finalValue ) {\n						jQuery.attr( elem, "class", finalValue );\n					}\n				}\n			}\n		}\n\n		return this;\n	},\n\n	toggleClass: function( value, stateVal ) {\n		var type = typeof value;\n\n		if ( typeof stateVal === "boolean" && type === "string" ) {\n			return stateVal ? this.addClass( value ) : this.removeClass( value );\n		}\n\n		if ( jQuery.isFunction( value ) ) {\n			return this.each( function( i ) {\n				jQuery( this ).toggleClass(\n					value.call( this, i, getClass( this ), stateVal ),\n					stateVal\n				);\n			} );\n		}\n\n		return this.each( function() {\n			var className, i, self, classNames;\n\n			if ( type === "string" ) {\n\n				// Toggle individual class names\n				i = 0;\n				self = jQuery( this );\n				classNames = value.match( rnotwhite ) || [];\n\n				while ( ( className = classNames[ i++ ] ) ) {\n\n					// Check each className given, space separated list\n					if ( self.hasClass( className ) ) {\n						self.removeClass( className );\n					} else {\n						self.addClass( className );\n					}\n				}\n\n			// Toggle whole class name\n			} else if ( value === undefined || type === "boolean" ) {\n				className = getClass( this );\n				if ( className ) {\n\n					// store className if set\n					jQuery._data( this, "__className__", className );\n				}\n\n				// If the element has a class name or if we\'re passed "false",\n				// then remove the whole classname (if there was one, the above saved it).\n				// Otherwise bring back whatever was previously saved (if anything),\n				// falling back to the empty string if nothing was stored.\n				jQuery.attr( this, "class",\n					className || value === false ?\n					"" :\n					jQuery._data( this, "__className__" ) || ""\n				);\n			}\n		} );\n	},\n\n	hasClass: function( selector ) {\n		var className, elem,\n			i = 0;\n\n		className = " " + selector + " ";\n		while ( ( elem = this[ i++ ] ) ) {\n			if ( elem.nodeType === 1 &&\n				( " " + getClass( elem ) + " " ).replace( rclass, " " )\n					.indexOf( className ) > -1\n			) {\n				return true;\n			}\n		}\n\n		return false;\n	}\n} );\n\n\n\n\n// Return jQuery for attributes-only inclusion\n\n\njQuery.each( ( "blur focus focusin focusout load resize scroll unload click dblclick " +\n	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +\n	"change select submit keydown keypress keyup error contextmenu" ).split( " " ),\n	function( i, name ) {\n\n	// Handle event binding\n	jQuery.fn[ name ] = function( data, fn ) {\n		return arguments.length > 0 ?\n			this.on( name, null, data, fn ) :\n			this.trigger( name );\n	};\n} );\n\njQuery.fn.extend( {\n	hover: function( fnOver, fnOut ) {\n		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n	}\n} );\n\n\nvar location = window.location;\n\nvar nonce = jQuery.now();\n\nvar rquery = ( /\\?/ );\n\n\n\nvar rvalidtokens = /(,)|(\\[|{)|(}|])|"(?:[^"\\\\\\r\\n]|\\\\["\\\\\\/bfnrt]|\\\\u[\\da-fA-F]{4})*"\\s*:?|true|false|null|-?(?!0\\d)\\d+(?:\\.\\d+|)(?:[eE][+-]?\\d+|)/g;\n\njQuery.parseJSON = function( data ) {\n\n	// Attempt to parse using the native JSON parser first\n	if ( window.JSON && window.JSON.parse ) {\n\n		// Support: Android 2.3\n		// Workaround failure to string-cast null input\n		return window.JSON.parse( data + "" );\n	}\n\n	var requireNonComma,\n		depth = null,\n		str = jQuery.trim( data + "" );\n\n	// Guard against invalid (and possibly dangerous) input by ensuring that nothing remains\n	// after removing valid tokens\n	return str && !jQuery.trim( str.replace( rvalidtokens, function( token, comma, open, close ) {\n\n		// Force termination if we see a misplaced comma\n		if ( requireNonComma && comma ) {\n			depth = 0;\n		}\n\n		// Perform no more replacements after returning to outermost depth\n		if ( depth === 0 ) {\n			return token;\n		}\n\n		// Commas must not follow "[", "{", or ","\n		requireNonComma = open || comma;\n\n		// Determine new depth\n		// array/object open ("[" or "{"): depth += true - false (increment)\n		// array/object close ("]" or "}"): depth += false - true (decrement)\n		// other cases ("," or primitive): depth += true - true (numeric cast)\n		depth += !close - !open;\n\n		// Remove this token\n		return "";\n	} ) ) ?\n		( Function( "return " + str ) )() :\n		jQuery.error( "Invalid JSON: " + data );\n};\n\n\n// Cross-browser xml parsing\njQuery.parseXML = function( data ) {\n	var xml, tmp;\n	if ( !data || typeof data !== "string" ) {\n		return null;\n	}\n	try {\n		if ( window.DOMParser ) { // Standard\n			tmp = new window.DOMParser();\n			xml = tmp.parseFromString( data, "text/xml" );\n		} else { // IE\n			xml = new window.ActiveXObject( "Microsoft.XMLDOM" );\n			xml.async = "false";\n			xml.loadXML( data );\n		}\n	} catch ( e ) {\n		xml = undefined;\n	}\n	if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {\n		jQuery.error( "Invalid XML: " + data );\n	}\n	return xml;\n};\n\n\nvar\n	rhash = /#.*$/,\n	rts = /([?&])_=[^&]*/,\n\n	// IE leaves an \\r character at EOL\n	rheaders = /^(.*?):[ \\t]*([^\\r\\n]*)\\r?$/mg,\n\n	// #7653, #8125, #8152: local protocol detection\n	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n	rnoContent = /^(?:GET|HEAD)$/,\n	rprotocol = /^\\/\\//,\n	rurl = /^([\\w.+-]+:)(?:\\/\\/(?:[^\\/?#]*@|)([^\\/?#:]*)(?::(\\d+)|)|)/,\n\n	/* Prefilters\n	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n	 * 2) These are called:\n	 *    - BEFORE asking for a transport\n	 *    - AFTER param serialization (s.data is a string if s.processData is true)\n	 * 3) key is the dataType\n	 * 4) the catchall symbol "*" can be used\n	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed\n	 */\n	prefilters = {},\n\n	/* Transports bindings\n	 * 1) key is the dataType\n	 * 2) the catchall symbol "*" can be used\n	 * 3) selection will start with transport dataType and THEN go to "*" if needed\n	 */\n	transports = {},\n\n	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n	allTypes = "*/".concat( "*" ),\n\n	// Document location\n	ajaxLocation = location.href,\n\n	// Segment location into parts\n	ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];\n\n// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n	// dataTypeExpression is optional and defaults to "*"\n	return function( dataTypeExpression, func ) {\n\n		if ( typeof dataTypeExpression !== "string" ) {\n			func = dataTypeExpression;\n			dataTypeExpression = "*";\n		}\n\n		var dataType,\n			i = 0,\n			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];\n\n		if ( jQuery.isFunction( func ) ) {\n\n			// For each dataType in the dataTypeExpression\n			while ( ( dataType = dataTypes[ i++ ] ) ) {\n\n				// Prepend if requested\n				if ( dataType.charAt( 0 ) === "+" ) {\n					dataType = dataType.slice( 1 ) || "*";\n					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\n\n				// Otherwise append\n				} else {\n					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\n				}\n			}\n		}\n	};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n	var inspected = {},\n		seekingTransport = ( structure === transports );\n\n	function inspect( dataType ) {\n		var selected;\n		inspected[ dataType ] = true;\n		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n			if ( typeof dataTypeOrTransport === "string" &&\n				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\n				options.dataTypes.unshift( dataTypeOrTransport );\n				inspect( dataTypeOrTransport );\n				return false;\n			} else if ( seekingTransport ) {\n				return !( selected = dataTypeOrTransport );\n			}\n		} );\n		return selected;\n	}\n\n	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );\n}\n\n// A special extend for ajax options\n// that takes "flat" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n	var deep, key,\n		flatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n	for ( key in src ) {\n		if ( src[ key ] !== undefined ) {\n			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\n		}\n	}\n	if ( deep ) {\n		jQuery.extend( true, target, deep );\n	}\n\n	return target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n	var firstDataType, ct, finalDataType, type,\n		contents = s.contents,\n		dataTypes = s.dataTypes;\n\n	// Remove auto dataType and get content-type in the process\n	while ( dataTypes[ 0 ] === "*" ) {\n		dataTypes.shift();\n		if ( ct === undefined ) {\n			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );\n		}\n	}\n\n	// Check if we\'re dealing with a known content-type\n	if ( ct ) {\n		for ( type in contents ) {\n			if ( contents[ type ] && contents[ type ].test( ct ) ) {\n				dataTypes.unshift( type );\n				break;\n			}\n		}\n	}\n\n	// Check to see if we have a response for the expected dataType\n	if ( dataTypes[ 0 ] in responses ) {\n		finalDataType = dataTypes[ 0 ];\n	} else {\n\n		// Try convertible dataTypes\n		for ( type in responses ) {\n			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {\n				finalDataType = type;\n				break;\n			}\n			if ( !firstDataType ) {\n				firstDataType = type;\n			}\n		}\n\n		// Or just use first one\n		finalDataType = finalDataType || firstDataType;\n	}\n\n	// If we found a dataType\n	// We add the dataType to the list if needed\n	// and return the corresponding response\n	if ( finalDataType ) {\n		if ( finalDataType !== dataTypes[ 0 ] ) {\n			dataTypes.unshift( finalDataType );\n		}\n		return responses[ finalDataType ];\n	}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n	var conv2, current, conv, tmp, prev,\n		converters = {},\n\n		// Work with a copy of dataTypes in case we need to modify it for conversion\n		dataTypes = s.dataTypes.slice();\n\n	// Create converters map with lowercased keys\n	if ( dataTypes[ 1 ] ) {\n		for ( conv in s.converters ) {\n			converters[ conv.toLowerCase() ] = s.converters[ conv ];\n		}\n	}\n\n	current = dataTypes.shift();\n\n	// Convert to each sequential dataType\n	while ( current ) {\n\n		if ( s.responseFields[ current ] ) {\n			jqXHR[ s.responseFields[ current ] ] = response;\n		}\n\n		// Apply the dataFilter if provided\n		if ( !prev && isSuccess && s.dataFilter ) {\n			response = s.dataFilter( response, s.dataType );\n		}\n\n		prev = current;\n		current = dataTypes.shift();\n\n		if ( current ) {\n\n			// There\'s only work to do if current dataType is non-auto\n			if ( current === "*" ) {\n\n				current = prev;\n\n			// Convert response if prev dataType is non-auto and differs from current\n			} else if ( prev !== "*" && prev !== current ) {\n\n				// Seek a direct converter\n				conv = converters[ prev + " " + current ] || converters[ "* " + current ];\n\n				// If none found, seek a pair\n				if ( !conv ) {\n					for ( conv2 in converters ) {\n\n						// If conv2 outputs current\n						tmp = conv2.split( " " );\n						if ( tmp[ 1 ] === current ) {\n\n							// If prev can be converted to accepted input\n							conv = converters[ prev + " " + tmp[ 0 ] ] ||\n								converters[ "* " + tmp[ 0 ] ];\n							if ( conv ) {\n\n								// Condense equivalence converters\n								if ( conv === true ) {\n									conv = converters[ conv2 ];\n\n								// Otherwise, insert the intermediate dataType\n								} else if ( converters[ conv2 ] !== true ) {\n									current = tmp[ 0 ];\n									dataTypes.unshift( tmp[ 1 ] );\n								}\n								break;\n							}\n						}\n					}\n				}\n\n				// Apply converter (if not an equivalence)\n				if ( conv !== true ) {\n\n					// Unless errors are allowed to bubble, catch and return them\n					if ( conv && s[ "throws" ] ) { // jscs:ignore requireDotNotation\n						response = conv( response );\n					} else {\n						try {\n							response = conv( response );\n						} catch ( e ) {\n							return {\n								state: "parsererror",\n								error: conv ? e : "No conversion from " + prev + " to " + current\n							};\n						}\n					}\n				}\n			}\n		}\n	}\n\n	return { state: "success", data: response };\n}\n\njQuery.extend( {\n\n	// Counter for holding the number of active queries\n	active: 0,\n\n	// Last-Modified header cache for next request\n	lastModified: {},\n	etag: {},\n\n	ajaxSettings: {\n		url: ajaxLocation,\n		type: "GET",\n		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),\n		global: true,\n		processData: true,\n		async: true,\n		contentType: "application/x-www-form-urlencoded; charset=UTF-8",\n		/*\n		timeout: 0,\n		data: null,\n		dataType: null,\n		username: null,\n		password: null,\n		cache: null,\n		throws: false,\n		traditional: false,\n		headers: {},\n		*/\n\n		accepts: {\n			"*": allTypes,\n			text: "text/plain",\n			html: "text/html",\n			xml: "application/xml, text/xml",\n			json: "application/json, text/javascript"\n		},\n\n		contents: {\n			xml: /\\bxml\\b/,\n			html: /\\bhtml/,\n			json: /\\bjson\\b/\n		},\n\n		responseFields: {\n			xml: "responseXML",\n			text: "responseText",\n			json: "responseJSON"\n		},\n\n		// Data converters\n		// Keys separate source (or catchall "*") and destination types with a single space\n		converters: {\n\n			// Convert anything to text\n			"* text": String,\n\n			// Text to html (true = no transformation)\n			"text html": true,\n\n			// Evaluate text as a json expression\n			"text json": jQuery.parseJSON,\n\n			// Parse text as xml\n			"text xml": jQuery.parseXML\n		},\n\n		// For options that shouldn\'t be deep extended:\n		// you can add your own custom options here if\n		// and when you create one that shouldn\'t be\n		// deep extended (see ajaxExtend)\n		flatOptions: {\n			url: true,\n			context: true\n		}\n	},\n\n	// Creates a full fledged settings object into target\n	// with both ajaxSettings and settings fields.\n	// If target is omitted, writes into ajaxSettings.\n	ajaxSetup: function( target, settings ) {\n		return settings ?\n\n			// Building a settings object\n			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n			// Extending ajaxSettings\n			ajaxExtend( jQuery.ajaxSettings, target );\n	},\n\n	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n	ajaxTransport: addToPrefiltersOrTransports( transports ),\n\n	// Main method\n	ajax: function( url, options ) {\n\n		// If url is an object, simulate pre-1.5 signature\n		if ( typeof url === "object" ) {\n			options = url;\n			url = undefined;\n		}\n\n		// Force options to be an object\n		options = options || {};\n\n		var\n\n			// Cross-domain detection vars\n			parts,\n\n			// Loop variable\n			i,\n\n			// URL without anti-cache param\n			cacheURL,\n\n			// Response headers as string\n			responseHeadersString,\n\n			// timeout handle\n			timeoutTimer,\n\n			// To know if global events are to be dispatched\n			fireGlobals,\n\n			transport,\n\n			// Response headers\n			responseHeaders,\n\n			// Create the final options object\n			s = jQuery.ajaxSetup( {}, options ),\n\n			// Callbacks context\n			callbackContext = s.context || s,\n\n			// Context for global events is callbackContext if it is a DOM node or jQuery collection\n			globalEventContext = s.context &&\n				( callbackContext.nodeType || callbackContext.jquery ) ?\n					jQuery( callbackContext ) :\n					jQuery.event,\n\n			// Deferreds\n			deferred = jQuery.Deferred(),\n			completeDeferred = jQuery.Callbacks( "once memory" ),\n\n			// Status-dependent callbacks\n			statusCode = s.statusCode || {},\n\n			// Headers (they are sent all at once)\n			requestHeaders = {},\n			requestHeadersNames = {},\n\n			// The jqXHR state\n			state = 0,\n\n			// Default abort message\n			strAbort = "canceled",\n\n			// Fake xhr\n			jqXHR = {\n				readyState: 0,\n\n				// Builds headers hashtable if needed\n				getResponseHeader: function( key ) {\n					var match;\n					if ( state === 2 ) {\n						if ( !responseHeaders ) {\n							responseHeaders = {};\n							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {\n								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];\n							}\n						}\n						match = responseHeaders[ key.toLowerCase() ];\n					}\n					return match == null ? null : match;\n				},\n\n				// Raw string\n				getAllResponseHeaders: function() {\n					return state === 2 ? responseHeadersString : null;\n				},\n\n				// Caches the header\n				setRequestHeader: function( name, value ) {\n					var lname = name.toLowerCase();\n					if ( !state ) {\n						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;\n						requestHeaders[ name ] = value;\n					}\n					return this;\n				},\n\n				// Overrides response content-type header\n				overrideMimeType: function( type ) {\n					if ( !state ) {\n						s.mimeType = type;\n					}\n					return this;\n				},\n\n				// Status-dependent callbacks\n				statusCode: function( map ) {\n					var code;\n					if ( map ) {\n						if ( state < 2 ) {\n							for ( code in map ) {\n\n								// Lazy-add the new callback in a way that preserves old ones\n								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n							}\n						} else {\n\n							// Execute the appropriate callbacks\n							jqXHR.always( map[ jqXHR.status ] );\n						}\n					}\n					return this;\n				},\n\n				// Cancel the request\n				abort: function( statusText ) {\n					var finalText = statusText || strAbort;\n					if ( transport ) {\n						transport.abort( finalText );\n					}\n					done( 0, finalText );\n					return this;\n				}\n			};\n\n		// Attach deferreds\n		deferred.promise( jqXHR ).complete = completeDeferred.add;\n		jqXHR.success = jqXHR.done;\n		jqXHR.error = jqXHR.fail;\n\n		// Remove hash character (#7531: and string promotion)\n		// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)\n		// Handle falsy url in the settings object (#10093: consistency with old signature)\n		// We also use the url parameter if available\n		s.url = ( ( url || s.url || ajaxLocation ) + "" )\n			.replace( rhash, "" )\n			.replace( rprotocol, ajaxLocParts[ 1 ] + "//" );\n\n		// Alias method option to type as per ticket #12004\n		s.type = options.method || options.type || s.method || s.type;\n\n		// Extract dataTypes list\n		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];\n\n		// A cross-domain request is in order when we have a protocol:host:port mismatch\n		if ( s.crossDomain == null ) {\n			parts = rurl.exec( s.url.toLowerCase() );\n			s.crossDomain = !!( parts &&\n				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||\n					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==\n						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )\n			);\n		}\n\n		// Convert data if not already a string\n		if ( s.data && s.processData && typeof s.data !== "string" ) {\n			s.data = jQuery.param( s.data, s.traditional );\n		}\n\n		// Apply prefilters\n		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n		// If request was aborted inside a prefilter, stop there\n		if ( state === 2 ) {\n			return jqXHR;\n		}\n\n		// We can fire global events as of now if asked to\n		// Don\'t fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n		fireGlobals = jQuery.event && s.global;\n\n		// Watch for a new set of requests\n		if ( fireGlobals && jQuery.active++ === 0 ) {\n			jQuery.event.trigger( "ajaxStart" );\n		}\n\n		// Uppercase the type\n		s.type = s.type.toUpperCase();\n\n		// Determine if request has content\n		s.hasContent = !rnoContent.test( s.type );\n\n		// Save the URL in case we\'re toying with the If-Modified-Since\n		// and/or If-None-Match header later on\n		cacheURL = s.url;\n\n		// More options handling for requests with no content\n		if ( !s.hasContent ) {\n\n			// If data is available, append data to url\n			if ( s.data ) {\n				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );\n\n				// #9682: remove data so that it\'s not used in an eventual retry\n				delete s.data;\n			}\n\n			// Add anti-cache in url if needed\n			if ( s.cache === false ) {\n				s.url = rts.test( cacheURL ) ?\n\n					// If there is already a \'_\' parameter, set its value\n					cacheURL.replace( rts, "$1_=" + nonce++ ) :\n\n					// Otherwise add one to the end\n					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;\n			}\n		}\n\n		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n		if ( s.ifModified ) {\n			if ( jQuery.lastModified[ cacheURL ] ) {\n				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );\n			}\n			if ( jQuery.etag[ cacheURL ] ) {\n				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );\n			}\n		}\n\n		// Set the correct header, if data is being sent\n		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n			jqXHR.setRequestHeader( "Content-Type", s.contentType );\n		}\n\n		// Set the Accepts header for the server, depending on the dataType\n		jqXHR.setRequestHeader(\n			"Accept",\n			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\n				s.accepts[ s.dataTypes[ 0 ] ] +\n					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :\n				s.accepts[ "*" ]\n		);\n\n		// Check for headers option\n		for ( i in s.headers ) {\n			jqXHR.setRequestHeader( i, s.headers[ i ] );\n		}\n\n		// Allow custom headers/mimetypes and early abort\n		if ( s.beforeSend &&\n			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {\n\n			// Abort if not done already and return\n			return jqXHR.abort();\n		}\n\n		// aborting is no longer a cancellation\n		strAbort = "abort";\n\n		// Install callbacks on deferreds\n		for ( i in { success: 1, error: 1, complete: 1 } ) {\n			jqXHR[ i ]( s[ i ] );\n		}\n\n		// Get transport\n		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n		// If no transport, we auto-abort\n		if ( !transport ) {\n			done( -1, "No Transport" );\n		} else {\n			jqXHR.readyState = 1;\n\n			// Send global event\n			if ( fireGlobals ) {\n				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );\n			}\n\n			// If request was aborted inside ajaxSend, stop there\n			if ( state === 2 ) {\n				return jqXHR;\n			}\n\n			// Timeout\n			if ( s.async && s.timeout > 0 ) {\n				timeoutTimer = window.setTimeout( function() {\n					jqXHR.abort( "timeout" );\n				}, s.timeout );\n			}\n\n			try {\n				state = 1;\n				transport.send( requestHeaders, done );\n			} catch ( e ) {\n\n				// Propagate exception as error if not done\n				if ( state < 2 ) {\n					done( -1, e );\n\n				// Simply rethrow otherwise\n				} else {\n					throw e;\n				}\n			}\n		}\n\n		// Callback for when everything is done\n		function done( status, nativeStatusText, responses, headers ) {\n			var isSuccess, success, error, response, modified,\n				statusText = nativeStatusText;\n\n			// Called once\n			if ( state === 2 ) {\n				return;\n			}\n\n			// State is "done" now\n			state = 2;\n\n			// Clear timeout if it exists\n			if ( timeoutTimer ) {\n				window.clearTimeout( timeoutTimer );\n			}\n\n			// Dereference transport for early garbage collection\n			// (no matter how long the jqXHR object will be used)\n			transport = undefined;\n\n			// Cache response headers\n			responseHeadersString = headers || "";\n\n			// Set readyState\n			jqXHR.readyState = status > 0 ? 4 : 0;\n\n			// Determine if successful\n			isSuccess = status >= 200 && status < 300 || status === 304;\n\n			// Get response data\n			if ( responses ) {\n				response = ajaxHandleResponses( s, jqXHR, responses );\n			}\n\n			// Convert no matter what (that way responseXXX fields are always set)\n			response = ajaxConvert( s, response, jqXHR, isSuccess );\n\n			// If successful, handle type chaining\n			if ( isSuccess ) {\n\n				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n				if ( s.ifModified ) {\n					modified = jqXHR.getResponseHeader( "Last-Modified" );\n					if ( modified ) {\n						jQuery.lastModified[ cacheURL ] = modified;\n					}\n					modified = jqXHR.getResponseHeader( "etag" );\n					if ( modified ) {\n						jQuery.etag[ cacheURL ] = modified;\n					}\n				}\n\n				// if no content\n				if ( status === 204 || s.type === "HEAD" ) {\n					statusText = "nocontent";\n\n				// if not modified\n				} else if ( status === 304 ) {\n					statusText = "notmodified";\n\n				// If we have data, let\'s convert it\n				} else {\n					statusText = response.state;\n					success = response.data;\n					error = response.error;\n					isSuccess = !error;\n				}\n			} else {\n\n				// We extract error from statusText\n				// then normalize statusText and status for non-aborts\n				error = statusText;\n				if ( status || !statusText ) {\n					statusText = "error";\n					if ( status < 0 ) {\n						status = 0;\n					}\n				}\n			}\n\n			// Set data for the fake xhr object\n			jqXHR.status = status;\n			jqXHR.statusText = ( nativeStatusText || statusText ) + "";\n\n			// Success/Error\n			if ( isSuccess ) {\n				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n			} else {\n				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n			}\n\n			// Status-dependent callbacks\n			jqXHR.statusCode( statusCode );\n			statusCode = undefined;\n\n			if ( fireGlobals ) {\n				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",\n					[ jqXHR, s, isSuccess ? success : error ] );\n			}\n\n			// Complete\n			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n			if ( fireGlobals ) {\n				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );\n\n				// Handle the global AJAX counter\n				if ( !( --jQuery.active ) ) {\n					jQuery.event.trigger( "ajaxStop" );\n				}\n			}\n		}\n\n		return jqXHR;\n	},\n\n	getJSON: function( url, data, callback ) {\n		return jQuery.get( url, data, callback, "json" );\n	},\n\n	getScript: function( url, callback ) {\n		return jQuery.get( url, undefined, callback, "script" );\n	}\n} );\n\njQuery.each( [ "get", "post" ], function( i, method ) {\n	jQuery[ method ] = function( url, data, callback, type ) {\n\n		// shift arguments if data argument was omitted\n		if ( jQuery.isFunction( data ) ) {\n			type = type || callback;\n			callback = data;\n			data = undefined;\n		}\n\n		// The url can be an options object (which then must have .url)\n		return jQuery.ajax( jQuery.extend( {\n			url: url,\n			type: method,\n			dataType: type,\n			data: data,\n			success: callback\n		}, jQuery.isPlainObject( url ) && url ) );\n	};\n} );\n\n\njQuery._evalUrl = function( url ) {\n	return jQuery.ajax( {\n		url: url,\n\n		// Make this explicit, since user can override this through ajaxSetup (#11264)\n		type: "GET",\n		dataType: "script",\n		cache: true,\n		async: false,\n		global: false,\n		"throws": true\n	} );\n};\n\n\njQuery.fn.extend( {\n	wrapAll: function( html ) {\n		if ( jQuery.isFunction( html ) ) {\n			return this.each( function( i ) {\n				jQuery( this ).wrapAll( html.call( this, i ) );\n			} );\n		}\n\n		if ( this[ 0 ] ) {\n\n			// The elements to wrap the target around\n			var wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n			if ( this[ 0 ].parentNode ) {\n				wrap.insertBefore( this[ 0 ] );\n			}\n\n			wrap.map( function() {\n				var elem = this;\n\n				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {\n					elem = elem.firstChild;\n				}\n\n				return elem;\n			} ).append( this );\n		}\n\n		return this;\n	},\n\n	wrapInner: function( html ) {\n		if ( jQuery.isFunction( html ) ) {\n			return this.each( function( i ) {\n				jQuery( this ).wrapInner( html.call( this, i ) );\n			} );\n		}\n\n		return this.each( function() {\n			var self = jQuery( this ),\n				contents = self.contents();\n\n			if ( contents.length ) {\n				contents.wrapAll( html );\n\n			} else {\n				self.append( html );\n			}\n		} );\n	},\n\n	wrap: function( html ) {\n		var isFunction = jQuery.isFunction( html );\n\n		return this.each( function( i ) {\n			jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );\n		} );\n	},\n\n	unwrap: function() {\n		return this.parent().each( function() {\n			if ( !jQuery.nodeName( this, "body" ) ) {\n				jQuery( this ).replaceWith( this.childNodes );\n			}\n		} ).end();\n	}\n} );\n\n\nfunction getDisplay( elem ) {\n	return elem.style && elem.style.display || jQuery.css( elem, "display" );\n}\n\nfunction filterHidden( elem ) {\n	while ( elem && elem.nodeType === 1 ) {\n		if ( getDisplay( elem ) === "none" || elem.type === "hidden" ) {\n			return true;\n		}\n		elem = elem.parentNode;\n	}\n	return false;\n}\n\njQuery.expr.filters.hidden = function( elem ) {\n\n	// Support: Opera <= 12.12\n	// Opera reports offsetWidths and offsetHeights less than zero on some elements\n	return support.reliableHiddenOffsets() ?\n		( elem.offsetWidth <= 0 && elem.offsetHeight <= 0 &&\n			!elem.getClientRects().length ) :\n			filterHidden( elem );\n};\n\njQuery.expr.filters.visible = function( elem ) {\n	return !jQuery.expr.filters.hidden( elem );\n};\n\n\n\n\nvar r20 = /%20/g,\n	rbracket = /\\[\\]$/,\n	rCRLF = /\\r?\\n/g,\n	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n	rsubmittable = /^(?:input|select|textarea|keygen)/i;\n\nfunction buildParams( prefix, obj, traditional, add ) {\n	var name;\n\n	if ( jQuery.isArray( obj ) ) {\n\n		// Serialize array item.\n		jQuery.each( obj, function( i, v ) {\n			if ( traditional || rbracket.test( prefix ) ) {\n\n				// Treat each array item as a scalar.\n				add( prefix, v );\n\n			} else {\n\n				// Item is non-scalar (array or object), encode its numeric index.\n				buildParams(\n					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",\n					v,\n					traditional,\n					add\n				);\n			}\n		} );\n\n	} else if ( !traditional && jQuery.type( obj ) === "object" ) {\n\n		// Serialize object item.\n		for ( name in obj ) {\n			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );\n		}\n\n	} else {\n\n		// Serialize scalar item.\n		add( prefix, obj );\n	}\n}\n\n// Serialize an array of form elements or a set of\n// key/values into a query string\njQuery.param = function( a, traditional ) {\n	var prefix,\n		s = [],\n		add = function( key, value ) {\n\n			// If value is a function, invoke it and return its value\n			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );\n			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );\n		};\n\n	// Set traditional to true for jQuery <= 1.3.2 behavior.\n	if ( traditional === undefined ) {\n		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;\n	}\n\n	// If an array was passed in, assume that it is an array of form elements.\n	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\n		// Serialize the form elements\n		jQuery.each( a, function() {\n			add( this.name, this.value );\n		} );\n\n	} else {\n\n		// If traditional, encode the "old" way (the way 1.3.2 or older\n		// did it), otherwise encode params recursively.\n		for ( prefix in a ) {\n			buildParams( prefix, a[ prefix ], traditional, add );\n		}\n	}\n\n	// Return the resulting serialization\n	return s.join( "&" ).replace( r20, "+" );\n};\n\njQuery.fn.extend( {\n	serialize: function() {\n		return jQuery.param( this.serializeArray() );\n	},\n	serializeArray: function() {\n		return this.map( function() {\n\n			// Can add propHook for "elements" to filter or add form elements\n			var elements = jQuery.prop( this, "elements" );\n			return elements ? jQuery.makeArray( elements ) : this;\n		} )\n		.filter( function() {\n			var type = this.type;\n\n			// Use .is(":disabled") so that fieldset[disabled] works\n			return this.name && !jQuery( this ).is( ":disabled" ) &&\n				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n				( this.checked || !rcheckableType.test( type ) );\n		} )\n		.map( function( i, elem ) {\n			var val = jQuery( this ).val();\n\n			return val == null ?\n				null :\n				jQuery.isArray( val ) ?\n					jQuery.map( val, function( val ) {\n						return { name: elem.name, value: val.replace( rCRLF, "\\r\\n" ) };\n					} ) :\n					{ name: elem.name, value: val.replace( rCRLF, "\\r\\n" ) };\n		} ).get();\n	}\n} );\n\n\n// Create the request object\n// (This is still attached to ajaxSettings for backward compatibility)\njQuery.ajaxSettings.xhr = window.ActiveXObject !== undefined ?\n\n	// Support: IE6-IE8\n	function() {\n\n		// XHR cannot access local files, always use ActiveX for that case\n		if ( this.isLocal ) {\n			return createActiveXHR();\n		}\n\n		// Support: IE 9-11\n		// IE seems to error on cross-domain PATCH requests when ActiveX XHR\n		// is used. In IE 9+ always use the native XHR.\n		// Note: this condition won\'t catch Edge as it doesn\'t define\n		// document.documentMode but it also doesn\'t support ActiveX so it won\'t\n		// reach this code.\n		if ( document.documentMode > 8 ) {\n			return createStandardXHR();\n		}\n\n		// Support: IE<9\n		// oldIE XHR does not support non-RFC2616 methods (#13240)\n		// See http://msdn.microsoft.com/en-us/library/ie/ms536648(v=vs.85).aspx\n		// and http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9\n		// Although this check for six methods instead of eight\n		// since IE also does not support "trace" and "connect"\n		return /^(get|post|head|put|delete|options)$/i.test( this.type ) &&\n			createStandardXHR() || createActiveXHR();\n	} :\n\n	// For all other browsers, use the standard XMLHttpRequest object\n	createStandardXHR;\n\nvar xhrId = 0,\n	xhrCallbacks = {},\n	xhrSupported = jQuery.ajaxSettings.xhr();\n\n// Support: IE<10\n// Open requests must be manually aborted on unload (#5280)\n// See https://support.microsoft.com/kb/2856746 for more info\nif ( window.attachEvent ) {\n	window.attachEvent( "onunload", function() {\n		for ( var key in xhrCallbacks ) {\n			xhrCallbacks[ key ]( undefined, true );\n		}\n	} );\n}\n\n// Determine support properties\nsupport.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );\nxhrSupported = support.ajax = !!xhrSupported;\n\n// Create transport if the browser can provide an xhr\nif ( xhrSupported ) {\n\n	jQuery.ajaxTransport( function( options ) {\n\n		// Cross domain only allowed if supported through XMLHttpRequest\n		if ( !options.crossDomain || support.cors ) {\n\n			var callback;\n\n			return {\n				send: function( headers, complete ) {\n					var i,\n						xhr = options.xhr(),\n						id = ++xhrId;\n\n					// Open the socket\n					xhr.open(\n						options.type,\n						options.url,\n						options.async,\n						options.username,\n						options.password\n					);\n\n					// Apply custom fields if provided\n					if ( options.xhrFields ) {\n						for ( i in options.xhrFields ) {\n							xhr[ i ] = options.xhrFields[ i ];\n						}\n					}\n\n					// Override mime type if needed\n					if ( options.mimeType && xhr.overrideMimeType ) {\n						xhr.overrideMimeType( options.mimeType );\n					}\n\n					// X-Requested-With header\n					// For cross-domain requests, seeing as conditions for a preflight are\n					// akin to a jigsaw puzzle, we simply never set it to be sure.\n					// (it can always be set on a per-request basis or even using ajaxSetup)\n					// For same-domain requests, won\'t change header if already provided.\n					if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {\n						headers[ "X-Requested-With" ] = "XMLHttpRequest";\n					}\n\n					// Set headers\n					for ( i in headers ) {\n\n						// Support: IE<9\n						// IE\'s ActiveXObject throws a \'Type Mismatch\' exception when setting\n						// request header to a null-value.\n						//\n						// To keep consistent with other XHR implementations, cast the value\n						// to string and ignore `undefined`.\n						if ( headers[ i ] !== undefined ) {\n							xhr.setRequestHeader( i, headers[ i ] + "" );\n						}\n					}\n\n					// Do send the request\n					// This may raise an exception which is actually\n					// handled in jQuery.ajax (so no try/catch here)\n					xhr.send( ( options.hasContent && options.data ) || null );\n\n					// Listener\n					callback = function( _, isAbort ) {\n						var status, statusText, responses;\n\n						// Was never called and is aborted or complete\n						if ( callback && ( isAbort || xhr.readyState === 4 ) ) {\n\n							// Clean up\n							delete xhrCallbacks[ id ];\n							callback = undefined;\n							xhr.onreadystatechange = jQuery.noop;\n\n							// Abort manually if needed\n							if ( isAbort ) {\n								if ( xhr.readyState !== 4 ) {\n									xhr.abort();\n								}\n							} else {\n								responses = {};\n								status = xhr.status;\n\n								// Support: IE<10\n								// Accessing binary-data responseText throws an exception\n								// (#11426)\n								if ( typeof xhr.responseText === "string" ) {\n									responses.text = xhr.responseText;\n								}\n\n								// Firefox throws an exception when accessing\n								// statusText for faulty cross-domain requests\n								try {\n									statusText = xhr.statusText;\n								} catch ( e ) {\n\n									// We normalize with Webkit giving an empty statusText\n									statusText = "";\n								}\n\n								// Filter status for non standard behaviors\n\n								// If the request is local and we have data: assume a success\n								// (success with no data won\'t get notified, that\'s the best we\n								// can do given current implementations)\n								if ( !status && options.isLocal && !options.crossDomain ) {\n									status = responses.text ? 200 : 404;\n\n								// IE - #1450: sometimes returns 1223 when it should be 204\n								} else if ( status === 1223 ) {\n									status = 204;\n								}\n							}\n						}\n\n						// Call complete if needed\n						if ( responses ) {\n							complete( status, statusText, responses, xhr.getAllResponseHeaders() );\n						}\n					};\n\n					// Do send the request\n					// `xhr.send` may raise an exception, but it will be\n					// handled in jQuery.ajax (so no try/catch here)\n					if ( !options.async ) {\n\n						// If we\'re in sync mode we fire the callback\n						callback();\n					} else if ( xhr.readyState === 4 ) {\n\n						// (IE6 & IE7) if it\'s in cache and has been\n						// retrieved directly we need to fire the callback\n						window.setTimeout( callback );\n					} else {\n\n						// Register the callback, but delay it in case `xhr.send` throws\n						// Add to the list of active xhr callbacks\n						xhr.onreadystatechange = xhrCallbacks[ id ] = callback;\n					}\n				},\n\n				abort: function() {\n					if ( callback ) {\n						callback( undefined, true );\n					}\n				}\n			};\n		}\n	} );\n}\n\n// Functions to create xhrs\nfunction createStandardXHR() {\n	try {\n		return new window.XMLHttpRequest();\n	} catch ( e ) {}\n}\n\nfunction createActiveXHR() {\n	try {\n		return new window.ActiveXObject( "Microsoft.XMLHTTP" );\n	} catch ( e ) {}\n}\n\n\n\n\n// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\njQuery.ajaxPrefilter( function( s ) {\n	if ( s.crossDomain ) {\n		s.contents.script = false;\n	}\n} );\n\n// Install script dataType\njQuery.ajaxSetup( {\n	accepts: {\n		script: "text/javascript, application/javascript, " +\n			"application/ecmascript, application/x-ecmascript"\n	},\n	contents: {\n		script: /\\b(?:java|ecma)script\\b/\n	},\n	converters: {\n		"text script": function( text ) {\n			jQuery.globalEval( text );\n			return text;\n		}\n	}\n} );\n\n// Handle cache\'s special case and global\njQuery.ajaxPrefilter( "script", function( s ) {\n	if ( s.cache === undefined ) {\n		s.cache = false;\n	}\n	if ( s.crossDomain ) {\n		s.type = "GET";\n		s.global = false;\n	}\n} );\n\n// Bind script tag hack transport\njQuery.ajaxTransport( "script", function( s ) {\n\n	// This transport only deals with cross domain requests\n	if ( s.crossDomain ) {\n\n		var script,\n			head = document.head || jQuery( "head" )[ 0 ] || document.documentElement;\n\n		return {\n\n			send: function( _, callback ) {\n\n				script = document.createElement( "script" );\n\n				script.async = true;\n\n				if ( s.scriptCharset ) {\n					script.charset = s.scriptCharset;\n				}\n\n				script.src = s.url;\n\n				// Attach handlers for all browsers\n				script.onload = script.onreadystatechange = function( _, isAbort ) {\n\n					if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {\n\n						// Handle memory leak in IE\n						script.onload = script.onreadystatechange = null;\n\n						// Remove the script\n						if ( script.parentNode ) {\n							script.parentNode.removeChild( script );\n						}\n\n						// Dereference the script\n						script = null;\n\n						// Callback if not abort\n						if ( !isAbort ) {\n							callback( 200, "success" );\n						}\n					}\n				};\n\n				// Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending\n				// Use native DOM manipulation to avoid our domManip AJAX trickery\n				head.insertBefore( script, head.firstChild );\n			},\n\n			abort: function() {\n				if ( script ) {\n					script.onload( undefined, true );\n				}\n			}\n		};\n	}\n} );\n\n\n\n\nvar oldCallbacks = [],\n	rjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup( {\n	jsonp: "callback",\n	jsonpCallback: function() {\n		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );\n		this[ callback ] = true;\n		return callback;\n	}\n} );\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {\n\n	var callbackName, overwritten, responseContainer,\n		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n			"url" :\n			typeof s.data === "string" &&\n				( s.contentType || "" )\n					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&\n				rjsonp.test( s.data ) && "data"\n		);\n\n	// Handle iff the expected data type is "jsonp" or we have a parameter to set\n	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {\n\n		// Get callback name, remembering preexisting value associated with it\n		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n			s.jsonpCallback() :\n			s.jsonpCallback;\n\n		// Insert callback into url or form data\n		if ( jsonProp ) {\n			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );\n		} else if ( s.jsonp !== false ) {\n			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;\n		}\n\n		// Use data converter to retrieve json after script execution\n		s.converters[ "script json" ] = function() {\n			if ( !responseContainer ) {\n				jQuery.error( callbackName + " was not called" );\n			}\n			return responseContainer[ 0 ];\n		};\n\n		// force json dataType\n		s.dataTypes[ 0 ] = "json";\n\n		// Install callback\n		overwritten = window[ callbackName ];\n		window[ callbackName ] = function() {\n			responseContainer = arguments;\n		};\n\n		// Clean-up function (fires after converters)\n		jqXHR.always( function() {\n\n			// If previous value didn\'t exist - remove it\n			if ( overwritten === undefined ) {\n				jQuery( window ).removeProp( callbackName );\n\n			// Otherwise restore preexisting value\n			} else {\n				window[ callbackName ] = overwritten;\n			}\n\n			// Save back as free\n			if ( s[ callbackName ] ) {\n\n				// make sure that re-using the options doesn\'t screw things around\n				s.jsonpCallback = originalSettings.jsonpCallback;\n\n				// save the callback name for future use\n				oldCallbacks.push( callbackName );\n			}\n\n			// Call if it was a function and we have a response\n			if ( responseContainer && jQuery.isFunction( overwritten ) ) {\n				overwritten( responseContainer[ 0 ] );\n			}\n\n			responseContainer = overwritten = undefined;\n		} );\n\n		// Delegate to script\n		return "script";\n	}\n} );\n\n\n\n\n// data: string of html\n// context (optional): If specified, the fragment will be created in this context,\n// defaults to document\n// keepScripts (optional): If true, will include scripts passed in the html string\njQuery.parseHTML = function( data, context, keepScripts ) {\n	if ( !data || typeof data !== "string" ) {\n		return null;\n	}\n	if ( typeof context === "boolean" ) {\n		keepScripts = context;\n		context = false;\n	}\n	context = context || document;\n\n	var parsed = rsingleTag.exec( data ),\n		scripts = !keepScripts && [];\n\n	// Single tag\n	if ( parsed ) {\n		return [ context.createElement( parsed[ 1 ] ) ];\n	}\n\n	parsed = buildFragment( [ data ], context, scripts );\n\n	if ( scripts && scripts.length ) {\n		jQuery( scripts ).remove();\n	}\n\n	return jQuery.merge( [], parsed.childNodes );\n};\n\n\n// Keep a copy of the old load method\nvar _load = jQuery.fn.load;\n\n/**\n * Load a url into a page\n */\njQuery.fn.load = function( url, params, callback ) {\n	if ( typeof url !== "string" && _load ) {\n		return _load.apply( this, arguments );\n	}\n\n	var selector, type, response,\n		self = this,\n		off = url.indexOf( " " );\n\n	if ( off > -1 ) {\n		selector = jQuery.trim( url.slice( off, url.length ) );\n		url = url.slice( 0, off );\n	}\n\n	// If it\'s a function\n	if ( jQuery.isFunction( params ) ) {\n\n		// We assume that it\'s the callback\n		callback = params;\n		params = undefined;\n\n	// Otherwise, build a param string\n	} else if ( params && typeof params === "object" ) {\n		type = "POST";\n	}\n\n	// If we have elements to modify, make the request\n	if ( self.length > 0 ) {\n		jQuery.ajax( {\n			url: url,\n\n			// If "type" variable is undefined, then "GET" method will be used.\n			// Make value of this field explicit since\n			// user can override it through ajaxSetup method\n			type: type || "GET",\n			dataType: "html",\n			data: params\n		} ).done( function( responseText ) {\n\n			// Save response for use in complete callback\n			response = arguments;\n\n			self.html( selector ?\n\n				// If a selector was specified, locate the right elements in a dummy div\n				// Exclude scripts to avoid IE \'Permission Denied\' errors\n				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n				// Otherwise use the full result\n				responseText );\n\n		// If the request succeeds, this function gets "data", "status", "jqXHR"\n		// but they are ignored because response was set above.\n		// If it fails, this function gets "jqXHR", "status", "error"\n		} ).always( callback && function( jqXHR, status ) {\n			self.each( function() {\n				callback.apply( self, response || [ jqXHR.responseText, status, jqXHR ] );\n			} );\n		} );\n	}\n\n	return this;\n};\n\n\n\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [\n	"ajaxStart",\n	"ajaxStop",\n	"ajaxComplete",\n	"ajaxError",\n	"ajaxSuccess",\n	"ajaxSend"\n], function( i, type ) {\n	jQuery.fn[ type ] = function( fn ) {\n		return this.on( type, fn );\n	};\n} );\n\n\n\n\njQuery.expr.filters.animated = function( elem ) {\n	return jQuery.grep( jQuery.timers, function( fn ) {\n		return elem === fn.elem;\n	} ).length;\n};\n\n\n\n\n\n/**\n * Gets a window from an element\n */\nfunction getWindow( elem ) {\n	return jQuery.isWindow( elem ) ?\n		elem :\n		elem.nodeType === 9 ?\n			elem.defaultView || elem.parentWindow :\n			false;\n}\n\njQuery.offset = {\n	setOffset: function( elem, options, i ) {\n		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n			position = jQuery.css( elem, "position" ),\n			curElem = jQuery( elem ),\n			props = {};\n\n		// set position first, in-case top/left are set even on static elem\n		if ( position === "static" ) {\n			elem.style.position = "relative";\n		}\n\n		curOffset = curElem.offset();\n		curCSSTop = jQuery.css( elem, "top" );\n		curCSSLeft = jQuery.css( elem, "left" );\n		calculatePosition = ( position === "absolute" || position === "fixed" ) &&\n			jQuery.inArray( "auto", [ curCSSTop, curCSSLeft ] ) > -1;\n\n		// need to be able to calculate position if either top or left\n		// is auto and position is either absolute or fixed\n		if ( calculatePosition ) {\n			curPosition = curElem.position();\n			curTop = curPosition.top;\n			curLeft = curPosition.left;\n		} else {\n			curTop = parseFloat( curCSSTop ) || 0;\n			curLeft = parseFloat( curCSSLeft ) || 0;\n		}\n\n		if ( jQuery.isFunction( options ) ) {\n\n			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );\n		}\n\n		if ( options.top != null ) {\n			props.top = ( options.top - curOffset.top ) + curTop;\n		}\n		if ( options.left != null ) {\n			props.left = ( options.left - curOffset.left ) + curLeft;\n		}\n\n		if ( "using" in options ) {\n			options.using.call( elem, props );\n		} else {\n			curElem.css( props );\n		}\n	}\n};\n\njQuery.fn.extend( {\n	offset: function( options ) {\n		if ( arguments.length ) {\n			return options === undefined ?\n				this :\n				this.each( function( i ) {\n					jQuery.offset.setOffset( this, options, i );\n				} );\n		}\n\n		var docElem, win,\n			box = { top: 0, left: 0 },\n			elem = this[ 0 ],\n			doc = elem && elem.ownerDocument;\n\n		if ( !doc ) {\n			return;\n		}\n\n		docElem = doc.documentElement;\n\n		// Make sure it\'s not a disconnected DOM node\n		if ( !jQuery.contains( docElem, elem ) ) {\n			return box;\n		}\n\n		// If we don\'t have gBCR, just use 0,0 rather than error\n		// BlackBerry 5, iOS 3 (original iPhone)\n		if ( typeof elem.getBoundingClientRect !== "undefined" ) {\n			box = elem.getBoundingClientRect();\n		}\n		win = getWindow( doc );\n		return {\n			top: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || 0 ),\n			left: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 )\n		};\n	},\n\n	position: function() {\n		if ( !this[ 0 ] ) {\n			return;\n		}\n\n		var offsetParent, offset,\n			parentOffset = { top: 0, left: 0 },\n			elem = this[ 0 ];\n\n		// Fixed elements are offset from window (parentOffset = {top:0, left: 0},\n		// because it is its only offset parent\n		if ( jQuery.css( elem, "position" ) === "fixed" ) {\n\n			// we assume that getBoundingClientRect is available when computed position is fixed\n			offset = elem.getBoundingClientRect();\n		} else {\n\n			// Get *real* offsetParent\n			offsetParent = this.offsetParent();\n\n			// Get correct offsets\n			offset = this.offset();\n			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {\n				parentOffset = offsetParent.offset();\n			}\n\n			// Add offsetParent borders\n			parentOffset.top  += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );\n			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );\n		}\n\n		// Subtract parent offsets and element margins\n		// note: when an element has margin: auto the offsetLeft and marginLeft\n		// are the same in Safari causing offset.left to incorrectly be 0\n		return {\n			top:  offset.top  - parentOffset.top - jQuery.css( elem, "marginTop", true ),\n			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )\n		};\n	},\n\n	offsetParent: function() {\n		return this.map( function() {\n			var offsetParent = this.offsetParent;\n\n			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) &&\n				jQuery.css( offsetParent, "position" ) === "static" ) ) {\n				offsetParent = offsetParent.offsetParent;\n			}\n			return offsetParent || documentElement;\n		} );\n	}\n} );\n\n// Create scrollLeft and scrollTop methods\njQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {\n	var top = /Y/.test( prop );\n\n	jQuery.fn[ method ] = function( val ) {\n		return access( this, function( elem, method, val ) {\n			var win = getWindow( elem );\n\n			if ( val === undefined ) {\n				return win ? ( prop in win ) ? win[ prop ] :\n					win.document.documentElement[ method ] :\n					elem[ method ];\n			}\n\n			if ( win ) {\n				win.scrollTo(\n					!top ? val : jQuery( win ).scrollLeft(),\n					top ? val : jQuery( win ).scrollTop()\n				);\n\n			} else {\n				elem[ method ] = val;\n			}\n		}, method, val, arguments.length, null );\n	};\n} );\n\n// Support: Safari<7-8+, Chrome<37-44+\n// Add the top/left cssHooks using jQuery.fn.position\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n// getComputedStyle returns percent when specified for top/left/bottom/right\n// rather than make the css module depend on the offset module, we just check for it here\njQuery.each( [ "top", "left" ], function( i, prop ) {\n	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n		function( elem, computed ) {\n			if ( computed ) {\n				computed = curCSS( elem, prop );\n\n				// if curCSS returns percentage, fallback to offset\n				return rnumnonpx.test( computed ) ?\n					jQuery( elem ).position()[ prop ] + "px" :\n					computed;\n			}\n		}\n	);\n} );\n\n\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: "height", Width: "width" }, function( name, type ) {\n	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },\n	function( defaultExtra, funcName ) {\n\n		// margin is only for outerHeight, outerWidth\n		jQuery.fn[ funcName ] = function( margin, value ) {\n			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),\n				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );\n\n			return access( this, function( elem, type, value ) {\n				var doc;\n\n				if ( jQuery.isWindow( elem ) ) {\n\n					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there\n					// isn\'t a whole lot we can do. See pull request at this URL for discussion:\n					// https://github.com/jquery/jquery/pull/764\n					return elem.document.documentElement[ "client" + name ];\n				}\n\n				// Get document width or height\n				if ( elem.nodeType === 9 ) {\n					doc = elem.documentElement;\n\n					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n					// whichever is greatest\n					// unfortunately, this causes bug #3838 in IE6/8 only,\n					// but there is currently no good, small way to fix it.\n					return Math.max(\n						elem.body[ "scroll" + name ], doc[ "scroll" + name ],\n						elem.body[ "offset" + name ], doc[ "offset" + name ],\n						doc[ "client" + name ]\n					);\n				}\n\n				return value === undefined ?\n\n					// Get width or height on the element, requesting but not forcing parseFloat\n					jQuery.css( elem, type, extra ) :\n\n					// Set width or height on the element\n					jQuery.style( elem, type, value, extra );\n			}, type, chainable ? margin : undefined, chainable, null );\n		};\n	} );\n} );\n\n\njQuery.fn.extend( {\n\n	bind: function( types, data, fn ) {\n		return this.on( types, null, data, fn );\n	},\n	unbind: function( types, fn ) {\n		return this.off( types, null, fn );\n	},\n\n	delegate: function( selector, types, data, fn ) {\n		return this.on( types, selector, data, fn );\n	},\n	undelegate: function( selector, types, fn ) {\n\n		// ( namespace ) or ( selector, types [, fn] )\n		return arguments.length === 1 ?\n			this.off( selector, "**" ) :\n			this.off( types, selector || "**", fn );\n	}\n} );\n\n// The number of elements contained in the matched element set\njQuery.fn.size = function() {\n	return this.length;\n};\n\njQuery.fn.andSelf = jQuery.fn.addBack;\n\n\n\n\n// Register as a named AMD module, since jQuery can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase jquery is used because AMD module names are\n// derived from file names, and jQuery is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of jQuery, it will work.\n\n// Note that for maximum portability, libraries that are not jQuery should\n// declare themselves as anonymous modules, and avoid setting a global if an\n// AMD loader is present. jQuery is a special case. For more information, see\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\nif ( true ) {\n	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {\n		return jQuery;\n	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n}\n\n\n\nvar\n\n	// Map over jQuery in case of overwrite\n	_jQuery = window.jQuery,\n\n	// Map over the $ in case of overwrite\n	_$ = window.$;\n\njQuery.noConflict = function( deep ) {\n	if ( window.$ === jQuery ) {\n		window.$ = _$;\n	}\n\n	if ( deep && window.jQuery === jQuery ) {\n		window.jQuery = _jQuery;\n	}\n\n	return jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in\n// AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( !noGlobal ) {\n	window.jQuery = window.$ = jQuery;\n}\n\nreturn jQuery;\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jquery/dist/jquery.js\n ** module id = 2\n ** module chunks = 0 1\n **/\n//# sourceURL=webpack:///./~/jquery/dist/jquery.js?');
},function(module,exports,__webpack_require__){eval('\'use strict\';\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.renderShowcaseLevels = renderShowcaseLevels;\nexports.renderUserLevels = renderUserLevels;\nexports.renderStatusMessage = renderStatusMessage;\nexports.renderHeader = renderHeader;\nexports.renderLevelInit = renderLevelInit;\nexports.renderMenu = renderMenu;\nexports.renderGameArea = renderGameArea;\n\nvar _showcaseLevels = __webpack_require__(4);\n\nvar _showcaseLevels2 = _interopRequireDefault(_showcaseLevels);\n\nvar _config = __webpack_require__(5);\n\nvar _config2 = _interopRequireDefault(_config);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction renderShowcaseLevels() {\n  var dom = \'\';\n  _showcaseLevels2.default.forEach(function (show) {\n    dom += \'<div class="show-level"><a href="\' + _config2.default.server + \'/level/\' + show.levelID + \'">\\n      <div>\' + show.name + \'</div>\\n    </a></div>\';\n  });\n\n  return \'<div class="showcase">\\n    \' + dom + \'\\n  </div>\';\n}\n\nfunction renderUserLevels(levels) {\n  var dom = \'\';\n\n  levels.forEach(function (level) {\n    dom += \'<div class="show-level"><a href="\' + _config2.default.server + \'/level/\' + level.levelID + \'">\\n      <div>\' + level.name + \'</div>\\n    </a></div>\';\n  });\n\n  return \'<div class="userlevels">\\n    \' + dom + \'\\n  </div>\';\n}\n\nvar renderLevelSelection = function renderLevelSelection(levels) {\n  var dom = "";\n\n  levels.forEach(function (level, id) {\n    dom += \'<div class="level-selection" data-level-num="\' + id + \'">\\n      level \' + (id + 1) + \'\\n    </div>\';\n  });\n\n  return dom;\n};\n\nfunction renderStatusMessage(message, status) {\n  return \'<div class="message \' + status + \'">\\n    \' + message + \'\\n  </div>\';\n}\n\nfunction renderHeader(mode, name, r, c) {\n  return \'<div class="subtitle">\\n    <span class="mode-name">\' + mode + \'</span>  /  <span class="level-name">\' + name + \'</span>  /  <span class="size">\' + c + \'x\' + r + \'</span>\\n  </div>\';\n};\n\nfunction renderLevelInit() {\n  return \'<div class="level-init">\\n  <div class="param">\\n    <div class="title">enter a name for your custom level</div>\\n    <input type="text" class="level-name"/>\\n  </div>\\n  <br/>\\n  <div class="param head">\\n    <div class="title">choose a size for your level <span>(max. 4500 blocks)</span> </div>\\n  </div>\\n  <div class="param">\\n    <div class="title">width <span>(blocks)</span>: </div>\\n    <input type="text" class=\\\'columns\\\'/>\\n  </div>\\n  <div class="param">\\n    <div class="title">height <span>(blocks)</span>: </div>\\n    <input type="text" class=\\\'rows\\\'/>\\n  </div>\\n\\n  <br/>\\n\\n  <div class="param">\\n    <div class="status"></div>\\n  </div>\\n\\n  <div class="create-button">\\n    create level\\n  </div>\\n</div>\';\n}\n//      <div class="back-image"><img src="/img/examplelevel.png"/></div>\n\nfunction renderMenu(userLevels) {\n  return \'<div class="menu">\\n\\n    <div class="intro">\\n      <div class="back-image"><img src="/img/examplelevel.png"/></div>\\n      <div class="intro-content">\\n      <span class="headline">Create, Share & Play</span>\\n      <br/>\\n      <div>The game is simple. Avoid obstacles, jump over enemies and catch <span>the star</span></div>\\n      </div>\\n    </div>\\n\\n    <div class="create-menu">\\n      <div class="title">Play one of the user submitted levels or create your own!</div>\\n      <div class="create-level">\\n        <div class="btn">\\n          Create Level!\\n        </div>\\n      </div>\\n      <div class="bottom-border"></div>\\n    </div>\\n\\n    <div class="highlight">\\n      <div class="title">showcase levels</div>\\n      <br/>\\n      \' + renderShowcaseLevels() + \'\\n\\n      <div class="bottom-border"></div>\\n    </div>\\n\\n    <div class="usersub">\\n    <div class="title">user submitted levels</div>\\n    \' + renderUserLevels(userLevels) + \'\\n    </div>\\n\\n  </div>\';\n}\n\nfunction renderGameArea() {\n  return \'\\n  <div class="game">\\n    <div class="viewport">\\n      <div class="content"></div>\\n    </div>\\n  </div>\';\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/js/menu.js\n ** module id = 3\n ** module chunks = 0 1\n **/\n//# sourceURL=webpack:///./src/js/menu.js?')},function(module,exports){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = [{ name: 'Space Level', levelID: 'BkUaw0Q' }, { name: 'Custom Level', levelID: 'rJcom27' }];\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/data/showcaseLevels.js\n ** module id = 4\n ** module chunks = 0 1\n **/\n//# sourceURL=webpack:///./src/data/showcaseLevels.js?")},function(module,exports){eval('"use strict";\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.default = {\n  server: "http://localhost:3000"\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/data/config.js\n ** module id = 5\n ** module chunks = 0 1\n **/\n//# sourceURL=webpack:///./src/data/config.js?')},function(module,exports){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar e = 'sunset';\nvar o = 'wall';\n\nvar level1 = exports.level1 = {\n  row: 50,\n  column: 100,\n  roamingObjs: [{ type: 'fireball', dir: 'vertical', speed: 1, spawnX: 10, spawnY: 200 }, { type: 'snake', dir: 'horizontal', speed: 3, spawnX: 50, spawnY: 300 }],\n  arr: [[e, e, e, e, e, e, e, e, e, e, e, e, e, e, e], [e, e, e, e, e, e, e, e, e, e, e, e, e, e, o], [e, e, e, e, e, e, e, e, e, e, e, e, e, e, o], [e, e, e, e, e, e, e, e, e, e, e, e, e, e, o], [e, e, e, e, e, e, e, e, e, e, e, e, e, e, o], [e, e, e, e, e, e, e, e, e, e, e, e, e, e, o], [e, e, e, e, e, e, e, e, e, e, e, e, e, e, o], [e, e, e, e, e, e, e, e, e, e, e, e, e, e, o], [e, e, e, e, e, e, e, e, e, e, e, e, e, e, o], [e, e, e, e, e, e, e, e, e, e, e, e, e, e, o], [e, e, e, e, e, e, e, e, e, e, e, e, e, e, o], [e, e, e, e, e, e, e, e, e, e, e, e, e, e, o], [e, e, e, e, e, e, e, e, e, e, e, e, e, e, o], [e, e, e, e, e, e, e, e, e, e, e, e, e, e, o], [e, e, e, e, e, e, e, e, e, e, e, e, e, e, o], [e, e, e, e, e, e, e, e, e, e, e, e, e, e, o], [e, e, e, e, e, e, e, e, e, e, e, e, e, e, o], [e, e, e, e, e, e, e, e, e, e, e, e, e, e, o], [e, e, e, e, e, e, e, e, e, e, e, e, e, e, o], [o, o, o, o, o, o, o, o, o, o, o, o, o, o, o]]\n};\n\nvar level2 = exports.level2 = {\n  row: 50,\n  column: 100,\n  roamingObjs: [],\n  arr: [[e, e, e, e, e, e, e, e, e, e, e, e, e, e], [e, e, e, e, e, e, e, e, e, e, e, e, e, e], [e, e, e, e, e, e, e, e, e, e, e, e, e, e], [e, e, e, e, e, e, e, e, e, e, e, e, e, e], [e, e, e, e, e, e, e, e, e, e, e, e, e, e], [e, e, e, e, e, e, e, e, e, e, e, e, e, e], [e, e, e, e, e, e, e, e, e, e, e, e, e, e], [e, o, o, o, o, o, o, o, o, o, o, o, o, o], [e, e, e, e, e, e, e, e, e, e, e, e, e, e], [e, e, e, e, e, e, e, e, e, e, e, e, e, e], [e, e, e, e, e, e, e, e, e, e, e, e, e, e], [e, e, e, e, e, e, e, e, e, e, e, e, e, e], [e, e, e, e, e, e, e, e, e, e, e, e, e, e], [e, e, e, e, e, e, e, e, e, e, e, e, e, e], [e, e, e, e, e, e, e, e, e, e, e, e, e, e], [e, e, e, e, e, e, e, e, e, e, e, e, e, e], [e, e, e, e, e, e, e, e, e, e, e, e, e, e], [e, e, e, e, e, e, e, e, e, e, e, e, e, e], [e, e, e, e, e, e, e, e, e, e, e, e, e, e], [o, o, o, o, o, o, o, o, o, o, o, o, o, o]]\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/data/levels.js\n ** module id = 6\n ** module chunks = 0 1\n **/\n//# sourceURL=webpack:///./src/data/levels.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _stringify = __webpack_require__(8);\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _underscore = __webpack_require__(11);\n\nvar _underscore2 = _interopRequireDefault(_underscore);\n\nvar _Grid = __webpack_require__(12);\n\nvar _Grid2 = _interopRequireDefault(_Grid);\n\nvar _enemy = __webpack_require__(16);\n\nvar _enemy2 = _interopRequireDefault(_enemy);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Level = function Level(levelMap) {\n  this.init(levelMap);\n};\n\nLevel.prototype = {\n  grid: null,\n  arr: [[]],\n  roamingObjs: [],\n  column: 0,\n  row: 0,\n  sqSize: 20,\n  name: \"\",\n  playerSpawn: [0, 0],\n  starPosition: [0, 0],\n  sqMorph: {},\n\n  init: function init(levelMap) {\n    var _this = this;\n\n    this.column = levelMap.column;\n    this.row = levelMap.row;\n    this.arr = levelMap.arr;\n    this.roamingObjs = levelMap.roamingObjs;\n    this.sqMorph = levelMap.sqMorph || {}, this.name = levelMap.name || \"custom game\";\n\n    this.playerSpawn = levelMap.playerSpawn || [20, 20];\n    this.starPosition = levelMap.starPosition || [50, 50];\n\n    this.grid = new _Grid2.default(this.row, this.column, this.sqSize, this);\n\n    console.log(levelMap);\n\n    this.arr.forEach(function (r, rI) {\n      r.forEach(function (elem, cI) {\n        _this.grid.read(rI, cI).setState(elem);\n      });\n    });\n  },\n\n  addEnemy: function addEnemy(type, dir, speed, x, y) {\n    var n = this.roamingObjs.length;\n    this.roamingObjs.push({ type: type, dir: dir, speed: speed, id: 'enemy-' + n, spawnX: x, spawnY: y });\n\n    return 'enemy-' + n;\n  },\n\n  removeEnemy: function removeEnemy(id) {\n    this.roamingObjs = this.roamingObjs.filter(function (val) {\n      return val.id !== id;\n    });\n  },\n\n  placePlayer: function placePlayer(x, y) {\n    this.playerSpawn[0] = x;\n    this.playerSpawn[1] = y;\n  },\n\n  placeStar: function placeStar(x, y) {\n    this.starPosition[0] = x;\n    this.starPosition[1] = y;\n  },\n\n  placeMorph: function placeMorph(r, c, morphStates, delay, cycle_0, cycle_1) {\n    this.sqMorph[r + '-' + c] = { row: r, column: c, delay: delay, cycle_0: cycle_0, cycle_1: cycle_1, state1: morphStates[0], state2: morphStates[1] };\n  },\n\n  removeMorph: function removeMorph(r, c) {\n    this.sqMorph = _underscore2.default.omit(this.sqMorph, r + '-' + c);\n  },\n\n  extract: function extract() {\n    return {\n      name: this.name,\n      row: this.row,\n      column: this.column,\n      arr: (0, _stringify2.default)(this.extractGrid()),\n      roamingObjs: (0, _stringify2.default)(this.roamingObjs),\n      sqMorph: (0, _stringify2.default)(this.sqMorph),\n      starPosition: this.starPosition,\n      playerSpawn: this.playerSpawn\n    };\n  },\n\n  extractGrid: function extractGrid() {\n\n    var arr = [];\n\n    for (var r = 0; r < this.row; r++) {\n      var nRow = [];\n      for (var c = 0; c < this.column; c++) {\n        nRow.push(this.grid.read(r, c).state);\n      }\n      arr.push(nRow);\n    }\n\n    /*    this.grid.forEach((r) => {\r\n          let nRow = [];\r\n          r.forEach((elem) => {\r\n            nRow.push(elem.state);\r\n          })\r\n          arr.push(nRow);\r\n        })\r\n    */\n    return arr;\n  },\n\n  update: function update(r, c, state) {\n    this.grid.update([r, c], state);\n  }\n\n};\n\nexports.default = Level;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/js/level.js\n ** module id = 7\n ** module chunks = 0 1\n **/\n//# sourceURL=webpack:///./src/js/level.js?")},function(module,exports,__webpack_require__){eval('module.exports = { "default": __webpack_require__(9), __esModule: true };\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/core-js/json/stringify.js\n ** module id = 8\n ** module chunks = 0 1\n **/\n//# sourceURL=webpack:///./~/babel-runtime/core-js/json/stringify.js?')},function(module,exports,__webpack_require__){eval("var core = __webpack_require__(10);\nmodule.exports = function stringify(it){ // eslint-disable-line no-unused-vars\n  return (core.JSON && core.JSON.stringify || JSON.stringify).apply(JSON, arguments);\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/fn/json/stringify.js\n ** module id = 9\n ** module chunks = 0 1\n **/\n//# sourceURL=webpack:///./~/babel-runtime/~/core-js/library/fn/json/stringify.js?")},function(module,exports){eval("var core = module.exports = {version: '1.2.6'};\nif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.core.js\n ** module id = 10\n ** module chunks = 0 1\n **/\n//# sourceURL=webpack:///./~/babel-runtime/~/core-js/library/modules/$.core.js?")},function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.8.3\n//     http://underscorejs.org\n//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `exports` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var\n    push             = ArrayProto.push,\n    slice            = ArrayProto.slice,\n    toString         = ObjProto.toString,\n    hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind,\n    nativeCreate       = Object.create;\n\n  // Naked function reference for surrogate-prototype-swapping.\n  var Ctor = function(){};\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object.\n  if (true) {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.8.3';\n\n  // Internal function that returns an efficient (for current engines) version\n  // of the passed-in callback, to be repeatedly applied in other Underscore\n  // functions.\n  var optimizeCb = function(func, context, argCount) {\n    if (context === void 0) return func;\n    switch (argCount == null ? 3 : argCount) {\n      case 1: return function(value) {\n        return func.call(context, value);\n      };\n      case 2: return function(value, other) {\n        return func.call(context, value, other);\n      };\n      case 3: return function(value, index, collection) {\n        return func.call(context, value, index, collection);\n      };\n      case 4: return function(accumulator, value, index, collection) {\n        return func.call(context, accumulator, value, index, collection);\n      };\n    }\n    return function() {\n      return func.apply(context, arguments);\n    };\n  };\n\n  // A mostly-internal function to generate callbacks that can be applied\n  // to each element in a collection, returning the desired result — either\n  // identity, an arbitrary callback, a property matcher, or a property accessor.\n  var cb = function(value, context, argCount) {\n    if (value == null) return _.identity;\n    if (_.isFunction(value)) return optimizeCb(value, context, argCount);\n    if (_.isObject(value)) return _.matcher(value);\n    return _.property(value);\n  };\n  _.iteratee = function(value, context) {\n    return cb(value, context, Infinity);\n  };\n\n  // An internal function for creating assigner functions.\n  var createAssigner = function(keysFunc, undefinedOnly) {\n    return function(obj) {\n      var length = arguments.length;\n      if (length < 2 || obj == null) return obj;\n      for (var index = 1; index < length; index++) {\n        var source = arguments[index],\n            keys = keysFunc(source),\n            l = keys.length;\n        for (var i = 0; i < l; i++) {\n          var key = keys[i];\n          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];\n        }\n      }\n      return obj;\n    };\n  };\n\n  // An internal function for creating a new object that inherits from another.\n  var baseCreate = function(prototype) {\n    if (!_.isObject(prototype)) return {};\n    if (nativeCreate) return nativeCreate(prototype);\n    Ctor.prototype = prototype;\n    var result = new Ctor;\n    Ctor.prototype = null;\n    return result;\n  };\n\n  var property = function(key) {\n    return function(obj) {\n      return obj == null ? void 0 : obj[key];\n    };\n  };\n\n  // Helper for collection methods to determine whether a collection\n  // should be iterated as an array or as an object\n  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength\n  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094\n  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n  var getLength = property('length');\n  var isArrayLike = function(collection) {\n    var length = getLength(collection);\n    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;\n  };\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles raw objects in addition to array-likes. Treats all\n  // sparse array-likes as if they were dense.\n  _.each = _.forEach = function(obj, iteratee, context) {\n    iteratee = optimizeCb(iteratee, context);\n    var i, length;\n    if (isArrayLike(obj)) {\n      for (i = 0, length = obj.length; i < length; i++) {\n        iteratee(obj[i], i, obj);\n      }\n    } else {\n      var keys = _.keys(obj);\n      for (i = 0, length = keys.length; i < length; i++) {\n        iteratee(obj[keys[i]], keys[i], obj);\n      }\n    }\n    return obj;\n  };\n\n  // Return the results of applying the iteratee to each element.\n  _.map = _.collect = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length,\n        results = Array(length);\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      results[index] = iteratee(obj[currentKey], currentKey, obj);\n    }\n    return results;\n  };\n\n  // Create a reducing function iterating left or right.\n  function createReduce(dir) {\n    // Optimized iterator function as using arguments.length\n    // in the main function will deoptimize the, see #1991.\n    function iterator(obj, iteratee, memo, keys, index, length) {\n      for (; index >= 0 && index < length; index += dir) {\n        var currentKey = keys ? keys[index] : index;\n        memo = iteratee(memo, obj[currentKey], currentKey, obj);\n      }\n      return memo;\n    }\n\n    return function(obj, iteratee, memo, context) {\n      iteratee = optimizeCb(iteratee, context, 4);\n      var keys = !isArrayLike(obj) && _.keys(obj),\n          length = (keys || obj).length,\n          index = dir > 0 ? 0 : length - 1;\n      // Determine the initial value if none is provided.\n      if (arguments.length < 3) {\n        memo = obj[keys ? keys[index] : index];\n        index += dir;\n      }\n      return iterator(obj, iteratee, memo, keys, index, length);\n    };\n  }\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`.\n  _.reduce = _.foldl = _.inject = createReduce(1);\n\n  // The right-associative version of reduce, also known as `foldr`.\n  _.reduceRight = _.foldr = createReduce(-1);\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, predicate, context) {\n    var key;\n    if (isArrayLike(obj)) {\n      key = _.findIndex(obj, predicate, context);\n    } else {\n      key = _.findKey(obj, predicate, context);\n    }\n    if (key !== void 0 && key !== -1) return obj[key];\n  };\n\n  // Return all the elements that pass a truth test.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, predicate, context) {\n    var results = [];\n    predicate = cb(predicate, context);\n    _.each(obj, function(value, index, list) {\n      if (predicate(value, index, list)) results.push(value);\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, predicate, context) {\n    return _.filter(obj, _.negate(cb(predicate)), context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (!predicate(obj[currentKey], currentKey, obj)) return false;\n    }\n    return true;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Aliased as `any`.\n  _.some = _.any = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (predicate(obj[currentKey], currentKey, obj)) return true;\n    }\n    return false;\n  };\n\n  // Determine if the array or object contains a given item (using `===`).\n  // Aliased as `includes` and `include`.\n  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {\n    if (!isArrayLike(obj)) obj = _.values(obj);\n    if (typeof fromIndex != 'number' || guard) fromIndex = 0;\n    return _.indexOf(obj, item, fromIndex) >= 0;\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    var isFunc = _.isFunction(method);\n    return _.map(obj, function(value) {\n      var func = isFunc ? method : value[method];\n      return func == null ? func : func.apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, _.property(key));\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs) {\n    return _.filter(obj, _.matcher(attrs));\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.find(obj, _.matcher(attrs));\n  };\n\n  // Return the maximum element (or element-based computation).\n  _.max = function(obj, iteratee, context) {\n    var result = -Infinity, lastComputed = -Infinity,\n        value, computed;\n    if (iteratee == null && obj != null) {\n      obj = isArrayLike(obj) ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value > result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index, list) {\n        computed = iteratee(value, index, list);\n        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {\n          result = value;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iteratee, context) {\n    var result = Infinity, lastComputed = Infinity,\n        value, computed;\n    if (iteratee == null && obj != null) {\n      obj = isArrayLike(obj) ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value < result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index, list) {\n        computed = iteratee(value, index, list);\n        if (computed < lastComputed || computed === Infinity && result === Infinity) {\n          result = value;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Shuffle a collection, using the modern version of the\n  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).\n  _.shuffle = function(obj) {\n    var set = isArrayLike(obj) ? obj : _.values(obj);\n    var length = set.length;\n    var shuffled = Array(length);\n    for (var index = 0, rand; index < length; index++) {\n      rand = _.random(0, index);\n      if (rand !== index) shuffled[index] = shuffled[rand];\n      shuffled[rand] = set[index];\n    }\n    return shuffled;\n  };\n\n  // Sample **n** random values from a collection.\n  // If **n** is not specified, returns a single random element.\n  // The internal `guard` argument allows it to work with `map`.\n  _.sample = function(obj, n, guard) {\n    if (n == null || guard) {\n      if (!isArrayLike(obj)) obj = _.values(obj);\n      return obj[_.random(obj.length - 1)];\n    }\n    return _.shuffle(obj).slice(0, Math.max(0, n));\n  };\n\n  // Sort the object's values by a criterion produced by an iteratee.\n  _.sortBy = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value: value,\n        index: index,\n        criteria: iteratee(value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index - right.index;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(behavior) {\n    return function(obj, iteratee, context) {\n      var result = {};\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index) {\n        var key = iteratee(value, index, obj);\n        behavior(result, value, key);\n      });\n      return result;\n    };\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = group(function(result, value, key) {\n    if (_.has(result, key)) result[key].push(value); else result[key] = [value];\n  });\n\n  // Indexes the object's values by a criterion, similar to `groupBy`, but for\n  // when you know that your index values will be unique.\n  _.indexBy = group(function(result, value, key) {\n    result[key] = value;\n  });\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = group(function(result, value, key) {\n    if (_.has(result, key)) result[key]++; else result[key] = 1;\n  });\n\n  // Safely create a real, live array from anything iterable.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (isArrayLike(obj)) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return isArrayLike(obj) ? obj.length : _.keys(obj).length;\n  };\n\n  // Split a collection into two arrays: one whose elements all satisfy the given\n  // predicate, and one whose elements all do not satisfy the predicate.\n  _.partition = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var pass = [], fail = [];\n    _.each(obj, function(value, key, obj) {\n      (predicate(value, key, obj) ? pass : fail).push(value);\n    });\n    return [pass, fail];\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    if (n == null || guard) return array[0];\n    return _.initial(array, array.length - n);\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if (n == null || guard) return array[array.length - 1];\n    return _.rest(array, Math.max(0, array.length - n));\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, n == null || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, strict, startIndex) {\n    var output = [], idx = 0;\n    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {\n      var value = input[i];\n      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {\n        //flatten current level of array or arguments object\n        if (!shallow) value = flatten(value, shallow, strict);\n        var j = 0, len = value.length;\n        output.length += len;\n        while (j < len) {\n          output[idx++] = value[j++];\n        }\n      } else if (!strict) {\n        output[idx++] = value;\n      }\n    }\n    return output;\n  };\n\n  // Flatten out an array, either recursively (by default), or just one level.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, false);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iteratee, context) {\n    if (!_.isBoolean(isSorted)) {\n      context = iteratee;\n      iteratee = isSorted;\n      isSorted = false;\n    }\n    if (iteratee != null) iteratee = cb(iteratee, context);\n    var result = [];\n    var seen = [];\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var value = array[i],\n          computed = iteratee ? iteratee(value, i, array) : value;\n      if (isSorted) {\n        if (!i || seen !== computed) result.push(value);\n        seen = computed;\n      } else if (iteratee) {\n        if (!_.contains(seen, computed)) {\n          seen.push(computed);\n          result.push(value);\n        }\n      } else if (!_.contains(result, value)) {\n        result.push(value);\n      }\n    }\n    return result;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(flatten(arguments, true, true));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var result = [];\n    var argsLength = arguments.length;\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var item = array[i];\n      if (_.contains(result, item)) continue;\n      for (var j = 1; j < argsLength; j++) {\n        if (!_.contains(arguments[j], item)) break;\n      }\n      if (j === argsLength) result.push(item);\n    }\n    return result;\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = flatten(arguments, true, true, 1);\n    return _.filter(array, function(value){\n      return !_.contains(rest, value);\n    });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    return _.unzip(arguments);\n  };\n\n  // Complement of _.zip. Unzip accepts an array of arrays and groups\n  // each array's elements on shared indices\n  _.unzip = function(array) {\n    var length = array && _.max(array, getLength).length || 0;\n    var result = Array(length);\n\n    for (var index = 0; index < length; index++) {\n      result[index] = _.pluck(array, index);\n    }\n    return result;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    var result = {};\n    for (var i = 0, length = getLength(list); i < length; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // Generator function to create the findIndex and findLastIndex functions\n  function createPredicateIndexFinder(dir) {\n    return function(array, predicate, context) {\n      predicate = cb(predicate, context);\n      var length = getLength(array);\n      var index = dir > 0 ? 0 : length - 1;\n      for (; index >= 0 && index < length; index += dir) {\n        if (predicate(array[index], index, array)) return index;\n      }\n      return -1;\n    };\n  }\n\n  // Returns the first index on an array-like that passes a predicate test\n  _.findIndex = createPredicateIndexFinder(1);\n  _.findLastIndex = createPredicateIndexFinder(-1);\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iteratee, context) {\n    iteratee = cb(iteratee, context, 1);\n    var value = iteratee(obj);\n    var low = 0, high = getLength(array);\n    while (low < high) {\n      var mid = Math.floor((low + high) / 2);\n      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;\n    }\n    return low;\n  };\n\n  // Generator function to create the indexOf and lastIndexOf functions\n  function createIndexFinder(dir, predicateFind, sortedIndex) {\n    return function(array, item, idx) {\n      var i = 0, length = getLength(array);\n      if (typeof idx == 'number') {\n        if (dir > 0) {\n            i = idx >= 0 ? idx : Math.max(idx + length, i);\n        } else {\n            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;\n        }\n      } else if (sortedIndex && idx && length) {\n        idx = sortedIndex(array, item);\n        return array[idx] === item ? idx : -1;\n      }\n      if (item !== item) {\n        idx = predicateFind(slice.call(array, i, length), _.isNaN);\n        return idx >= 0 ? idx + i : -1;\n      }\n      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {\n        if (array[idx] === item) return idx;\n      }\n      return -1;\n    };\n  }\n\n  // Return the position of the first occurrence of an item in an array,\n  // or -1 if the item is not included in the array.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);\n  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (stop == null) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = step || 1;\n\n    var length = Math.max(Math.ceil((stop - start) / step), 0);\n    var range = Array(length);\n\n    for (var idx = 0; idx < length; idx++, start += step) {\n      range[idx] = start;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Determines whether to execute a function as a constructor\n  // or a normal function with the provided arguments\n  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {\n    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);\n    var self = baseCreate(sourceFunc.prototype);\n    var result = sourceFunc.apply(self, args);\n    if (_.isObject(result)) return result;\n    return self;\n  };\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = function(func, context) {\n    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');\n    var args = slice.call(arguments, 2);\n    var bound = function() {\n      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));\n    };\n    return bound;\n  };\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context. _ acts\n  // as a placeholder, allowing any combination of arguments to be pre-filled.\n  _.partial = function(func) {\n    var boundArgs = slice.call(arguments, 1);\n    var bound = function() {\n      var position = 0, length = boundArgs.length;\n      var args = Array(length);\n      for (var i = 0; i < length; i++) {\n        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];\n      }\n      while (position < arguments.length) args.push(arguments[position++]);\n      return executeBound(func, bound, this, this, args);\n    };\n    return bound;\n  };\n\n  // Bind a number of an object's methods to that object. Remaining arguments\n  // are the method names to be bound. Useful for ensuring that all callbacks\n  // defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var i, length = arguments.length, key;\n    if (length <= 1) throw new Error('bindAll must be passed function names');\n    for (i = 1; i < length; i++) {\n      key = arguments[i];\n      obj[key] = _.bind(obj[key], obj);\n    }\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memoize = function(key) {\n      var cache = memoize.cache;\n      var address = '' + (hasher ? hasher.apply(this, arguments) : key);\n      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);\n      return cache[address];\n    };\n    memoize.cache = {};\n    return memoize;\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){\n      return func.apply(null, args);\n    }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = _.partial(_.delay, _, 1);\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  _.throttle = function(func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    if (!options) options = {};\n    var later = function() {\n      previous = options.leading === false ? 0 : _.now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n    return function() {\n      var now = _.now();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, args, context, timestamp, result;\n\n    var later = function() {\n      var last = _.now() - timestamp;\n\n      if (last < wait && last >= 0) {\n        timeout = setTimeout(later, wait - last);\n      } else {\n        timeout = null;\n        if (!immediate) {\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        }\n      }\n    };\n\n    return function() {\n      context = this;\n      args = arguments;\n      timestamp = _.now();\n      var callNow = immediate && !timeout;\n      if (!timeout) timeout = setTimeout(later, wait);\n      if (callNow) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n\n      return result;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return _.partial(wrapper, func);\n  };\n\n  // Returns a negated version of the passed-in predicate.\n  _.negate = function(predicate) {\n    return function() {\n      return !predicate.apply(this, arguments);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var args = arguments;\n    var start = args.length - 1;\n    return function() {\n      var i = start;\n      var result = args[start].apply(this, arguments);\n      while (i--) result = args[i].call(this, result);\n      return result;\n    };\n  };\n\n  // Returns a function that will only be executed on and after the Nth call.\n  _.after = function(times, func) {\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Returns a function that will only be executed up to (but not including) the Nth call.\n  _.before = function(times, func) {\n    var memo;\n    return function() {\n      if (--times > 0) {\n        memo = func.apply(this, arguments);\n      }\n      if (times <= 1) func = null;\n      return memo;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = _.partial(_.before, 2);\n\n  // Object Functions\n  // ----------------\n\n  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.\n  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');\n  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',\n                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];\n\n  function collectNonEnumProps(obj, keys) {\n    var nonEnumIdx = nonEnumerableProps.length;\n    var constructor = obj.constructor;\n    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;\n\n    // Constructor is a special case.\n    var prop = 'constructor';\n    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);\n\n    while (nonEnumIdx--) {\n      prop = nonEnumerableProps[nonEnumIdx];\n      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {\n        keys.push(prop);\n      }\n    }\n  }\n\n  // Retrieve the names of an object's own properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    if (nativeKeys) return nativeKeys(obj);\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  };\n\n  // Retrieve all the property names of an object.\n  _.allKeys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    var keys = [];\n    for (var key in obj) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var values = Array(length);\n    for (var i = 0; i < length; i++) {\n      values[i] = obj[keys[i]];\n    }\n    return values;\n  };\n\n  // Returns the results of applying the iteratee to each element of the object\n  // In contrast to _.map it returns an object\n  _.mapObject = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var keys =  _.keys(obj),\n          length = keys.length,\n          results = {},\n          currentKey;\n      for (var index = 0; index < length; index++) {\n        currentKey = keys[index];\n        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);\n      }\n      return results;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var pairs = Array(length);\n    for (var i = 0; i < length; i++) {\n      pairs[i] = [keys[i], obj[keys[i]]];\n    }\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    var keys = _.keys(obj);\n    for (var i = 0, length = keys.length; i < length; i++) {\n      result[obj[keys[i]]] = keys[i];\n    }\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = createAssigner(_.allKeys);\n\n  // Assigns a given object with all the own properties in the passed-in object(s)\n  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n  _.extendOwn = _.assign = createAssigner(_.keys);\n\n  // Returns the first key on an object that passes a predicate test\n  _.findKey = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = _.keys(obj), key;\n    for (var i = 0, length = keys.length; i < length; i++) {\n      key = keys[i];\n      if (predicate(obj[key], key, obj)) return key;\n    }\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(object, oiteratee, context) {\n    var result = {}, obj = object, iteratee, keys;\n    if (obj == null) return result;\n    if (_.isFunction(oiteratee)) {\n      keys = _.allKeys(obj);\n      iteratee = optimizeCb(oiteratee, context);\n    } else {\n      keys = flatten(arguments, false, false, 1);\n      iteratee = function(value, key, obj) { return key in obj; };\n      obj = Object(obj);\n    }\n    for (var i = 0, length = keys.length; i < length; i++) {\n      var key = keys[i];\n      var value = obj[key];\n      if (iteratee(value, key, obj)) result[key] = value;\n    }\n    return result;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj, iteratee, context) {\n    if (_.isFunction(iteratee)) {\n      iteratee = _.negate(iteratee);\n    } else {\n      var keys = _.map(flatten(arguments, false, false, 1), String);\n      iteratee = function(value, key) {\n        return !_.contains(keys, key);\n      };\n    }\n    return _.pick(obj, iteratee, context);\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = createAssigner(_.allKeys, true);\n\n  // Creates an object that inherits from the given prototype object.\n  // If additional properties are provided then they will be added to the\n  // created object.\n  _.create = function(prototype, props) {\n    var result = baseCreate(prototype);\n    if (props) _.extendOwn(result, props);\n    return result;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Returns whether an object has a given set of `key:value` pairs.\n  _.isMatch = function(object, attrs) {\n    var keys = _.keys(attrs), length = keys.length;\n    if (object == null) return !length;\n    var obj = Object(object);\n    for (var i = 0; i < length; i++) {\n      var key = keys[i];\n      if (attrs[key] !== obj[key] || !(key in obj)) return false;\n    }\n    return true;\n  };\n\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) return a !== 0 || 1 / a === 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className !== toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, regular expressions, dates, and booleans are compared by value.\n      case '[object RegExp]':\n      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return '' + a === '' + b;\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive.\n        // Object(NaN) is equivalent to NaN\n        if (+a !== +a) return +b !== +b;\n        // An `egal` comparison is performed for other numeric values.\n        return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a === +b;\n    }\n\n    var areArrays = className === '[object Array]';\n    if (!areArrays) {\n      if (typeof a != 'object' || typeof b != 'object') return false;\n\n      // Objects with different constructors are not equivalent, but `Object`s or `Array`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&\n                               _.isFunction(bCtor) && bCtor instanceof bCtor)\n                          && ('constructor' in a && 'constructor' in b)) {\n        return false;\n      }\n    }\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n\n    // Initializing stack of traversed objects.\n    // It's done here since we only need them for objects and arrays comparison.\n    aStack = aStack || [];\n    bStack = bStack || [];\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] === a) return bStack[length] === b;\n    }\n\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n\n    // Recursively compare objects and arrays.\n    if (areArrays) {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      length = a.length;\n      if (length !== b.length) return false;\n      // Deep compare the contents, ignoring non-numeric properties.\n      while (length--) {\n        if (!eq(a[length], b[length], aStack, bStack)) return false;\n      }\n    } else {\n      // Deep compare objects.\n      var keys = _.keys(a), key;\n      length = keys.length;\n      // Ensure that both objects contain the same number of properties before comparing deep equality.\n      if (_.keys(b).length !== length) return false;\n      while (length--) {\n        // Deep compare each member\n        key = keys[length];\n        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return true;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;\n    return _.keys(obj).length === 0;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) === '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    var type = typeof obj;\n    return type === 'function' || type === 'object' && !!obj;\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.\n  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) === '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE < 9), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return _.has(obj, 'callee');\n    };\n  }\n\n  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,\n  // IE 11 (#1621), and in Safari 8 (#1929).\n  if (typeof /./ != 'function' && typeof Int8Array != 'object') {\n    _.isFunction = function(obj) {\n      return typeof obj == 'function' || false;\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj !== +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return obj != null && hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iteratees.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Predicate-generating functions. Often useful outside of Underscore.\n  _.constant = function(value) {\n    return function() {\n      return value;\n    };\n  };\n\n  _.noop = function(){};\n\n  _.property = property;\n\n  // Generates a function for a given object that returns a given property.\n  _.propertyOf = function(obj) {\n    return obj == null ? function(){} : function(key) {\n      return obj[key];\n    };\n  };\n\n  // Returns a predicate for checking whether an object has a given set of\n  // `key:value` pairs.\n  _.matcher = _.matches = function(attrs) {\n    attrs = _.extendOwn({}, attrs);\n    return function(obj) {\n      return _.isMatch(obj, attrs);\n    };\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iteratee, context) {\n    var accum = Array(Math.max(0, n));\n    iteratee = optimizeCb(iteratee, context, 1);\n    for (var i = 0; i < n; i++) accum[i] = iteratee(i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // A (possibly faster) way to get the current timestamp as an integer.\n  _.now = Date.now || function() {\n    return new Date().getTime();\n  };\n\n   // List of HTML entities for escaping.\n  var escapeMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '`': '&#x60;'\n  };\n  var unescapeMap = _.invert(escapeMap);\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  var createEscaper = function(map) {\n    var escaper = function(match) {\n      return map[match];\n    };\n    // Regexes for identifying a key that needs to be escaped\n    var source = '(?:' + _.keys(map).join('|') + ')';\n    var testRegexp = RegExp(source);\n    var replaceRegexp = RegExp(source, 'g');\n    return function(string) {\n      string = string == null ? '' : '' + string;\n      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\n    };\n  };\n  _.escape = createEscaper(escapeMap);\n  _.unescape = createEscaper(unescapeMap);\n\n  // If the value of the named `property` is a function then invoke it with the\n  // `object` as context; otherwise, return it.\n  _.result = function(object, property, fallback) {\n    var value = object == null ? void 0 : object[property];\n    if (value === void 0) {\n      value = fallback;\n    }\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\n  var escapeChar = function(match) {\n    return '\\\\' + escapes[match];\n  };\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  // NB: `oldSettings` only exists for backwards compatibility.\n  _.template = function(text, settings, oldSettings) {\n    if (!settings && oldSettings) settings = oldSettings;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset).replace(escaper, escapeChar);\n      index = offset + match.length;\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      } else if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      } else if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n\n      // Adobe VMs need the match returned to produce the correct offest.\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + 'return __p;\\n';\n\n    try {\n      var render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled source as a convenience for precompilation.\n    var argument = settings.variable || 'obj';\n    template.source = 'function(' + argument + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function. Start chaining a wrapped Underscore object.\n  _.chain = function(obj) {\n    var instance = _(obj);\n    instance._chain = true;\n    return instance;\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(instance, obj) {\n    return instance._chain ? _(obj).chain() : obj;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    _.each(_.functions(obj), function(name) {\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];\n      return result(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  _.each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  // Extracts the result from a wrapped and chained object.\n  _.prototype.value = function() {\n    return this._wrapped;\n  };\n\n  // Provide unwrapping proxy for some methods used in engine operations\n  // such as arithmetic and JSON stringification.\n  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;\n\n  _.prototype.toString = function() {\n    return '' + this._wrapped;\n  };\n\n  // AMD registration happens at the end for compatibility with AMD loaders\n  // that may not enforce next-turn semantics on modules. Even though general\n  // practice for AMD registration is to be anonymous, underscore registers\n  // as a named module because, like jQuery, it is a base library that is\n  // popular enough to be bundled in a third party lib, but not be part of\n  // an AMD load request. Those cases could generate an error when an\n  // anonymous define() is called outside of a loader request.\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {\n      return _;\n    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n}.call(this));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/underscore/underscore.js\n ** module id = 11\n ** module chunks = 0 1\n **/\n//# sourceURL=webpack:///./~/underscore/underscore.js?");
},function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _jquery = __webpack_require__(2);\n\nvar _jquery2 = _interopRequireDefault(_jquery);\n\nvar _Array2d = __webpack_require__(13);\n\nvar _Array2d2 = _interopRequireDefault(_Array2d);\n\nvar _Square = __webpack_require__(14);\n\nvar _Square2 = _interopRequireDefault(_Square);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction Grid(height, width, sqSize, level) {\n  this.height = height;\n  this.width = width;\n  this.level = level;\n  this.sqSize = sqSize;\n\n  this.array = new _Array2d2.default(height, width);\n  this.populate();\n}\n\nGrid.prototype = {\n  sqSize: 20,\n  array: [[]],\n  squaresInFocus: [],\n  mouseDown: false,\n  editBlockType: 'wall',\n  level: null,\n  editEnemy: false,\n  editEnemyType: 'fireball',\n  editEnemyDir: 'vertical',\n  editEnemySpeed: 2,\n  editBlockMorphable: false,\n  editBlockDelay: 0.5,\n  editBlockCycle_0: 2,\n  editBlockCycle_1: 2,\n  editBlockMorphStates: ['green-wall', 'empty'],\n  placePlayerMarker: false,\n  placeStarMarker: false,\n  brushX: 1,\n  brushY: 1,\n  sqMarker: [-1, -1],\n\n  editMode: 'block',\n\n  populate: function populate() {\n    for (var r = 0; r < this.height; r++) {\n      for (var c = 0; c < this.width; c++) {\n        this.array.write(r, c, new _Square2.default(r, c, this.sqSize, this));\n      }\n    }\n  },\n\n  read: function read(r, c) {\n    return this.array.read(r, c);\n  },\n\n  write: function write(r, c, val) {\n    this.array.write(r, c, val);\n  },\n\n  print: function print() {\n    this.array.print();\n  },\n\n  forEach: function forEach(fn) {\n    this.array.forEach(fn);\n  },\n\n  clear: function clear() {\n    this.array.forEach(function (elem) {\n      elem.setState('empty');\n    });\n    return this.render();\n  },\n\n  render: function render() {\n    var html = \"\";\n    this.forEach(function (square) {\n      html += square.render();\n      square.morphable = false;\n      square.run();\n      console.log(square.state);\n    });\n    return html;\n  },\n\n  registerEditorInput: function registerEditorInput() {\n    var _this = this;\n\n    (0, _jquery2.default)('.enemy-marker').click(function (e) {\n      console.log('MARKER!!');\n      if (_this.editMode === 'erase') {\n        var id = e.target.getAttribute('data-enemy-id');\n        console.log(\"delete id \" + id);\n        (0, _jquery2.default)(e.target).remove();\n\n        _this.level.removeEnemy(id);\n      }\n    });\n  },\n\n  squareAt: function squareAt(pos) {\n    var x = pos[0];\n    var y = pos[1];\n\n    y = Math.floor(y / this.sqSize);\n    x = Math.floor(x / this.sqSize);\n\n    return this.read(y, x);\n  },\n\n  morphStates: function morphStates(index) {\n    var morphState = this.editBlockMorphStates[index];\n    return morphState;\n  },\n\n  activateSquares: function activateSquares() {\n    this.forEach(function (square) {\n      square.editing = true;\n      square.morphable = false;\n      square.run();\n    });\n  },\n\n  activateMorph: function activateMorph() {\n    for (var key in this.level.sqMorph) {\n      var obj = this.level.sqMorph[key];\n      var sq = this.read(obj.row, obj.column);\n      sq.morphable = true;\n      sq.delay = obj.delay;\n      sq.cycle_0 = obj.cycle_0;\n      sq.cycle_1 = obj.cycle_1;\n      sq.morphState_0 = obj.state1;\n      sq.morphState_1 = obj.state2;\n      sq.init();\n    }\n  },\n\n  suspendSquares: function suspendSquares() {\n    this.forEach(function (square) {\n      square.editing = false;\n    });\n  },\n\n  removeSquareMarker: function removeSquareMarker(r, c) {\n    var sq = this.read(r, c);\n    sq.update(sq.prevState);\n  },\n\n  addSquareMarker: function addSquareMarker(r, c) {\n    var sq = this.read(r, c);\n    sq.update(this.editBlockType);\n  },\n\n  unmarkSquare: function unmarkSquare(r, c) {\n    if (this.editMode === \"block\") {\n      this.unbrush(r, c);\n    } else this.read(r, c).update(this.read(r, c).prevState);\n  },\n\n  markSquare: function markSquare(r, c) {\n    var sq = this.read(r, c);\n\n    switch (this.editMode) {\n      case \"block\":\n        {\n          //sq.update(this.editBlockType); break;\n          this.brush(false, r, c);break;\n        }\n      case \"enemy\":\n        {\n          sq.update('enemy-marker ' + this.editEnemyType);break;\n        }\n      case \"erase\":\n        {\n          sq.update(sq.state);\n          break;\n        }\n      case \"star\":\n        {\n          sq.update('star-marker');break;\n        }\n      case \"player\":\n        {\n          sq.update('player-marker');break;\n        }\n      case \"morph\":\n        {\n          sq.update('' + this.editBlockMorphStates[0]);break;\n        }\n    }\n  },\n\n  modSquare: function modSquare(r, c) {\n    switch (this.editMode) {\n      case \"block\":\n        {\n          this.brush(true, r, c);break;\n          /*let sq = this.read(r,c);\r\n          sq.suspendMorph();\r\n          this.removeMorph(r,c);\r\n          sq.update(this.editBlockType); break;*/\n        }\n      case \"enemy\":\n        {\n          this.addEnemy(r, c);break;\n        }\n      case \"erase\":\n        {\n          break;\n        }\n      case \"star\":\n        {\n          //this.unmarkSquare(r,c);\n          this.placeStar(r, c);break;\n        }\n      case \"player\":\n        {\n          //this.unmarkSquare(r,c);\n          this.placePlayer(r, c);break;\n        }\n      case \"morph\":\n        {\n          this.read(r, c).morphable = false;\n          this.placeMorph(r, c);break;\n        }\n    }\n  },\n\n  renderEnemyMarker: function renderEnemyMarker(type, x, y, id) {\n    console.log(x + \"~~~~~~~~\" + y);\n    return '<div data-enemy-id=\"' + id + '\" class=\"placeholder enemy-marker ' + type + '\" style=\"height:' + this.sqSize + 'px; width:' + this.sqSize + 'px; top:' + y + 'px; left:' + x + 'px;\"></div>';\n  },\n\n  renderPlayerMarker: function renderPlayerMarker(x, y) {\n    (0, _jquery2.default)('.placeholder.player-marker').remove();\n    return '<div class=\"placeholder square player-marker\" style=\"height:' + 0.7 * this.sqSize + 'px; width:' + 0.7 * this.sqSize + 'px; top:' + y + 'px; left:' + x + 'px;\"></div>';\n  },\n\n  renderAllEnemyMarkers: function renderAllEnemyMarkers() {\n    var _this2 = this;\n\n    var dom = \"\";\n    this.level.roamingObjs.forEach(function (obj) {\n      dom += _this2.renderEnemyMarker(obj.type, obj.spawnX, obj.spawnY, obj.id);\n    });\n\n    return dom;\n  },\n\n  renderStarMarker: function renderStarMarker(x, y) {\n    (0, _jquery2.default)('.placeholder.star-marker').remove();\n    return '<div class=\"placeholder square star-marker\" style=\"height:' + 0.7 * this.sqSize + 'px; width:' + 0.7 * this.sqSize + 'px; top:' + y + 'px; left:' + x + 'px;\"></div>';\n  },\n\n  unbrush: function unbrush(r, c) {\n    var startX = c - Math.floor(this.brushX / 2);\n    startX = startX < 0 ? 0 : startX;\n\n    var endX = c + Math.ceil(this.brushX / 2);\n    endX = endX > this.width ? this.width : endX;\n\n    var startY = r - Math.floor(this.brushY / 2);\n    startY = startY < 0 ? 0 : startY;\n\n    var endY = r + Math.ceil(this.brushY / 2);\n    endY = endY > this.height ? this.height : endY;\n\n    for (var x = startX; x < endX; x++) {\n      for (var y = startY; y < endY; y++) {\n        this.read(y, x).update(this.read(y, x).prevState);\n      }\n    }\n  },\n\n  brush: function brush(mod, r, c) {\n    var startX = c - Math.floor(this.brushX / 2);\n    startX = startX < 0 ? 0 : startX;\n\n    var endX = c + Math.ceil(this.brushX / 2);\n    endX = endX > this.width ? this.width : endX;\n\n    var startY = r - Math.floor(this.brushY / 2);\n    startY = startY < 0 ? 0 : startY;\n\n    var endY = r + Math.ceil(this.brushY / 2);\n    endY = endY > this.height ? this.height : endY;\n\n    for (var x = startX; x < endX; x++) {\n      for (var y = startY; y < endY; y++) {\n        if (mod && this.read(y, x).morphable) {\n          this.read(y, x).suspendMorph();\n          this.removeMorph(y, x);\n        }\n        this.read(y, x).update(this.editBlockType);\n      }\n    }\n  },\n\n  addEnemy: function addEnemy(r, c) {\n    var id = this.level.addEnemy(this.editEnemyType, this.editEnemyDir, this.editEnemySpeed, c * this.sqSize, r * this.sqSize);\n\n    console.log('ID ' + id);\n\n    (0, _jquery2.default)('.editor').append(this.renderEnemyMarker(this.editEnemyType, c * this.sqSize, r * this.sqSize, id));\n\n    this.registerEditorInput();\n  },\n\n  removeEnemy: function removeEnemy(id) {\n\n    //  this.level.removeEnemy(id);\n  },\n\n  placePlayer: function placePlayer(r, c) {\n    this.level.placePlayer(c * this.sqSize, r * this.sqSize);\n    (0, _jquery2.default)('.editor').append(this.renderPlayerMarker(c * this.sqSize, r * this.sqSize));\n  },\n\n  placeStar: function placeStar(r, c) {\n    this.level.placeStar(c * this.sqSize, r * this.sqSize);\n    (0, _jquery2.default)('.editor').append(this.renderStarMarker(c * this.sqSize, r * this.sqSize));\n  },\n\n  placeMorph: function placeMorph(r, c) {\n    this.level.placeMorph(r, c, this.editBlockMorphStates, this.editBlockDelay * 1000, this.editBlockCycle_0 * 1000, this.editBlockCycle_1 * 1000);\n    this.activateMorph();\n  },\n\n  removeMorph: function removeMorph(r, c) {\n    this.level.removeMorph(r, c);\n    this.activateMorph();\n  },\n\n  squareFocus: function squareFocus(square) {\n    /*this.squaresInFocus.forEach((sq) => {\r\n      sq.update(sq.prevState);\r\n    });*/\n\n    this.squareFocus = [];\n\n    this.squaresInFocus.push(square);\n    square.update('food');\n  },\n\n  update: function update(coord, state) {\n    var r = coord[0];\n    var c = coord[1];\n\n    this.read(coord[0], coord[1]).update(state);\n\n    //this.read(coord[0], coord[1]).setState(state);\n\n    //console.log(this.read(coord[0], coord[1]).state);\n\n    /*$(`#${r}-${c}`).remove();\r\n    $('.content').append(this.read(r,c).render());\r\n    */\n\n    if (state === 'food') {\n      console.log(this.read(r, c).state);\n    }\n  }\n\n};\n\nexports.default = Grid;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/js/Grid.js\n ** module id = 12\n ** module chunks = 0 1\n **/\n//# sourceURL=webpack:///./src/js/Grid.js?")},function(module,exports){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nfunction Array2d(row, column) {\n  this.row = row;\n  this.column = column;\n  this.grid = this.initGrid();\n}\n\nArray2d.prototype = {\n  row: 1,\n  column: 1,\n  initGrid: function initGrid() {\n    var grid = [[]];\n\n    for (var r = 0; r < this.row; r++) {\n      for (var c = 0; c < this.column; c++) {\n        grid[r].push(0);\n      }\n      grid.push([]);\n    }\n    return grid;\n  },\n\n  read: function read(r, c) {\n    if (r < 0 || r > this.row || c < 0 || c > this.column) {\n      return null;\n    }\n    return this.grid[r][c];\n  },\n\n  write: function write(r, c, val) {\n    if (r < 0 || r >= this.row || c < 0 || c >= this.column) {\n      return null;\n    } else {\n      this.grid[r][c] = val;\n    }\n  },\n\n  forEach: function forEach(fn) {\n    this.grid.forEach(function (element) {\n      element.forEach(fn);\n    });\n  },\n\n  map: function map(fn) {\n    return this.grid.map(function (element) {\n      return element.map(fn);\n    });\n  },\n\n  print: function print() {\n    var line = '';\n    for (var r = 0; r < this.row; r++) {\n      for (var c = 0; c < this.column; c++) {\n        line += this.read(r, c);\n      }\n      line += '\\n';\n    }\n\n    console.log(line);\n  }\n};\n\nexports.default = Array2d;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/js/Array2d.js\n ** module id = 13\n ** module chunks = 0 1\n **/\n//# sourceURL=webpack:///./src/js/Array2d.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _jquery = __webpack_require__(2);\n\nvar _jquery2 = _interopRequireDefault(_jquery);\n\nvar _underscore = __webpack_require__(11);\n\nvar _underscore2 = _interopRequireDefault(_underscore);\n\nvar _camera = __webpack_require__(15);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction Square(row, column, size, grid) {\n  this.state = \"empty\";\n  this.row = row;\n  this.column = column;\n  this.size = size;\n  this.grid = grid;\n  this.pos = [this.column * this.size, this.row * this.size];\n}\n\nSquare.prototype = {\n  row: 0,\n  column: 0,\n  size: 20,\n  prevState: 'empty',\n  state: 'empty',\n  editing: false,\n  pos: [0, 0],\n  grid: null,\n  morphable: false,\n  intervalID: null,\n  animID: null,\n  animCount: 0,\n  cycle: 500,\n  timer: 0,\n  toggle: true,\n  currentTimeout: 500,\n  cycle_0: 500,\n  cycle_1: 500,\n  morphState_0: 'green-wall',\n  morphState_1: 'empty',\n  morphIndex: 0,\n  initDelayID: null,\n  delay: 10,\n\n  init: function init() {\n    var _this = this;\n\n    if (this.morphable) {\n      this.update(this.morphState_0);\n      //if(this.intervalID) clearInterval(this.intervalID);\n      if (this.initDelayID) clearTimeout(this.initDelayID);\n      if (this.animID) cancelAnimationFrame(this.animID);\n\n      console.log(\"delay: \" + this.delay);\n\n      this.initDelayID = setTimeout(function () {\n        _this.morph();\n        _this.animMorph();\n      }, this.delay);\n    }\n  },\n\n  render: function render() {\n    return '<div id=\"' + this.row + '-' + this.column + '\" class=\"square ' + this.state + '\" style=\"top:' + this.row * this.size + 'px; left:' + this.column * this.size + 'px; height:' + this.size + 'px; width:' + this.size + 'px\"></div>';\n  },\n\n  setState: function setState(state) {\n    this.prevState = this.state;\n    this.state = state;\n  },\n\n  buildAnimation: function buildAnimation(animator) {\n    var _this2 = this;\n\n    var prevTime = null;\n\n    var frame = function frame(time) {\n      if (prevTime) {\n        var dt = time - prevTime;\n        dt = dt < 100 ? dt : 0;\n        animator(dt);\n      }\n      prevTime = time;\n\n      if (_this2.morphable) _this2.animID = requestAnimationFrame(frame);\n    };\n\n    return requestAnimationFrame(frame);\n  },\n\n  morphAnimator: function morphAnimator(dt) {},\n\n  animMorph: function animMorph() {\n    var _this3 = this;\n\n    //this.animCount++;\n    var timer = 0;\n    var toggle = true;\n    var currentTimeout = this.cycle_0;\n\n    this.animID = this.buildAnimation(function (dt) {\n      if (!_this3.morphable) return;\n      //      timer += dt;\n      var delta = Math.floor(dt / 10) * 10;\n      timer += delta;\n      //timer = Math.floor(timer/100) * 100;\n      //timer = timer - (timer % 100);\n      if (timer >= currentTimeout) {\n        timer = 0;\n        if (toggle) {\n          currentTimeout = _this3.cycle_1;\n          _this3.update(_this3.morphState_1);\n        } else {\n          currentTimeout = _this3.cycle_0;\n          _this3.update(_this3.morphState_0);\n        }\n\n        toggle = !toggle;\n      }\n    });\n  },\n\n  morph: function morph() {\n    this.toggle = true;\n    /*var toggle = true;\r\n    let lifetime = this.cycle_0;\r\n    let morphState = this.morphState_0;\r\n      let morphFuncAlt = () => {\r\n      clearInterval(this.intervalID);\r\n      if(toggle){\r\n        lifetime = this.cycle_1;\r\n        morphState = this.morphState_1;\r\n      } else{\r\n        lifetime = this.cycle_0;\r\n        morphState = this.morphState_0;\r\n      }\r\n      this.update(morphState);\r\n        toggle = !toggle;\r\n        this.intervalID = setInterval(morphFuncAlt, lifetime);\r\n      }\r\n        this.intervalID = setInterval(morphFuncAlt, lifetime);\r\n    */\n    /*this.intervalID = setInterval(() => {\r\n    //  console.log(this.morphStates);\r\n      if(toggle){\r\n        this.update(this.morphState_1);\r\n      }\r\n      else{\r\n        this.update(this.morphState_0);\r\n      }\r\n      toggle = !toggle;\r\n    }, this.cycle);\r\n    */\n  },\n\n  suspendMorph: function suspendMorph() {\n    this.morphable = false;\n    //if(this.intervalID) clearInterval(this.intervalID);\n    if (this.initDelayID) clearTimeout(this.initDelayID);\n  },\n\n  update: function update(newState) {\n    (0, _jquery2.default)('#' + this.row + '-' + this.column).removeClass(this.state);\n    this.setState(newState);\n    (0, _jquery2.default)('#' + this.row + '-' + this.column).addClass(this.state);\n  },\n\n  handleEnter: function handleEnter(t) {\n    t.grid.markSquare(t.row, t.column);\n  },\n\n  handleExit: function handleExit(t) {\n    t.grid.unmarkSquare(t.row, t.column);\n\n    if (t.grid.mouseDown && t.grid.editMode === \"block\") {\n      t.grid.modSquare(t.row, t.column);\n    }\n  },\n\n  handleClick: function handleClick(t) {\n    t.grid.modSquare(t.row, t.column);\n  },\n\n  run: function run() {\n    var _this4 = this;\n\n    (0, _jquery2.default)('#' + this.row + '-' + this.column).hover(function () {\n      if (_this4.editing) {\n        _this4.handleEnter(_this4);\n      }\n    }, function () {\n      if (_this4.editing) {\n        _this4.handleExit(_this4);\n      }\n    });\n    (0, _jquery2.default)('#' + this.row + '-' + this.column).click(function () {\n      if (_this4.editing) {\n        _this4.handleClick(_this4);\n      }\n    });\n  }\n\n};\n\nexports.default = Square;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/js/Square.js\n ** module id = 14\n ** module chunks = 0 1\n **/\n//# sourceURL=webpack:///./src/js/Square.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.viewportScroll = viewportScroll;\n\nvar _jquery = __webpack_require__(2);\n\nvar _jquery2 = _interopRequireDefault(_jquery);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar viewportPosition = function viewportPosition(pos, scrollLeft, scrollTop) {\n  return [pos[0] - scrollLeft, pos[1] - scrollTop];\n};\n\nfunction viewportScroll(actor) {\n  var scrollLeft = (0, _jquery2.default)('.viewport').scrollLeft();\n  var scrollTop = (0, _jquery2.default)('.viewport').scrollTop();\n\n  var vPos = viewportPosition(actor.pos, scrollLeft, scrollTop);\n\n  if (vPos[0] > 700) {\n    (0, _jquery2.default)('.viewport').scrollLeft(scrollLeft + 20);\n  } else if (vPos[0] < 200) {\n    (0, _jquery2.default)('.viewport').scrollLeft(scrollLeft - 20);\n  }\n\n  if (vPos[1] > 250) {\n    (0, _jquery2.default)('.viewport').scrollTop(scrollTop + 20);\n  } else if (vPos[1] < 200) {\n    (0, _jquery2.default)('.viewport').scrollTop(scrollTop - 20);\n  }\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/js/camera.js\n ** module id = 15\n ** module chunks = 0 1\n **/\n//# sourceURL=webpack:///./src/js/camera.js?")},function(module,exports,__webpack_require__){eval('"use strict";\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _jquery = __webpack_require__(2);\n\nvar _jquery2 = _interopRequireDefault(_jquery);\n\nvar _squareTypes = __webpack_require__(17);\n\nvar _squareTypes2 = _interopRequireDefault(_squareTypes);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar allSpeeds = [10, 20, 35, 60, 100];\n\nvar Enemy = function Enemy(type, dir, speed, spawnX, spawnY, id, grid) {\n  this.id = id;\n  this.dir = dir;\n  this.spawnX = spawnX;\n  this.spawnY = spawnY;\n\n  this.type = type;\n  this.grid = grid;\n  this.size = grid.sqSize;\n\n  this.speedMult = allSpeeds[speed];\n  console.log("mult: " + this.speedMult);\n};\n\nEnemy.prototype = {\n  grid: null,\n  vX: 0,\n  vY: 1,\n  size: 20,\n  type: \'fireball\',\n  spawnX: 0,\n  spawnY: 0,\n  xPos: 0,\n  yPos: 0,\n  speedMult: 100,\n  elem: null,\n  id: -1,\n  immortal: false,\n  dead: false,\n  delay: 3000,\n  timeoutID: null,\n  borders: [\'top\', \'down\', \'left\', \'right\'],\n\n  init: function init() {\n    var _this = this;\n\n    if (this.dir === \'horizontal\') {\n      this.vX = this.speedMult;\n      this.vY = 0;\n    } else {\n      this.vX = 0;\n      this.vY = this.speedMult;\n    }\n\n    this.xPos = this.spawnX;\n    this.yPos = this.spawnY;\n\n    (0, _jquery2.default)(\'.content\').append(this.render());\n\n    this.elem = document.querySelector("#" + this.id);\n\n    (0, _jquery2.default)("#" + this.id).click(function (e) {\n      if (_this.grid.editMode === \'erase\') {\n        console.log(\'erasing...\');\n        _this.remove();\n      }\n    });\n  },\n\n  render: function render() {\n    return "<div id=\\"" + this.id + "\\" class=\\"roaming " + this.type + "\\" style=\\"width:" + this.size + "px; height:" + this.size + "px; left:" + this.spawnX + "px; top:" + this.spawnY + "px;\\"></div>";\n  },\n\n  suspend: function suspend() {\n    clearTimeout(this.timeoutID);\n    (0, _jquery2.default)("#" + this.id).remove();\n  },\n\n  remove: function remove() {\n    this.suspend();\n    this.grid.removeEnemy(this.id);\n  },\n\n  boundaries: function boundaries(dt) {\n\n    var nPos = [this.xPos + dt * this.vX * 0.003, this.yPos + dt * this.vY * 0.003];\n\n    //var nPos = this.pos;\n\n    var step = this.grid.sqSize;\n\n    var bounds = [];\n\n    var Xs = [nPos[0] + 1, nPos[0] + this.size - 1, nPos[0] + this.size / 2];\n\n    var Ys = [nPos[1] + 1, nPos[1] + this.size - 1, nPos[1] + this.size / 2];\n\n    for (var x = 0; x < Xs.length; x++) {\n      for (var y = 0; y < Ys.length; y++) {\n        //console.log(x + " - " + y);\n        bounds.push(this.grid.squareAt([Xs[x], Ys[y]]));\n      }\n    }\n\n    return bounds;\n  },\n\n  collide_wall: function collide_wall() {\n\n    if (this.dir === \'horizontal\') {\n      this.vX = -1 * this.vX;\n    } else if (this.dir === \'vertical\') {\n      this.vY = -1 * this.vY;\n    }\n  },\n\n  collide_enemy: function collide_enemy() {\n\n    if (this.immortal) {\n      this.collide_wall();\n    } else {\n      this.dead = true;\n      this.respawnDelay();\n      (0, _jquery2.default)("#" + this.id).remove();\n    }\n  },\n\n  motionOutcome: function motionOutcome(sq) {\n\n    var type = !sq ? \'wall\' : _squareTypes2.default[sq.state];\n\n    var isEmpty = true;\n\n    //    console.log("state: " + sq.state);\n    //    console.log("type : " + type);\n\n    if (type === \'wall\') {\n      this.collide_wall();\n      isEmpty = false;\n    } else if (type === \'enemy\') {\n      this.collide_enemy();\n      isEmpty = false;\n    }\n\n    return isEmpty;\n  },\n\n  respawnDelay: function respawnDelay() {\n    var _this2 = this;\n\n    this.timeoutID = setTimeout(function () {\n      //this.render();\n      _this2.init();\n      _this2.dead = false;\n    }, this.delay);\n  },\n\n  animate: function animate(dt) {\n\n    if (this.dead) {\n      return;\n    }\n\n    var bounds = this.boundaries(dt);\n\n    for (var i = 0; i < bounds.length; i++) {\n      //console.log(bounds[i].row + " -  " + bounds[i].column);\n      if (!this.motionOutcome(bounds[i])) break;\n      //bounds[i].update(\'empty\');\n    }\n\n    //console.log(this.spawnX + " -- " + this.spawnY);\n\n    //  console.log(allSpeeds[this.speedIndex]);\n\n    this.xPos += dt * this.vX * 0.003;\n    this.yPos += dt * this.vY * 0.003;\n\n    if (this.dir === \'vertical\') {\n      if (this.vY > 0) {\n        this.yPos = Math.floor(this.yPos / 2.5) * 2.5;\n      } else {\n        this.yPos = Math.ceil(this.yPos / 2.5) * 2.5;\n      }\n    } else {\n      if (this.vX > 0) {\n        this.xPos = Math.floor(this.xPos / 2.5) * 2.5;\n      } else {\n        this.xPos = Math.ceil(this.xPos / 2.5) * 2.5;\n      }\n    }\n\n    this.elem.style.left = this.xPos + \'px\';\n    this.elem.style.top = this.yPos + \'px\';\n  }\n\n};\n\nexports.default = Enemy;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/js/enemy.js\n ** module id = 16\n ** module chunks = 0 1\n **/\n//# sourceURL=webpack:///./src/js/enemy.js?')},function(module,exports){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = {\n  'sky': 'empty',\n  'wall': 'wall',\n  'green-wall': 'wall',\n  'snake': 'enemy',\n  'empty': 'empty',\n  'collision': 'enemy',\n  'brick': 'wall',\n  'sunset': 'empty',\n  'desert': 'wall',\n  'fireball': 'enemy',\n  'star': 'star'\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/data/squareTypes.js\n ** module id = 17\n ** module chunks = 0 1\n **/\n//# sourceURL=webpack:///./src/data/squareTypes.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _jquery = __webpack_require__(2);\n\nvar _jquery2 = _interopRequireDefault(_jquery);\n\nvar _level = __webpack_require__(7);\n\nvar _level2 = _interopRequireDefault(_level);\n\nvar _Grid = __webpack_require__(12);\n\nvar _Grid2 = _interopRequireDefault(_Grid);\n\nvar _Player = __webpack_require__(19);\n\nvar _Player2 = _interopRequireDefault(_Player);\n\nvar _editor = __webpack_require__(20);\n\nvar _editor2 = _interopRequireDefault(_editor);\n\nvar _enemy = __webpack_require__(16);\n\nvar _enemy2 = _interopRequireDefault(_enemy);\n\nvar _menu = __webpack_require__(3);\n\nvar _levels = __webpack_require__(6);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Game = function Game(row, column, sqSize) {\n  this.row = row;\n  this.column = column;\n  this.sqSize = sqSize;\n};\n\nGame.prototype = {\n\n  row: 1,\n  column: 1,\n  sqSize: 20,\n  grid: [[]],\n  level: null,\n  scrollVal_left: 40,\n  scrollVal_top: 0,\n  mode: 'play',\n  editor: false,\n  editorObj: null,\n\n  roamingObjs: [],\n\n  player: null,\n\n  init: function init(level) {\n    var _this = this;\n\n    (0, _jquery2.default)('.content').empty();\n\n    if (level === null) {\n      this.level = new _level2.default({ row: 30, column: 200, arr: [], roamingObjs: [] });\n    } else {\n      this.level = level;\n    }\n\n    if (this.player === null) {\n      this.player = new _Player2.default(this);\n    }\n\n    this.player.init(this.level.playerSpawn);\n\n    (0, _jquery2.default)('.content').append('<div class=\"play-area\">' + this.level.grid.render() + '</div>');\n    //$('.content').append(level.grid.render());\n    (0, _jquery2.default)('.viewport').removeClass('mode-editor');\n    (0, _jquery2.default)('.viewport').addClass('mode-playing');\n    (0, _jquery2.default)('.win-message').remove();\n    (0, _jquery2.default)('.play-area').append(this.renderStar(this.level.starPosition));\n    (0, _jquery2.default)('.subtitle-container').empty();\n    (0, _jquery2.default)('.subtitle-container').append((0, _menu.renderHeader)(\"playing\", this.level.name, this.level.row, this.level.column));\n\n    this.roamingObjs = [];\n\n    this.level.roamingObjs.forEach(function (obj, id) {\n      _this.roamingObjs.push(new _enemy2.default(obj.type, obj.dir, obj.speed, obj.spawnX, obj.spawnY, 'enemy-' + id, _this.level.grid));\n    });\n\n    this.activateRoamingObjs();\n    this.level.grid.activateMorph();\n\n    this.run();\n  },\n\n  suspend: function suspend() {\n    this.pause();\n    this.player.suspend();\n\n    this.roamingObjs.forEach(function (obj) {\n      obj.suspend();\n    });\n\n    (0, _jquery2.default)('.play-area').remove();\n\n    return this.level;\n  },\n\n  activateRoamingObjs: function activateRoamingObjs() {\n    this.roamingObjs.forEach(function (obj) {\n      if (!obj.dead) obj.init();\n    });\n  },\n\n  activateMorph: function activateMorph() {\n    console.log(this.level.sqMorph);\n\n    for (var key in this.level.sqMorph) {\n      var obj = this.level.sqMorph[key];\n      var sq = this.level.grid.read(obj.row, obj.column);\n      sq.morphable = true;\n      sq.delay = obj.delay;\n      sq.cycle = obj.cycle;\n      sq.morphState_0 = obj.state1;\n      sq.morphState_1 = obj.state2;\n      sq.init();\n    }\n  },\n\n  renderStar: function renderStar(starPosition) {\n    console.log(\"star: \" + starPosition);\n\n    return '<div id=\"star\" style=\"width:' + this.level.sqSize + 'px; height:' + this.level.sqSize + 'px; left:' + starPosition[0] + 'px; top:' + starPosition[1] + 'px;\">\\n      <div class=\"clockwise\"></div>\\n      <div class=\"anticlockwise\"></div>\\n    </div>';\n  },\n\n  squareAt: function squareAt(pos) {\n    var x = pos[0];\n    var y = pos[1];\n\n    y = Math.floor(y / this.sqSize);\n    x = Math.floor(x / this.sqSize);\n\n    return this.level.grid.read(y, x);\n  },\n\n  animateStar: function animateStar(dt) {},\n\n  buildAnimation: function buildAnimation(animator) {\n    var _this2 = this;\n\n    var prevTime = null;\n\n    var frame = function frame(time) {\n      if (prevTime) {\n        var dt = time - prevTime;\n        dt = dt < 100 ? dt : 0;\n        animator(dt);\n      }\n      prevTime = time;\n\n      if (_this2.mode === 'play') requestAnimationFrame(frame);\n    };\n\n    requestAnimationFrame(frame);\n  },\n\n  viewportPosition: function viewportPosition(pos, scrollLeft, scrollTop) {\n    return [pos[0] - scrollLeft, pos[1] - scrollTop];\n  },\n\n  viewportScroll: function viewportScroll(actor) {\n    var scrollLeft = (0, _jquery2.default)('.viewport').scrollLeft();\n    var scrollTop = (0, _jquery2.default)('.viewport').scrollTop();\n\n    var vWidth = (0, _jquery2.default)('.viewport').width();\n    var vHeight = (0, _jquery2.default)('.viewport').height();\n\n    var vPos = this.viewportPosition(actor.pos, scrollLeft, scrollTop);\n\n    if (vPos[0] > vWidth * 0.7) {\n      (0, _jquery2.default)('.viewport').scrollLeft(scrollLeft + vPos[0] - vWidth * 0.7);\n    } else if (vPos[0] < vWidth * 0.3) {\n      (0, _jquery2.default)('.viewport').scrollLeft(scrollLeft - (vWidth * 0.3 - vPos[0]));\n    }\n\n    if (vPos[1] > vHeight * 0.6) {\n      (0, _jquery2.default)('.viewport').scrollTop(scrollTop + vPos[1] - vHeight * 0.6);\n    } else if (vPos[1] < vHeight * 0.4) {\n      (0, _jquery2.default)('.viewport').scrollTop(scrollTop - (vHeight * 0.4 - vPos[1]));\n    }\n  },\n\n  renderWinMessage: function renderWinMessage() {\n    return '<div class=\"win-message\">\\n      <div class=\"win-content\">\\n        <div class=\"title\">\\n        Level Completed!\\n        </div>\\n        <div class=\"btns\">\\n        <div class=\"btn restart\" data-btn=\"restart\">restart</div>\\n        <div class=\"btn\" data-btn=\"menu\">main menu</div>\\n        </div>\\n      </div>\\n    </div>';\n  },\n\n  play: function play() {\n    var _this3 = this;\n\n    this.mode = 'play';\n    this.buildAnimation(function (dt) {\n      //let actor = (this.editor ? this.editorObj : this.player);\n      _this3.player.animate(dt);\n\n      _this3.roamingObjs.forEach(function (obj) {\n        obj.animate(dt);\n      });\n\n      _this3.viewportScroll(_this3.player);\n    });\n  },\n\n  pause: function pause() {\n    this.mode = 'pause';\n  },\n\n  win: function win() {\n    var _this4 = this;\n\n    this.pause();\n    (0, _jquery2.default)('.game').append(this.renderWinMessage());\n    (0, _jquery2.default)('.btn').click(function (e) {\n      var val = e.target.getAttribute('data-btn');\n\n      if (val === 'restart') {\n        _this4.init(_this4.level);\n      } else if (val === 'menu') {\n        window.location.href = 'http://localhost:3000/home';\n      }\n    });\n  },\n\n  run: function run() {\n\n    console.log(\"RUNNING\");\n    this.player.run();\n    this.play();\n    //$('.viewport').scrollTop(0);\n  }\n\n};\n\nexports.default = Game;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/js/game.js\n ** module id = 18\n ** module chunks = 0 1\n **/\n//# sourceURL=webpack:///./src/js/game.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _jquery = __webpack_require__(2);\n\nvar _jquery2 = _interopRequireDefault(_jquery);\n\nvar _Square = __webpack_require__(14);\n\nvar _Square2 = _interopRequireDefault(_Square);\n\nvar _squareTypes = __webpack_require__(17);\n\nvar _squareTypes2 = _interopRequireDefault(_squareTypes);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Player = function Player(game) {\n  this.game = game;\n};\n\nPlayer.prototype = {\n  game: null,\n  startPos: [10, 10],\n  vX: 0,\n  vY: 0,\n  speedMult: 50,\n  size: [20, 40],\n  pos: [40, 10],\n  elem: null,\n  jumping: false,\n  grounded: false,\n  deathCount: 0,\n  death: false,\n  keys: {\n    right: false,\n    left: false,\n    up: false,\n    down: false\n  },\n  borders: ['top', 'down', 'left', 'right'],\n\n  init: function init(spawn) {\n    //$('#player').remove();\n    this.startPos = spawn;\n\n    console.log(this.startPos);\n\n    (0, _jquery2.default)('.content').append(this.render());\n\n    this.elem = document.querySelector('#player');\n\n    this.reset();\n  },\n\n  reset: function reset() {\n    this.pos[0] = this.startPos[0];\n    this.pos[1] = this.startPos[1];\n  },\n\n  suspend: function suspend() {\n    this.elem.remove();\n  },\n\n  render: function render() {\n    return '<div id=\"player\" style=\"width:' + this.size[0] + 'px; height:' + this.size[1] + 'px; left:' + this.startPos[0] + 'px; top:' + this.startPos[1] + 'px;\"></div>';\n  },\n\n  input: function input() {\n    var _this = this;\n\n    (0, _jquery2.default)(document).keydown(function (event) {\n      if (event.keyCode === 39) {\n        _this.keys.right = true;\n      }\n      if (event.keyCode === 37) {\n        _this.keys.left = true;\n      }\n      if (event.keyCode === 38) {\n        _this.keys.up = true;\n      }\n      if (event.keyCode === 40) {\n        _this.keys.down = true;\n      }\n    });\n\n    (0, _jquery2.default)(document).keyup(function (event) {\n      if (event.keyCode === 39) {\n        _this.keys.right = false;\n      }\n      if (event.keyCode === 37) {\n        _this.keys.left = false;\n      }\n      if (event.keyCode === 38) {\n        _this.keys.up = false;\n      }\n      if (event.keyCode === 40) {\n        _this.keys.down = false;\n      }\n    });\n  },\n\n  boundaries: function boundaries(xP, yP) {\n    //var nPos = newVals[2];\n\n    var bounds = [];\n\n    var Xs = [xP, xP + this.size[0], xP + this.size[0] / 2];\n\n    var Ys = [yP, yP + this.size[1], yP + this.size[1] / 2];\n\n    //console.log(\"x \" + Xs);\n    //console.log(\"y \" + Ys);\n\n    for (var x = 0; x < Xs.length; x++) {\n      for (var y = 0; y < Ys.length; y++) {\n        //    console.log(Xs[x] + \"---\" + Ys[y]);\n        bounds.push(this.game.squareAt([Xs[x], Ys[y]]));\n      }\n    }\n\n    return bounds;\n  },\n\n  /*boundaries: function(newVals){\r\n      var nPos = newVals[2];\r\n    var step = this.game.sqSize;\r\n      var bounds = {\r\n      top: [],\r\n      down: [],\r\n      left: [],\r\n      right:[]\r\n    };\r\n    //  var bounds = [];\r\n      var vertices = [\r\n      [\r\n        nPos[0] - 4,\r\n        nPos[0] + this.size[0] + 4\r\n      ],\r\n      [\r\n        nPos[1] - 4,\r\n        nPos[1] + this.size[1] + 4\r\n      ]\r\n    ];\r\n      for(var i=0; i<2; i++){\r\n      var origin = nPos[0];\r\n      var end = nPos[0] + this.size[0];\r\n      var fixed = vertices[1][i];\r\n        for(var x=origin; x<=end; x += step){\r\n        bounds[this.borders[i]].push(this.game.squareAt([x, fixed]));\r\n      }\r\n    }\r\n      for(var i=0; i<2; i++){\r\n      var origin = nPos[1];\r\n      var end = nPos[1] + this.size[1];\r\n      var fixed = vertices[0][i];\r\n        for(var y=origin; y<=end; y += step){\r\n        bounds[this.borders[2+i]].push(this.game.squareAt([fixed, y]));\r\n      }\r\n    }\r\n      return bounds;\r\n    },*/\n\n  evaluateMotion: function evaluateMotion(dt) {\n    var new_vX = this.vX;\n    var new_vY = this.vY;\n\n    if (this.keys.right) {\n      new_vX = this.speedMult;\n    }\n    if (this.keys.left) {\n      new_vX = -1 * this.speedMult;\n    }\n\n    if (!this.keys.right && !this.keys.left) {\n      new_vX = 0;\n    }\n\n    new_vY += new_vY > 50 ? 0 : 3;\n\n    if (!this.jumping && this.keys.up && this.vY === 0) {\n      this.jumping = true;\n      new_vY = -70;\n      this.grounded = false;\n    } else if (this.vY > 0) {\n      this.jumping = false;\n    }\n\n    var newPos = [this.pos[0] + dt * new_vX * 0.003, this.pos[1] + dt * new_vY * 0.003];\n\n    return [new_vX, new_vY];\n  },\n\n  executeMotion: function executeMotion(newVs) {\n    this.vX = newVs[0];\n    this.vY = newVs[1];\n  },\n\n  collide_wall: function collide_wall(side, Vs, sq) {\n\n    switch (side) {\n      case 'top':\n        {\n          Vs[1] = Vs[1] < 0 ? 0 : Vs[1];\n          break;\n        }\n      case 'down':\n        {\n          Vs[1] = Vs[1] > 0 ? 0 : Vs[1];\n          this.grounded = true;\n          break;\n        }\n      case 'left':\n        {\n          Vs[0] = Vs[0] <= 0 ? 0 : Vs[0];\n          break;\n        }\n      case 'right':\n        {\n          Vs[0] = Vs[0] >= 0 ? 0 : Vs[0];\n          break;\n        }\n\n    }\n\n    return Vs;\n  },\n\n\n  collide_enemy: function collide_enemy() {\n    if (!this.death) {\n      this.death = true;\n      this.deathAnim();\n    }\n  },\n\n  winGame: function winGame() {\n    this.game.win();\n  },\n\n  isWall: function isWall(bounds) {\n    var _this2 = this;\n\n    var collide = false;\n    bounds.forEach(function (sq) {\n\n      var type = !sq ? 'wall' : _squareTypes2.default[sq.state];\n\n      if (type === 'wall') {\n        collide = true;\n      } else if (type === 'enemy') {\n        _this2.collide_enemy();\n      }\n    });\n    return collide;\n  },\n\n  motionOutcome: function motionOutcome(side, bounds, newVs) {\n    var _this3 = this;\n\n    var border = bounds[side];\n    var Vs = newVs;\n\n    border.forEach(function (sq) {\n\n      var type = !sq ? 'wall' : _squareTypes2.default[sq.state];\n\n      if (type === 'wall') {\n        Vs = _this3.collide_wall(side, Vs, sq);\n      } else if (type === 'enemy') {\n        _this3.collide_enemy();\n      }\n    });\n\n    return Vs;\n  },\n\n  checkStar: function checkStar() {\n    var starX = this.game.level.starPosition[0];\n    var starY = this.game.level.starPosition[1];\n\n    var starSize = this.game.level.sqSize;\n\n    var distX = Math.abs(this.pos[0] + this.size[0] / 2 - (starX + starSize / 2));\n    var distY = Math.abs(this.pos[1] + this.size[1] / 2 - (starY + starSize / 2));\n\n    if (distX < this.size[0] / 2 + starSize / 2 && distY < this.size[1] / 2 + starSize / 2) {\n      return true;\n    } else {\n      return false;\n    }\n  },\n\n  checkEnemies: function checkEnemies(obj, newPos) {\n    if (obj.dead) {\n      return false;\n    }\n\n    var distX = Math.abs(this.pos[0] + this.size[0] / 2 - (obj.xPos + obj.size / 2));\n\n    var distY = Math.abs(this.pos[1] + this.size[1] / 2 - (obj.yPos + obj.size / 2));\n\n    if (distX < this.size[0] / 2 + obj.size / 2 && distY < this.size[1] / 2 + obj.size / 2) {\n      return true;\n    } else {\n      return false;\n    }\n\n    /*if(obj.pos[0] >= newPos[0] && obj.pos[0] <= (newPos[0] + this.size[0])\r\n      || (obj.pos[0] + obj.size) >= newPos[0] &&  (obj.pos[0] + obj.size) <= (newPos[0] + this.size[0])\r\n       || this.size[0] < obj.size obj.pos[1] && newPos[0] > obj.pos[0] && newPos[0] < (obj.pos[0] + obj.size))\r\n    */\n  },\n\n  deathAnim: function deathAnim() {\n    var _this4 = this;\n\n    var toggle = true;\n    var intervalID = setInterval(function () {\n      if (toggle) (0, _jquery2.default)('#player').addClass('damaged');else (0, _jquery2.default)('#player').removeClass('damaged');\n\n      toggle = !toggle;\n\n      if (_this4.deathCount++ > 6) {\n        clearInterval(intervalID);\n        _this4.deathCount = 0;\n        _this4.death = false;\n        _this4.reset();\n      }\n    }, 100);\n  },\n\n  animate: function animate(dt) {\n    var _this5 = this;\n\n    if (this.elem == null) {\n      this.elem = document.querySelector('#player');\n    }\n\n    var newVals = this.evaluateMotion(dt);\n\n    this.grounded = false;\n\n    var boundsX = this.boundaries(this.pos[0] + dt * newVals[0] * 0.003, this.pos[1]);\n    var boundsY = this.boundaries(this.pos[0], this.pos[1] + dt * newVals[1] * 0.003);\n\n    if (this.isWall(boundsX)) {\n      this.vX = 0;\n    } else {\n      this.vX = newVals[0];\n    }\n\n    if (this.isWall(boundsY)) {\n      this.vY = 0;\n    } else {\n      this.vY = newVals[1];\n    }\n\n    //    var bounds = this.boundaries(newVals);\n\n    /*this.borders.forEach((b) => {\r\n      newVals = this.motionOutcome(b, bounds, newVals);\r\n    });*/\n\n    var st = this.checkStar();\n    console.log(st);\n    if (st) {\n      this.winGame();\n      return;\n    }\n\n    var enemyTouched = false;\n\n    this.game.roamingObjs.forEach(function (obj) {\n      if (_this5.checkEnemies(obj, newVals)) {\n        enemyTouched = true;\n      }\n    });\n\n    if (enemyTouched) {\n      this.collide_enemy();\n    }\n\n    //this.executeMotion(newVals);\n\n    this.pos[0] += dt * this.vX * 0.003;\n    this.pos[1] += dt * this.vY * 0.003;\n\n    this.elem.style.left = this.pos[0] + 'px';\n    this.elem.style.top = this.pos[1] + 'px';\n\n    //    console.log(this.vY);\n  },\n\n  run: function run() {\n    this.input();\n  }\n};\n\nexports.default = Player;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/js/Player.js\n ** module id = 19\n ** module chunks = 0 1\n **/\n//# sourceURL=webpack:///./src/js/Player.js?");
},function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _jquery = __webpack_require__(2);\n\nvar _jquery2 = _interopRequireDefault(_jquery);\n\nvar _level = __webpack_require__(7);\n\nvar _level2 = _interopRequireDefault(_level);\n\nvar _editorTools = __webpack_require__(21);\n\nvar _menu = __webpack_require__(3);\n\nvar _publish = __webpack_require__(22);\n\nvar _publish2 = _interopRequireDefault(_publish);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Editor = function Editor(level) {\n  this.level = level;\n};\n\nEditor.prototype = {\n  game: null,\n  level: null,\n  running: false,\n  mouseDown: false,\n  morphable: false,\n  morphIndex: 0,\n\n  pl: function pl(pos) {\n    return function () {\n      (0, _editorTools.playerSpawnText)(pos);\n    };\n  },\n\n  selector: {\n    \"block\": _editorTools.blockSelector,\n    \"enemy\": _editorTools.enemySelector,\n    \"player-spawn\": _editorTools.playerSpawnText,\n    \"star-position\": _editorTools.starText,\n    \"publish\": _editorTools.publishLevel\n  },\n\n  init: function init(level) {\n\n    if (level === null) {\n      this.level = new _level2.default({ row: 50, column: 100, arr: [], roamingObjs: [] });\n    } else {\n      this.level = level;\n    }\n\n    this.running = true;\n\n    this.level.grid.brushX = 1;\n    this.level.grid.brushY = 1;\n\n    (0, _jquery2.default)('.content').append('<div class=\"editor\">' + this.level.grid.render() + '</div>');\n\n    (0, _jquery2.default)('.editor').append(this.level.grid.renderAllEnemyMarkers());\n\n    this.level.grid.activateSquares();\n    this.level.grid.activateMorph();\n\n    (0, _jquery2.default)('.viewport').removeClass('mode-playing');\n    (0, _jquery2.default)('.viewport').addClass('mode-editor');\n\n    (0, _jquery2.default)('.editor-tools').append((0, _editorTools.toolbox)());\n\n    (0, _jquery2.default)('.subtitle-container').empty();\n    (0, _jquery2.default)('.subtitle-container').append((0, _menu.renderHeader)(\"editor\", this.level.name, this.level.row, this.level.column));\n\n    this.morphable = false;\n    this.level.grid.editMode = \"block\";\n    this.openSelector('block');\n\n    if (this.level.starPosition) {\n      (0, _jquery2.default)('.editor').append(this.level.grid.renderStarMarker(this.level.starPosition[0], this.level.starPosition[1]));\n    }\n    (0, _jquery2.default)('.editor').append(this.level.grid.renderPlayerMarker(this.level.playerSpawn[0], this.level.playerSpawn[1]));\n\n    this.level.grid.registerEditorInput();\n\n    this.run();\n  },\n\n  suspend: function suspend() {\n    (0, _jquery2.default)('.editor').remove();\n    (0, _jquery2.default)('.toolbox').remove();\n\n    this.level.grid.suspendSquares();\n    this.running = false;\n\n    return this.level;\n  },\n\n  openSelector: function openSelector(type) {\n    (0, _jquery2.default)('.toolbox-content').empty();\n    var arg = undefined;\n    if (type === \"player-spawn\") {\n      arg = this.level.playerSpawn;\n    } else if (type === \"star-position\") {\n      arg = this.level.starPosition;\n    }\n\n    (0, _jquery2.default)('.toolbox-content').append(this.selector[type](arg, this.level.sqSize));\n\n    (0, _jquery2.default)('.header-elem').removeClass('selected');\n    (0, _jquery2.default)('.header-elem[data-header=\"' + type + '\"]').addClass('selected');\n    this.registerInput();\n    (0, _jquery2.default)(window).scrollTop((0, _jquery2.default)(document).height());\n\n    if (type === \"enemy\") {\n      this.level.grid.editEnemyDir = 'vertical';\n      (0, _jquery2.default)(\".enemy-speed .speed\").removeClass('selected');\n      (0, _jquery2.default)(\".enemy-direction .dir\").removeClass('selected');\n\n      (0, _jquery2.default)('.enemy-speed .speed[data-speed=\"' + this.level.grid.editEnemySpeed + '\"]').addClass('selected');\n      (0, _jquery2.default)('.enemy-direction .dir[data-dir=\"' + this.level.grid.editEnemyDir + '\"]').addClass('selected');\n      (0, _jquery2.default)('.eraser').removeClass('selected');\n      (0, _jquery2.default)('.enemy-eraser .txt').text('');\n    } else if (type === \"block\") {\n      (0, _jquery2.default)(\".behaviour\").removeClass('selected');\n      (0, _jquery2.default)('.behaviour[data-behaviour=\"static\"]').addClass('selected');\n      this.brushParams();\n      this.updateBlockSelect();\n    }\n  },\n\n\n  updateBlockSelect: function updateBlockSelect() {\n    (0, _jquery2.default)('.block-type-container').removeClass('selected');\n    if (!this.morphable) (0, _jquery2.default)('.block-type[data-type=\"' + this.level.grid.editBlockType + '\"]').parent().addClass('selected');else (0, _jquery2.default)('.block-type[data-type=\"' + this.level.grid.editBlockMorphStates[this.morphIndex] + '\"]').parent().addClass('selected');\n  },\n\n  squareAt: function squareAt(pos) {\n    var x = pos[0];\n    var y = pos[1];\n\n    y = Math.floor(y / this.sqSize);\n    x = Math.floor(x / this.sqSize);\n\n    return this.level.grid.read(y, x);\n  },\n\n  registerInput: function registerInput() {\n    var _this = this;\n\n    var editName = this.level.name;\n    var editRow = this.level.row;\n    var editColumn = this.level.column;\n\n    (0, _jquery2.default)('.player-spawn').click(function (e) {\n      console.log('PLAYER');\n      _this.level.grid.editMode = \"player\";\n    });\n\n    (0, _jquery2.default)('.star-position').click(function (e) {\n      console.log('Star');\n      _this.level.grid.editMode = \"star\";\n    });\n\n    (0, _jquery2.default)('.block-type').click(function (e) {\n\n      if (!_this.morphable) {\n        _this.level.grid.editBlockType = e.target.getAttribute('data-type');\n      } else {\n        _this.level.grid.editBlockMorphStates[_this.morphIndex] = e.target.getAttribute('data-type');\n        (0, _jquery2.default)('.morph-block-selection').empty();\n        (0, _jquery2.default)('.morph-block-selection').append(_this.morphStates());\n      }\n\n      (0, _jquery2.default)('.block-type-container').removeClass('selected');\n      (0, _jquery2.default)(e.target).parent().addClass('selected');\n    });\n\n    (0, _jquery2.default)('.enemy-type').click(function (e) {\n      //if(!this.running) return;\n      console.log(e.target.getAttribute('data-type'));\n      _this.level.grid.editMode = \"enemy\";\n      (0, _jquery2.default)('.eraser').removeClass('selected');\n      (0, _jquery2.default)('.enemy-eraser .txt').text('');\n      _this.level.grid.editEnemyType = e.target.getAttribute('data-type');\n    });\n\n    (0, _jquery2.default)('.dir').click(function (e) {\n      _this.level.grid.editEnemyDir = e.target.getAttribute('data-dir');\n      (0, _jquery2.default)('.dir').removeClass('selected');\n      e.target.className += \" selected\";\n    });\n\n    (0, _jquery2.default)('.speed').click(function (e) {\n      console.log(e.target.getAttribute('data-speed'));\n      _this.level.grid.editEnemySpeed = parseInt(e.target.getAttribute('data-speed'));\n      (0, _jquery2.default)('.speed').removeClass('selected');\n      e.target.className += \" selected\";\n    });\n\n    (0, _jquery2.default)('.eraser').click(function (e) {\n      _this.level.grid.editMode = 'erase';\n      (0, _jquery2.default)(e.target).addClass('selected');\n      (0, _jquery2.default)('.enemy-eraser .txt').text('click on an enemy to delete it');\n    });\n\n    (0, _jquery2.default)('.behaviour').click(function (e) {\n      (0, _jquery2.default)(window).scrollTop((0, _jquery2.default)(document).height());\n      var behaviour = e.target.getAttribute('data-behaviour');\n      (0, _jquery2.default)('.params-detail').empty();\n      (0, _jquery2.default)('.behaviour').removeClass('selected');\n      if (behaviour === 'morphable') {\n        _this.morphable = true;\n        _this.level.grid.editMode = \"morph\";\n        _this.morphParams();\n        (0, _jquery2.default)('.morph-block-selection').append(_this.morphStates());\n      } else {\n        _this.morphable = false;\n        _this.level.grid.editMode = \"block\";\n        _this.brushParams();\n      }\n\n      (0, _jquery2.default)(e.target).addClass('selected');\n\n      _this.updateBlockSelect();\n    });\n\n    (0, _jquery2.default)('.publish-text .btn').click(function (e) {\n      (0, _publish2.default)(_this.level.extract());\n    });\n  },\n\n  brushParams: function brushParams() {\n    var _this2 = this;\n\n    (0, _jquery2.default)('.params-detail').append((0, _editorTools.renderBrushParams)());\n\n    (0, _jquery2.default)('.brush-dimen-input[data-dimen=\"width\"]').val(this.level.grid.brushX);\n    (0, _jquery2.default)('.brush-dimen-input[data-dimen=\"height\"]').val(this.level.grid.brushY);\n\n    (0, _jquery2.default)('.brush-dimen-input').bind('input propertychange', function (e) {\n      var dimen = e.target.getAttribute('data-dimen');\n\n      var val = (0, _jquery2.default)(e.target).val();\n      if (val === \"\") val = \"1\";\n      val = parseFloat(val) || 1;\n      val = val < 1 ? val = 1 : val;\n\n      if (dimen === \"width\") {\n        val = val > _this2.level.column ? val = _this2.level.column : val;\n        _this2.level.grid.brushX = val;\n      } else if (dimen === \"height\") {\n        val = val > _this2.level.row ? val = _this2.level.row : val;\n        _this2.level.grid.brushY = val;\n      }\n    });\n\n    (0, _jquery2.default)('.brush-dimen-input').change(function (e) {\n      if (e.target.getAttribute('data-dimen') === 'width') (0, _jquery2.default)(e.target).val(_this2.level.grid.brushX);else (0, _jquery2.default)(e.target).val(_this2.level.grid.brushY);\n    });\n  },\n\n  morphParams: function morphParams() {\n    var _this3 = this;\n\n    (0, _jquery2.default)('.params-detail').append((0, _editorTools.morphableBlockParams)());\n\n    this.morphIndex = 0;\n\n    (0, _jquery2.default)('.delay').click(function (e) {\n      var delay = e.target.getAttribute('data-delay');\n      _this3.level.grid.editBlockDelay = parseFloat(delay);\n    });\n\n    (0, _jquery2.default)('.cycle').click(function (e) {\n      var cycle = e.target.getAttribute('data-cycle');\n      _this3.level.grid.editBlockCycle = parseInt(cycle);\n    });\n\n    /*    $('.delay-input').change((e) => {\r\n          console.log($(e.target).val());\r\n        });\r\n    */\n    (0, _jquery2.default)('.delay-input').bind('input propertychange', function (e) {\n      var val = (0, _jquery2.default)(e.target).val();\n      if (val === \"\") val = \"0\";\n      val = parseFloat(val) || 0;\n      val = val < 0 ? val = 0 : val;\n      val = val > 20 ? val = 20 : val;\n      console.log(val);\n      _this3.level.grid.editBlockDelay = val;\n    });\n\n    (0, _jquery2.default)('.delay-input').change(function (e) {\n      (0, _jquery2.default)(e.target).val(_this3.level.grid.editBlockDelay);\n    });\n\n    (0, _jquery2.default)('.cycle-input').bind('input propertychange', function (e) {\n      var val = (0, _jquery2.default)(e.target).val();\n      if (val === \"\") val = \"0.5\";\n      val = parseFloat(val) || 0.5;\n      val = val < 0 ? val = 0 : val;\n      val = val > 20 ? val = 20 : val;\n      console.log(val);\n\n      var stateNum = e.target.getAttribute(\"data-cycle\");\n\n      if (stateNum === \"first\") {\n        _this3.level.grid.editBlockCycle_0 = val;\n      } else {\n        _this3.level.grid.editBlockCycle_1 = val;\n      }\n    });\n    (0, _jquery2.default)('.cycle-input').change(function (e) {\n      if (e.target.getAttribute(\"data-cycle\") === \"first\") {\n        (0, _jquery2.default)(e.target).val(_this3.level.grid.editBlockCycle_0);\n      } else {\n        (0, _jquery2.default)(e.target).val(_this3.level.grid.editBlockCycle_1);\n      }\n    });\n  },\n\n  morphStates: function morphStates() {\n    var _this4 = this;\n\n    (0, _jquery2.default)('.morph-block-selection').append((0, _editorTools.morphStates)(this.level.grid.editBlockMorphStates));\n\n    (0, _jquery2.default)('.morph-state-container').removeClass('selected');\n    (0, _jquery2.default)('.morph-state[data-morph=\"' + this.morphIndex + '\"]').parent().addClass('selected');\n\n    (0, _jquery2.default)('.morph-state').click(function (e) {\n      _this4.morphIndex = e.target.getAttribute('data-morph');\n      (0, _jquery2.default)('.morph-state-container').removeClass('selected');\n      (0, _jquery2.default)(e.target).parent().addClass('selected');\n      _this4.updateBlockSelect();\n      console.log(_this4.morphIndex);\n    });\n  },\n\n  run: function run() {\n    var _this5 = this;\n\n    (0, _jquery2.default)(document).mousedown(function (e) {\n      if (!_this5.running) return;\n      //      e.preventDefault();\n      _this5.level.grid.mouseDown = true;\n    });\n\n    (0, _jquery2.default)(document).mouseup(function () {\n      if (!_this5.running) return;\n      _this5.level.grid.mouseDown = false;\n    });\n\n    (0, _jquery2.default)('.header-elem').click(function (e) {\n      var type = e.target.getAttribute('data-header');\n      _this5.openSelector(type);\n\n      if (type === \"enemy\") {\n        _this5.level.grid.editMode = \"enemy\";\n      } else {\n        _this5.morphable = false;\n        _this5.level.grid.editMode = \"block\";\n      }\n    });\n\n    this.registerInput();\n  }\n\n};\n\nexports.default = Editor;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/js/editor.js\n ** module id = 20\n ** module chunks = 0 1\n **/\n//# sourceURL=webpack:///./src/js/editor.js?")},function(module,exports,__webpack_require__){eval('\'use strict\';\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.toolbox = toolbox;\nexports.morphableBlockParams = morphableBlockParams;\nexports.morphStates = morphStates;\nexports.renderBrushParams = renderBrushParams;\nexports.playerSpawnText = playerSpawnText;\nexports.starText = starText;\nexports.blockSelector = blockSelector;\nexports.enemySelector = enemySelector;\nexports.levelSettings = levelSettings;\nexports.publishLevel = publishLevel;\nexports.renderPublishFailed = renderPublishFailed;\nexports.renderPublishSuccess = renderPublishSuccess;\n\nvar _jquery = __webpack_require__(2);\n\nvar _jquery2 = _interopRequireDefault(_jquery);\n\nvar _squareTypes = __webpack_require__(17);\n\nvar _squareTypes2 = _interopRequireDefault(_squareTypes);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction toolbox() {\n  return \'<div class="toolbox">\\n    <div class="toolbox-header">\\n      <div class="header-elem" data-header="block">\\n        add block\\n      </div>\\n      <div class="header-elem" data-header="enemy">\\n        place enemy\\n      </div>\\n      <div class="header-elem player-spawn" data-header="player-spawn">\\n        set player spawn location\\n      </div>\\n      <div class="header-elem star-position" data-header="star-position">\\n        place star\\n      </div>\\n      <div class="header-elem publish" data-header="publish">\\n        publish level\\n      </div>\\n    </div>\\n\\n    <div class="toolbox-content group">\\n\\n    </div>\\n  </div>\';\n}\n\nvar blockTypes = function blockTypes() {\n\n  var blocks = {\n    \'empty\': [],\n    \'wall\': [],\n    \'enemy\': []\n  };\n\n  var renderBlocksinGroup = function renderBlocksinGroup(group) {\n    var d = "";\n\n    group.forEach(function (type) {\n      d += \'<div class="block-type-container">\\n        <div class="block-type square \' + type + \'" data-type="\' + type + \'"></div>\\n      </div>\';\n    });\n\n    return d;\n  };\n\n  for (var type in _squareTypes2.default) {\n    if (blocks[_squareTypes2.default[type]]) blocks[_squareTypes2.default[type]].push(type);\n  }\n\n  var dom = "";\n\n  for (var group in blocks) {\n    dom += \'<div class="block-type-group">\\n      <div class="title">\' + group + \'</div>\\n      \' + renderBlocksinGroup(blocks[group]) + \'\\n    </div>\';\n  }\n\n  return dom;\n};\n\nvar enemyType = function enemyType() {\n  var types = [\'fireball\', \'moving-lava\', \'spike\', \'laser\', \'plasma\', \'flubber\'];\n\n  var dom = "";\n\n  types.forEach(function (type) {\n    dom += \'<div class="enemy-type-container">\\n      <div class="enemy-type roaming \' + type + \'" data-type="\' + type + \'"></div>\\n    </div>\';\n  });\n\n  return dom;\n};\n\n/*\r\n<div class="params-elem delay" data-delay="0.5">0.5s</div>\r\n<div class="params-elem delay" data-delay="1">1s</div>\r\n<div class="params-elem delay" data-delay="2">2s</div>\r\n<div class="params-elem delay" data-delay="3">3s</div>\r\n<div class="params-elem delay" data-delay="4">4s</div>\r\n\r\n<div class="params-elem cycle" data-cycle="1">1s</div>\r\n<div class="params-elem cycle" data-cycle="2">2s</div>\r\n<div class="params-elem cycle" data-cycle="3">3s</div>\r\n<div class="params-elem cycle" data-cycle="4">4s</div>\r\n\r\n*/\nfunction morphableBlockParams() {\n  return \'<div class="morphable-params">\\n    <div class="delay-selection param">\\n      <div class="title">Delay (seconds)</div>\\n      <input type="text" class="delay-input" />\\n    </div>\\n\\n    <div class="cycle-selection param">\\n      <div class="title">state 1 lifetime (seconds)</div>\\n      <input type="text" class="cycle-input" data-cycle="first"/>\\n    </div>\\n\\n    <div class="cycle-selection param">\\n      <div class="title">state 2 lifetime (seconds)</div>\\n      <input type="text" class="cycle-input" data-cycle="second"/>\\n    </div>\\n\\n    <div class="morph-block-selection param">\\n    </div>\\n\\n  </div>\';\n}\n\nfunction morphStates(states) {\n  return \'<div class="title">alternating states</div>\\n    <div class="morph-state-box">\\n      <div class="morph-state-container">\\n        <div class="morph-state square \' + states[0] + \'" data-morph="0"></div>\\n      </div>\\n      <div class="morph-state-sub">state 1</div>\\n    </div>\\n\\n    <div class="morph-state-box">\\n      <div class="morph-state-container">\\n        <div class="morph-state square \' + states[1] + \'" data-morph="1"></div>\\n      </div>\\n      <div class="morph-state-sub">state 2</div>\\n    </div>\';\n}\n\nfunction renderBrushParams() {\n  return \'<div class="brush-params">\\n    <div class="title">\\n      brush size\\n    </div>\\n    <br/>\\n\\n    <div class="brush-dimen">\\n      <span>width </span>\\n      <input type="text" class="brush-dimen-input" data-dimen="width" />\\n    </div>\\n    <div class="brush-dimen">\\n      <span>height </span>\\n      <input type="text" class="brush-dimen-input" data-dimen="height" />\\n    </div>\\n  </div>\';\n};\n\nfunction playerSpawnText(pos, sqSize) {\n  return \'<div class="info-txt player-spawn-text">\\n    <div>Player spawns at column: \' + Math.floor(pos[0] / sqSize) + \', row: \' + Math.floor(pos[1] / sqSize) + \'</div>\\n    <br/>\\n    You can change the player\\\'s starting position by clicking in the editor where you want the player to spawn.\\n  </div>\';\n};\n\nfunction starText(pos, sqSize) {\n  var txt = function txt(pos) {\n    if (!pos) {\n      return \'<div>The star\\\'s location has not yet been set</div>\';\n    } else {\n      return \'<div>The star is at column: \' + Math.floor(pos[0] / sqSize) + \', row: \' + Math.floor(pos[1] / sqSize) + \'</div>\';\n    }\n  };\n\n  return \'<div class="info-txt star-text">\\n    A level is completed when the player reaches the <span>star</span>.\\n    <br/>\\n    \' + txt(pos) + \'\\n    <br/>\\n    You can set/change the star\\\'s location by clicking in the editor where you want the star to appear.\\n  </div>\';\n};\n\nfunction blockSelector() {\n  return \'<div class="block-params">\\n  <div class="behaviour-selection">\\n    <div class="behaviour" data-behaviour="static">Static</div>\\n    <div class="behaviour" data-behaviour="morphable">Alternating</div>\\n  </div>\\n\\n  <div class="test">\\n  </div>\\n\\n  <div class="params-detail">\\n  </div>\\n  </div>\\n\\n  <div class=\\\'block-selector\\\'>\\n      \' + blockTypes() + \'\\n  </div>\';\n}\n\nfunction enemySelector() {\n  return \'<div class="enemy-params">\\n    <div class="enemy-direction">\\n      <div class="title">movement</div>\\n      <div class="dir" data-dir="vertical">vertical</div>\\n      <div class="dir" data-dir="horizontal">horizontal</div>\\n    </div>\\n    <div class="enemy-speed">\\n      <div class="title">speed</div>\\n      <div class="speed" data-speed="0">very slow</div>\\n      <div class="speed" data-speed="1">slow</div>\\n      <div class="speed" data-speed="2">normal</div>\\n      <div class="speed" data-speed="3">fast</div>\\n      <div class="speed" data-speed="4">very fast</div>\\n    </div>\\n    <div class="enemy-eraser">\\n      <div class="title">eraser</div>\\n      <div class="eraser">X</div>\\n      <div class="txt"></div>\\n    </div>\\n  </div>\\n  <div class=\\\'enemy-selector\\\'>\\n      \' + enemyType() + \'\\n  </div>\';\n}\n\nfunction levelSettings() {\n  return \'<div class="level-settings">\\n    <div class="param">\\n      <span>level name: </span>\\n      <input type="text" class="level-setting-name"/>\\n      <span class="btn" data-setting="name">ok</span>\\n    </div>\\n\\n    <br/>\\n\\n    <div class="param">\\n      <span>columns: </span>\\n      <input type="text" class="level-setting-col"/>\\n    </div>\\n    <div class="param">\\n      <span>rows: </span>\\n      <input type="text" class="level-setting-row"/>\\n    </div>\\n    <div class="param btn size" data-setting="size">\\n      ok\\n    </div>\\n\\n  </div>\';\n}\n\nfunction publishLevel() {\n  return \'<div class="info-txt publish-text">\\n    <div>Are you sure you want to publish this level?</div>\\n    <br/>\\n    <div class="btn">Yes!</div>\\n  </div>\';\n}\n\nfunction renderPublishFailed() {\n  return \'<div>\\n    Uploading failed!\\n  </div>\';\n}\n\nfunction renderPublishSuccess(id) {\n  return \'<div>\\n    Level successfully saved & published.\\n  </div>\\n  <br/>\\n  <div>You can find your custom level at</div>\\n  <div class="publish-link"><a href="http://localhost:3000/level/\' + id + \'">madalin.ski/game/level/<span>\' + id + \'</span></a></div>\';\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/js/editorTools.js\n ** module id = 21\n ** module chunks = 0 1\n **/\n//# sourceURL=webpack:///./src/js/editorTools.js?')},function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _stringify = __webpack_require__(8);\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nexports.default = publish;\n\nvar _jquery = __webpack_require__(2);\n\nvar _jquery2 = _interopRequireDefault(_jquery);\n\nvar _editorTools = __webpack_require__(21);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n//let json = JSON.stringify({name: \"tadic\", shirt: 11});\n\nfunction publish(data) {\n  data.submitBy = 'user';\n\n  data = (0, _stringify2.default)(data);\n\n  _jquery2.default.ajax({\n    type: 'POST',\n    dataType: 'json',\n    contentType: 'application/json',\n    url: 'http://localhost:3000/levelpublish',\n    data: data,\n    success: function success(res) {\n      if (res.status === \"success\") {\n        console.log(\"SAVE SUCCESS\");\n        (0, _jquery2.default)('.publish-text').empty();\n        (0, _jquery2.default)('.publish-text').append((0, _editorTools.renderPublishSuccess)(res.levelID));\n      } else {\n        (0, _jquery2.default)('.publish-text').empty();\n        (0, _jquery2.default)('.publish-text').append((0, _editorTools.renderPublishFailed)());\n      }\n      console.log('AJAX RESPONSE: ');\n      console.log(res);\n    }\n  });\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/js/publish.js\n ** module id = 22\n ** module chunks = 0 1\n **/\n//# sourceURL=webpack:///./src/js/publish.js?")},function(module,exports){eval("// removed by extract-text-webpack-plugin\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/main.scss\n ** module id = 23\n ** module chunks = 0 1\n **/\n//# sourceURL=webpack:///./src/main.scss?")}]);